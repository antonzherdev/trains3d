package com.antonzherdev.geometry

import core.math._

struct vec2(x : float4, y : float4) extends Comparable<vec2> {
    static def apply(vec2i : vec2i) = vec2(vec2i.x, vec2i.y)

    def add(vec2 : vec2) = vec2(x + vec2.x, y + vec2.y)
    def add(f4 : float4) = vec2(x + f4, y + f4)
    def add(f : float) = vec2(x + f, y + f)
    def add(i : int) = vec2(x + i, y + i)

    def sub(vec2 : vec2) = vec2(x - vec2.x, y - vec2.y)
    def sub(f4 : float4) = vec2(x - f4, y - f4)
    def sub(f : float) = vec2(x - f, y - f)
    def sub(i : int) = vec2(x - i, y - i)

    def mul(vec2 : vec2) = vec2(x*vec2.x, y*vec2.y)
    def mul(f4 : float4) = vec2(x*f4, y*f4)
    def mul(f : float) = vec2(x*f, y*f)
    def mul(i : int) = vec2(x*i, y*i)

    def div(vec2 : vec2) = vec2(x/vec2.x, y/vec2.y)
    def div(f4 : float4) = vec2(x/f4, y/f4)
    def div(f : float) = vec2(x/f, y/f)
    def div(i : int) = vec2(x/i, y/i)

    def negate = vec2(-x, -y)
    def degreeAngle : float4 = 180.0 / M_PI * atan2(y, x)
    def angle : float4 = atan2(y, x)
    def dot(vec2 : vec2) : float4 = x*vec2.x + y*vec2.y
    def lengthSquare : float4 = dot(self)
    def length = sqrt(lengthSquare)

    def mid(vec2 : vec2) = add(vec2).mul(0.5)
    def distanceTo(vec2 : vec2) = sub(vec2).length
    def set(length : float4) = mul(length/self.length)
    def normalize = set(length = 1.0)

    def compare(to : vec2) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }

    def rectTo(vec2 : vec2) : rect = rect(self, vec2.sub(self))
    def rectInCenterWith(size : vec2) : rect = rect((size - self)*0.5, self)
}

struct vec2i(x : int, y : int) extends Comparable<vec2i> {
    static def apply(vec2 : vec2) = vec2i(lround(vec2.x), lround(vec2.y))

    def add(vec2i : vec2i) = vec2i(x + vec2i.x, y + vec2i.y)
    def sub(vec2i : vec2i) = vec2i(x - vec2i.x, y - vec2i.y)
    def div(f4 : float4) = vec2(x.cast<float4>/f4, y.cast<float4>/f4)
    def div(f : float) = vec2(x.cast<float4>/f, y.cast<float4>/f)
    def div(i : int) = vec2i(x/i, y/i)
    def negate = vec2i(-x, -y)

    def compare(to : vec2i) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }
    def rectTo(vec2i : vec2i) : recti = recti(self, vec2i.sub(self))
}

struct vec3(x : float4, y : float4, z : float4) {
    static def apply(vec2 : vec2, z : float4) = vec3(vec2.x, vec2.y, z)
    def add(vec3 : vec3) = vec3(x + vec3.x, y + vec3.y, z + vec3.z)
    def sub(vec3 : vec3) = vec3(x - vec3.x, y - vec3.y, z - vec3.z)
    def sqr = mul(length)
    def negate = vec3(-x, -y, -z)
    def mul(k : float4) = vec3(k*x, k*y, k*z)
    def dot(vec3 : vec3) : float4 = x*vec3.x + y*vec3.y + z*vec3.z
    def lengthSquare : float4 = x*x + y*y + z*z
    def length = sqrt(lengthSquare)
    def set(length : float4) = mul(length/self.length)
    def normalize = set(length = 1.0)
    def xy = vec2(x, y)
}

struct vec4(x : float4, y : float4, z : float4, w : float4) {
    static def apply(vec3 : vec3, w : float4) = vec4(vec3.x, vec3.y, vec3.z, w)
    def xyz = vec3(x, y, z)
    def xy = vec2(x, y)
    def mul(k : float4) = vec4(k*x, k*y, k*z, k*w)
    def div(mat4 : mat4) :vec4 = mat4.divBySelf(vec4 = self)
    def div(f4 : float4) = vec4(x/f4, y/f4, z/f4, w/f4)
    def div(f : float) = vec4(x/f, y/f, z/f, w/f)
    def div(i : int) = vec4(x/i, y/i, z/i, w/i)

    def lengthSquare : float4 = x*x + y*y + z*z + w*w
    def length = sqrt(lengthSquare)
    def set(length : float4) = mul(length/self.length)
    def normalize = set(length = 1.0)
}

struct Quad(p1 : vec2, p2 : vec2, p3 : vec2, p4 : vec2) {
    static val identity = Quad(vec2(0, 0), vec2(1, 0), vec2(1, 1), vec2(0, 1))
    static def apply(size : float4) = Quad(vec2(-size, -size), vec2(size, -size), vec2(size, size), vec2(-size, size))
    def mul(value : float4) = Quad(p1.mul(value), p2.mul(value), p3.mul(value), p4.mul(value))
    def add(vec2 : vec2) = Quad(p1.add(vec2), p2.add(vec2), p3.add(vec2), p4.add(vec2))
    def add(x : float4, y : float4) = add(vec2(x, y))

    def quadrant :Quadrant = {
        val x = (p2.x - p1.x)/2
        val y = (p4.y - p1.y)/2
        val q = mul(0.5).add(p1)
        Quadrant([q, q.add(x, 0), q.add(x, y), q.add(0, y)])
    }
}

struct Quadrant(quads : Quad[4]) {
    def randomQuad = quads[randomMax(3)]
}

struct rect(origin : vec2, size : vec2) {
    static def apply(x : float4, y : float4, width : float4, height : float4) = rect(vec2(x, y), vec2(width, height))

    def x = origin.x
    def y = origin.y
    def x2 : float4 = origin.x + size.x
    def y2 : float4 = origin.y + size.y
    def width : float4 = size.x
    def height : float4 = size.y
    def contains(vec2 : vec2) : bool =
        origin.x <= vec2.x
        && vec2.x <= origin.x + size.x
        && origin.y <= vec2.y
        && vec2.y <= origin.y + size.y

    def add(vec2 : vec2) = rect(origin.add(vec2), size)

    def intersects(rect : rect) : bool =
        origin.x <= rect.x2 && x2 >= rect.origin.x &&
        origin.y <= rect.y2 && y2 >= rect.origin.y

    def thicken(halfSize : vec2) = rect(origin.sub(halfSize), size.add(halfSize.mul(2)))
    def div(vec2 : vec2) = rect(origin/vec2, size/vec2)

    def leftBottom = origin
    def leftTop = vec2(origin.x, origin.y + size.y)
    def rightTop = vec2(origin.x + size.x, origin.y + size.y)
    def rightBottom = vec2(origin.x + size.x, origin.y)
}
struct recti(origin : vec2i, size : vec2i) {
    static def apply(x : float4, y : float4, width : float4, height : float4) = recti(vec2(x, y), vec2(width, height))
    static def apply(rect : rect) = recti(rect.origin, rect.size)
    def x = origin.x
    def y = origin.y
    def x2 : int = origin.x + size.x
    def y2 : int = origin.y + size.y
    def width : int = size.x
    def height : int = size.y
    def moveToCenterFor(size : vec2) = recti(size.sub(self.size).mul(0.5), self.size)
}
