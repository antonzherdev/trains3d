package com.antonzherdev.actor

class React<T> extends Observable<T> {
    static def apply<T>(value : T) : React<T> = Val<T>(value)
    static def apply<A, T>(a : React<A>, f : A -> T) : React<T> = MappedReact<A, T>(a, f)
    static def apply<A, B, T>(a : React<A>, b : React<B>, f : (A, B) -> T) : React<T> = MappedReact2<A, B, T>(a, b, f)
    static def apply<A, B, C, T>(a : React<A>, b : React<B>, c : React<C>, f : (A, B, C) -> T) : React<T> = MappedReact3<A, B, C, T>(a, b, c, f)

    static def async<A, T>(queue : DispatchQueue = DispatchQueue.default, a : React<A>, f : A -> T) : React<T> = AsyncMappedReact<A, T>(queue, a, f)
    static def async<A, B, T>(queue : DispatchQueue = DispatchQueue.default, a : React<A>, b : React<B>, f : (A, B) -> T) : React<T> = AsyncMappedReact2<A, B, T>(queue, a, b, f)
    static def async<A, B, C, T>(queue : DispatchQueue = DispatchQueue.default, a : React<A>, b : React<B>, c : React<C>, f : (A, B, C) -> T) : React<T> = AsyncMappedReact3<A, B, C, T>(queue, a, b, c, f)

    def attach(observer : Observer<T>)
    def detach(observer : Observer<T>)
    def value : T
    def map<R>(f : T -> R) : React<R> = MappedReact<T, R>(self, f)
    def asyncMap<R>(queue : DispatchQueue = DispatchQueue.default, f : T -> R) : React<R> = AsyncMappedReact<T, R>(queue, self, f)

}

class ImReact<T> extends React<T> {
    protected def attach(observer : Observer<T>) {}
    def detach(observer : Observer<T>) {}
}

class MReact<T> extends React<T> with ObservableBase<T>

class Val<T>(value : T) extends ImReact<T>

class Var<T> extends MReact<T> {
    static def apply<T>(initial : T) : Var<T> = {
        val v = Var<T>()
        v.set(value = initial)
        v
    }

    private val _value = AtomicObject<T>()
    def value : T = _value.value

    def set(value : T) {
        while(true) {
            val v = _value.value
            if(v == value) return nil
            if(_value.compareAndSet(v, value)) {
                notify(value)
                return nil
            }
        }
    }
    def update(f : T -> T) {
        while(true) {
            val v = _value.value
            val value : T = f(v)
            if(v == value) return nil
            if(_value.compareAndSet(v, value)) {
                notify(value)
                return nil
            }
        }
    }
}

abstract class ReactExpression<T> extends MReact<T> {
    private val _value = AtomicObject<T>()

    def value : T = _value.value
    protected def set(value : T) {
        while(true) {
            val v = _value.value
            if(v == value) return nil
            if(_value.compareAndSet(v, value)) {
                notify(value)
                return nil
            }
        }
    }

    def init {
        set(value = calc)
    }
    protected def recalc {
        set(value = calc)
    }

    protected def calc : T
}

final class MappedReact<A, R>(a : React<A>, f : A -> R) extends ReactExpression<R> {
    private val obsA = a.observe{newValue -> set(value = f(newValue))}

    def calc : R = f(a.value)
}

final class MappedReact2<A, B, R>(a : React<A>, b : React<B>, f : (A, B) -> R) extends ReactExpression<R> {
    private val obsA = a.observe{newValue -> set(value = f(newValue, b.value)) }
    private val obsB = b.observe{newValue -> set(value = f(a.value, newValue)) }

    def calc : R = f(a.value, b.value)

}

final class MappedReact3<A, B, C, R>(a : React<A>, b : React<B>, c : React<C>, f : (A, B, C) -> R) extends ReactExpression<R> {
    private val obsA = a.observe{newValue -> set(value = f(newValue, b.value, c.value)) }
    private val obsB = b.observe{newValue -> set(value = f(a.value, newValue, c.value)) }
    private val obsC = c.observe{newValue -> set(value = f(a.value, b.value, newValue)) }

    def calc : R = f(a.value, b.value, c.value)
}

final class AsyncMappedReact<A, R>(queue : DispatchQueue, a : React<A>, f : A -> R) extends ReactExpression<R> {
    private val obsA = a.observe{_ -> queue.async{recalc}}
    def calc : R = f(a.value)
}

final class AsyncMappedReact2<A, B, R>(queue : DispatchQueue, a : React<A>, b : React<B>, f : (A, B) -> R) extends ReactExpression<R> {
    private val obsA = a.observe{_ -> queue.async{recalc}}
    private val obsB = b.observe{_ -> queue.async{recalc}}
    def calc : R = f(a.value, b.value)
}

final class AsyncMappedReact3<A, B, C, R>(queue : DispatchQueue, a : React<A>, b : React<B>, c : React<C>, f : (A, B, C) -> R) extends ReactExpression<R> {
    private val obsA = a.observe{_ -> queue.async{recalc}}
    private val obsB = b.observe{_ -> queue.async{recalc}}
    private val obsC = c.observe{_ -> queue.async{recalc}}
    def calc : R = f(a.value, b.value, b.value)
}

final class ReactFlag(initial : bool, reacts : [React<_>]) extends Var<bool> {
    private val observers = reacts.chain.map{r ->
        r.observe{_ ->
            set(value = true)
        }
    }.toArray

    def init {
        set(value = initial)
    }

    def set {
        set(value = true)
    }

    def clear {
        set(value = false)
    }

    def process(f : () -> void) {
        if(value) {
            f()
            clear
        }
    }
}