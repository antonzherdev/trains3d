package com.antonzherdev.actor

class TypedActor {
    def future<T>(f : void -> T) : Future<T> = {
        TypedActorFuture(self, prompt = false, f)
    }

    def prompt<T>(f : void -> T) : Future<T> = {
        TypedActorFuture(self, prompt = true, f)
    }

    private weak var _actor : self = nil
    private var _setup = false
    def actor : self = {
        val a = _actor
        Memory.memoryBarrier
        if(a == nil) {
            synchronized(self) {
                if(_actor == nil) {
                    if(_setup) {
                        throw "WARNING: Incorrect actor reference using"
                        //log("WARNING: Incorrect actor reference using")
                    }
                    val act = Actors.typed(self)
                    Memory.memoryBarrier
                    _actor = act
                    _setup = true
                    act
                } else {
                    _actor
                }
            }
        } else _actor
    }

    def lockAndOnSuccess<T, R>(future : Future<T>, f : T -> R) : Future<R> = {
        var res : T
        val fut = TypedActorFuture(self, prompt = false) {
            f(res)
        }
        fut.lock
        future.onComplete { tr ->
            if(tr.isFailure) fut.complete(tr)
            else {
                res = tr.get
                fut.unlock
            }
        }
        fut
    }
}