package com.antonzherdev.actor


trait Observable<T> {
    def attach(observer : Observer<T>)
    def detach(observer : Observer<T>)

    def observe(weak f : T -> void) : Observer<T> = {
        val obs = Observer<T>(observable = self, f)
        attach(obs)
        obs
    }
}

trait ObservableBase<T> extends Observable<T> {
    private val _observers = AtomicObject<[Weak<Observer<T>>]>([])
    def attach(observer : Observer<T>) {
        while(true) {
            val v = _observers.value
            if(_observers.compareAndSet(v, v + Weak(observer))) {
                return nil
            }
        }
    }

    def detach(observer : Observer<T>) {
        while(true) {
            val v = _observers.value
            val nv = v.chain.filter{l ->
                val lv = l.get
                lv !== observer && lv !== nil
            }.toArray
            if(_observers.compareAndSet(v, nv)) {
                return nil
            }
        }
    }

    protected def notify(value : T) {
        _observers.value.for((o : Weak<Observer<T>>) -> o.get.f(value))
    }

    protected def hasObservers : bool = !_observers.value.isEmpty
}

class Observer<T>(observable : Observable<T>, f : T -> void) {
    def detach {
        observable.detach(observer = self)
    }
    def dealloc {
        detach
    }
}

class Signal<T> extends ObservableBase<T> {
    def post(data : T) {
        notify(data)
    }
    def post(self : Signal<void>) {
        notify(nil)
    }
}
