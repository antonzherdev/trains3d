package com.antonzherdev.actor

class Mailbox {
    private var _stopped = false
    private val _scheduled = AtomicBool()

    private val _queue = ConcurrentQueue<ActorMessage>()
    def send(message : ActorMessage) {
        if(_stopped) return nil

        if(message.prompt) {
            if(!_scheduled.getAndSet(true)) {
                if(_queue.isEmpty) {
                    message.process
                    Memory.memoryBarrier
                    if(_queue.isEmpty) {
                        _scheduled.set(false)
                        Memory.memoryBarrier
                        if(!_queue.isEmpty) {
                            trySchedule
                        }
                    } else {
                        schedule
                    }
                } else {
                    _queue.enqueue(message)
                    schedule
                }
            } else {
                _queue.enqueue(message)
                trySchedule
            }
        } else {
            _queue.enqueue(message)
            trySchedule
        }
    }

    private def trySchedule {
        if(!_scheduled.getAndSet(true)) {
            schedule
        }
    }

    private def schedule {
        if(!_stopped) {
            DispatchQueue.default.async{
                Memory.autoreleasePoolStart
                processQueue
                Memory.autoreleasePoolEnd
            }
        }
    }

    private def processQueue {
        var left = 5
        var locked = false
        while(left > 0) {
            val msg = _queue.dequeue(when = message ->
                if(message.process) true
                else {
                    locked = true
                    message.onUnlock{
                        if(self != nil) schedule
                    }
                    false
                }
            )
            if(msg.isEmpty) break
            left--
        }
        if(locked) {

        } else if(_queue.isEmpty) {
            _scheduled.set(false)
            Memory.memoryBarrier
            if(!_queue.isEmpty) {
                trySchedule
            }
        } else {
            schedule
        }
    }

    def stop {
        _stopped = true
        Memory.memoryBarrier
        _queue.clear
    }

    def isEmpty : bool = _queue.isEmpty
}


trait ActorMessage{
    def sender : Actor
    def receiver : Actor
    def prompt : bool
    def process : bool
    def onUnlock(weak f : () -> void)
}


class ActorFuture<T>(receiver : Actor, prompt : bool, f : void -> T) extends DefaultPromise<T> with ActorMessage {
    private var _completed = false
    def process : bool =
        if(_completed) true
        else if(_locked) false
        else success(f())


    def sender : Actor = nil

    private var _locked = false
    def lock {
        _locked = true
    }
    def unlock {
        _locked = false
        while(true) {
            val v = _unlocks.value
            if(_unlocks.compareAndSet(v, nil)) {
                v.for{f -> f()}
                return nil
            }
        }
    }
    private val _unlocks = AtomicObject<[() -> void]>([])
    def onUnlock(weak f : () -> void) {
        while(true) {
            val v = _unlocks.value
            if(!_locked) {
                f()
                return nil
            }
            if(_unlocks.compareAndSet(v, v + f)) {
                return nil
            }
        }
    }
    def isLocked = _locked
    def complete(value : Try<T>) : bool = {
        val ret = super.complete(value)
        if(ret) {
            _completed = true
            _locked = false
        }
        ret
    }
}