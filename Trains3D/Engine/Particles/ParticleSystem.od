package com.antonzherdev.eg

import core.math._


trait ParticleSystem <P extends Particle> extends Updatable {
    def particles : [P]

    def updateWith(delta : float) {
        particles.for(_.updateWith(delta))
    }
}

trait Particle extends Updatable  {
    def writeTo(array : VoidRefArray) : VoidRefArray
}

class ParticleSystemView<P extends Particle, D, M>(
    system : ParticleSystem<P>, vbDesc : VertexBufferDesc<D>, maxCount : uint,
    shader : Shader<M>, material : M, blendFunc : BlendFunction)
{
    def vertexCount : uint
    def index(vertexCount : uint, maxCount : uint) : IndexSource
    def indexCount : uint


    val vertexArr = VoidRefArray(vbDesc.dataType, maxCount*vertexCount)
    val vertexBuffer = VBO.mut<D>(vbDesc)
    val index : IndexSource = index(vertexCount, maxCount)
    val vao = Mesh<D>(vertex = vertexBuffer, index).vao(shader)

    def draw {
        val particles = system.particles
        if(particles.isEmpty) return nil


        var i = 0

        vertexBuffer.write(count = vertexCount * maxCount.min(particles.count)) { vertexPointer ->
            var p = vertexPointer
            particles.go{particle ->
                if(i < maxCount) {
                    p = particle.writeTo(p)
                    i++
                    true
                } else false
            }
        }


        context.depthTest.disabled{ context.cullFace.disabled{ blendFunc {
            vao.draw(material, 0, indexCount * i)
        }}}
    }

//    def dealloc {
//        vertexArr.free
//    }
}

trait IBOParticleSystemView {
    def writeIndexesTo(indexPointer : VoidRefArray, i : uint4) : VoidRefArray
    def vertexCount : uint
    def indexCount : uint = 3*(vertexCount - 2)

    def index(vertexCount : uint, maxCount : uint) : MutableIndexSourceGap = {
        val vc = vertexCount
        val ia = VoidRefArray(UInt4.type, indexCount*maxCount)
        var indexPointer = ia
        maxCount.range.for{i ->
            indexPointer = writeIndexesTo(indexPointer, i*vc)
        }
        val ib = IBO(ia)
        ia.free
        ib
    }
}

trait IBOParticleSystemViewQuad extends IBOParticleSystemView {
    def vertexCount : uint = 4
    def indexCount : uint = 6

    def writeIndexesTo(indexPointer : VoidRefArray, i : uint4) : VoidRefArray = {
        indexPointer
        .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
        .write(uInt4 = i + 2).write(uInt4 = i).write(uInt4 = i + 3)
    }
}

class EmissiveParticleSystem <P extends EmittedParticle> extends ParticleSystem<P> {
    private val _particles = MutableList<P>()
    def particles : [P] = _particles

    def generateParticle : P
    def generateParticlesWith(delta : float) {}

    def emitParticle {
        _particles.append(generateParticle)
    }

    def updateWith(delta : float) {
        generateParticlesWith(delta)

        _particles.mutableFilter { p ->
            p.updateWith(delta)
            p.isLive
        }
    }

    def hasParticles = !_particles.isEmpty
}

class EmittedParticle(lifeLength : float4) extends Particle {
    private var _lifeTime : float4
    def lifeTime : float4 = _lifeTime

    def isLive : bool  = _lifeTime <= lifeLength

    def updateWith(delta : float) {
        _lifeTime += delta
        update(t = _lifeTime, dt = delta)
    }

    def update(t : float4, dt : float4)
    def writeTo(array : VoidRefArray) : VoidRefArray
}
