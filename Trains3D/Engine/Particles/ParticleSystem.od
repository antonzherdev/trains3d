package com.antonzherdev.eg

import core.math._


class ParticleSystem <P extends Particle> extends Actor {
    protected def particles : Seq<P>

    def updateWith(delta : float) : Future<void> = future{
        doUpdateWith(delta)
    }
    protected def doUpdateWith(delta : float) {
        particles.for(p : Particle -> {
            p.updateWith(delta)
        })
    }

    var _lastWriteCount : uint = 0
    def lastWriteCount = prompt {
        _lastWriteCount
    }
    def writeTo(maxCount : uint, array : VoidRefArray) : Future<void> = future {
        doWriteTo(maxCount, array)
    }

    protected def doWriteTo(maxCount : uint, array : VoidRefArray) {
        var p = array
        var i : uint = 0
        particles.go{particle ->
        if(i < maxCount) {
            p = particle.writeTo(p)
            i++
            true
        } else false
        }
        _lastWriteCount = i
    }
}

trait Particle extends Updatable  {
    def writeTo(array : VoidRefArray) : VoidRefArray
    def updateWith(delta : float)
}


class EmissiveParticleSystem <P extends EmittedParticle> extends ParticleSystem<P> {
    protected def particles : Seq<P> = _particles
    val _particles = MArray<P>()

    def generateParticle : P
    def generateParticlesWith(delta : float) {}

    def emitParticle {
        _particles.append(generateParticle)
    }

    protected def doUpdateWith(delta : float) {
        generateParticlesWith(delta)

        _particles.mutableFilter { p ->
            p.cast<Particle>.updateWith(delta)
            p.isLive
        }
    }

    def hasParticles = !_particles.isEmpty
}

class EmittedParticle(lifeLength : float4) extends Particle {
    private var _lifeTime : float4
    def lifeTime : float4 = _lifeTime

    def isLive : bool  = _lifeTime <= lifeLength

    def updateWith(delta : float) {
        _lifeTime += delta
        update(t = _lifeTime, dt = delta)
    }

    def update(t : float4, dt : float4)
    def writeTo(array : VoidRefArray) : VoidRefArray
}
