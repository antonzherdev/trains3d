package com.antonzherdev.eg

object BillboardShaderSystem extends ShaderSystem<ColorSource> {
    def shaderFor(param : ColorSource) : BillboardShader =
        if(context.renderTarget.is<ShadowRenderTarget>)
            if(ShadowShaderSystem.isColorShaderFor(param)) BillboardShader.instanceForColorShadow
            else BillboardShader.instanceForTextureShadow
        else if(param.texture.isEmpty) BillboardShader.instanceForColor else BillboardShader.instanceForTexture
}

class BillboardShaderBuilder(texture : bool, shadow : bool, parameters : string, code : string) extends ShaderTextBuilder {
    def vertex =
        "$vertexHeader
         $ain highp vec3 position;
         $ain lowp vec2 model;
        $if(texture)
         $ain mediump vec2 vertexUV;
         $out mediump vec2 UV;
        $endif
         $ain lowp vec4 vertexColor;

         uniform mat4 wc;
         uniform mat4 p;
         $out vec4 fColor;
         $parameters

         void main(void) {
             highp vec4 pos = wc*vec4(position, 1);
             pos.x += model.x;
             pos.y += model.y;
             gl_Position = p*pos;
             UV = vertexUV;$when(texture)
             fColor = vertexColor;
             $code
         }"
    def fragment =
        "$versionString

        $if(texture)
         $in mediump vec2 UV;
         uniform lowp sampler2D texture;
        $endif
         uniform lowp vec4 color;
         uniform lowp float alphaTestLevel;
         $in lowp vec4 fColor;
        $if(shadow)
         out float depth;
        $else
         $fragColorDeclaration
        $endif

         $parameters
         void main(void) {
             lowp vec4 fragColor;$when(shadow && !isFragColorDeclared)
            $if(texture)
             $fragColor = fColor * color * $texture2D\(texture, UV);
            $else
             $fragColor = fColor * color;
            $endif
             if($fragColor.a < alphaTestLevel) {
                 discard;
             }
             depth = gl_FragCoord.z;$when(shadow)
             $code
         }"

    def program = ShaderProgram(vertex, fragment)
}

class BillboardShader(program : ShaderProgram, texture : bool, shadow : bool) extends Shader<ColorSource>(program) {
    static lazy val instanceForColor = BillboardShader(BillboardShaderBuilder(false, false, "", "").program, false, false)
    static lazy val instanceForTexture = BillboardShader(BillboardShaderBuilder(true, false, "", "").program, true, false)
    static lazy val instanceForColorShadow = BillboardShader(BillboardShaderBuilder(false, true, "", "").program, false, true)
    static lazy val instanceForTextureShadow = BillboardShader(BillboardShaderBuilder(true, true, "", "").program, true, true)

    val positionSlot = attributeFor("position")
    val modelSlot = attributeFor("model")
    val uvSlot : ShaderAttribute? = if(texture) attributeFor("vertexUV") else nil
    val colorSlot = attributeFor("vertexColor")
    val colorUniform = uniformVec4("color")
    val alphaTestLevelUniform = uniformF4("alphaTestLevel")

    val wcUniform = uniformMat4("wc")
    val pUniform = uniformMat4("p")

    def load(vbDesc : VertexBufferDesc<_>, param : ColorSource) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 3, GL_FLOAT, shift = vbDesc.position)
        modelSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, shift = vbDesc.model)
        colorSlot.setFromBufferWith(vbDesc.stride, valuesCount = 4, GL_FLOAT, shift = vbDesc.color)
        wcUniform(matrix = matrix.value.wc)
        pUniform(matrix = matrix.value.p)
        alphaTestLevelUniform(f4 = param.alphaTestLevel)
        if(texture) {
            uvSlot.for(_.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, shift = vbDesc.uv))
            param.texture.get.bind
        }
        colorUniform(vec4 = param.color)
    }
}

struct BillboardBufferData(position : vec3, model : vec2, color : vec4, uv : vec2)


class BillboardParticleSystem extends ParticleSystem<BillboardParticle>


class BillboardParticle(lifeLength : float4) extends Particle(lifeLength) {
    var position : vec3
    var uv : Quad
    var model : Quad
    var color : vec4

    def writeTo(array : VoidRefArray) : VoidRefArray = {
        array
            .write(BillboardBufferData, BillboardBufferData(position, model.p[0], color, uv.p[0]))
            .write(BillboardBufferData, BillboardBufferData(position, model.p[1], color, uv.p[1]))
            .write(BillboardBufferData, BillboardBufferData(position, model.p[2], color, uv.p[2]))
            .write(BillboardBufferData, BillboardBufferData(position, model.p[3], color, uv.p[3]))
    }
}

class BillboardParticleSystemView(maxCount : uint, material : ColorSource, blendFunc : BlendFunction)
    extends  ParticleSystemView<BillboardParticle, BillboardBufferData>(Billboard.vbDesc, maxCount, blendFunc)
{

    static def apply(maxCount : uint, material : ColorSource) =
        BillboardParticleSystemView(maxCount, material, BlendFunction.standard)
    val shader : Shader =  BillboardShaderSystem.shaderFor(material)
    def vertexCount : uint = 4

    def writeIndexesTo(indexPointer : VoidRefArray, i : uint4) : VoidRefArray = {
        indexPointer
            .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
            .write(uInt4 = i + 2).write(uInt4 = i).write(uInt4 = i + 3)
    }
}

class Billboard {
    static val vbDesc = VertexBufferDesc<BillboardBufferData>(BillboardBufferData.type,
        position = 0, uv = 9*4, normal = -1, color = 5*4, model = 3*4)
    var material : ColorSource
    var uv : Rect = Rect(0, 0, 1, 1)

    def draw {
        D2D.drawSprite(material, at = position, rect.quad, uv.quad)
    }

    var position : vec3 = vec3(0, 0, 0)
    var rect : Rect = Rect(0, 0, 0, 0)

    static def apply(material : ColorSource) : Billboard = {
        val ret = Billboard()
        ret.material = material
        ret
    }

    def contains(vec2 : vec2) : bool = {
        val pp = matrix.value.wc.mul(vec4(position, 1))
        matrix.value.p.mul(rect + pp.xy, pp.z).contains(vec2)
    }
}