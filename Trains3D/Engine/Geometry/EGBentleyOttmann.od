import EGTypes
import EGFigure
import CNTreeMap
import CNTreeSet


class EGBentleyOttmann {
    static def intersectionsFor<T>(segments : [(T, EGLineSegment)]) : [EGBentleyOttmannIntersection] =
        intersectionsMap(segments).values

    static private def intersectionsMap<T>(segments : [(T, EGLineSegment)]) : [EGPoint : [EGBentleyOttmannIntersection]] =
        if(segments.count < 2) []
        else {
            val sweepLine = EGSweepLine.new
            val queue = EGBentleyOttmannEventQueue.newWith(segments, sweepLine)

            while(!queue.isEmpty) {
                val events = queue.poll
                sweepLine.handle(events)
            }
            sweepLine.intersections
        }
}

class EGBentleyOttmannEvent<T> {
    def point : EGPoint
    def isIntersection : bool
    def isStart : bool
    def isEnd : bool = !isStart && !isIntersection
}

class EGBentleyOttmannPointEvent<T>(isStart : bool, data : T, segment : EGLineSegment, point : EGPoint) extends EGBentleyOttmannEvent<T> {
    def isIntersection = false
}
class EGBentleyOttmannIntersection<T>(data1 : T, data2 : T, point : EGPoint) extends EGBentleyOttmannEvent<T> {
    def isIntersection = true
    def isStart = false
}


class EGBentleyOttmannEventQueue<T> {
    val events = CNTreeMap<EGPoint, [var EGBentleyOttmannEvent<T>]>((a, b) -> a.compare(b))

    def isEmpty : bool = events.isEmpty

    static def newWith<T>(segments : [(T, EGLineSegment)], sweepLine : EGSweepLine) : EGBentleyOttmannEventQueue<T> {
        val ret = EGBentleyOttmannEventQueue.new<T>
        if(!(segments.isEmpty)) {
            val xs = CNTreeSet.new<float>
            segments.for(s -> {
                val segment : EGLineSegment = s.b
                xs.add(segment.p1.x)
                xs.add(segment.p2.x)
                ret.offer(segment.p1, EGBentleyOttmannPointEvent(true, s.a, s, segment.p1))
                ret.offer(segment.p2, EGBentleyOttmannPointEvent(false, s.a, s, segment.p2))
            })

            val minY = xs.head.get
            val maxY = xs.last.get
            val minDeltaX = xs.chain.neighbors.map(pair -> pair.b - pair.a).min.get
            val slope = (minY - maxY)/minDeltaX*1000
            sweepLine.sweepLine = EGLine.newWith(slope, EGPoint(0, 0))
            sweepLine.queue = ret
        }
        ret
    }

    def offer(point : EGPoint, event : EGBentleyOttmannEvent) {
        events.objectFor(key = point, orUpdateWith = []).add(event)
    }

    def poll : [EGBentleyOttmannEvent] {
        events.pollFirst.get.b
    }
}

class EGSweepLine<T>
    /**
    * Whether to ignore intersections of line segments when both
    * their end points form the intersection point.
    */
//    ignoreSegmentEndings : bool
{
    private var events = CNTreeSet.newWith<EGBentleyOttmannEvent<T>>((a, b) -> compareEvents(a, b))

    /**
    * A map holding all intersection points mapped to the Events
    * that form these intersections.
    */
    val intersections : [var EGPoint : [var EGBentleyOttmannEvent<T>]] = []

    /**
    * The line sweeping from left to right.
    */
    var sweepLine : EGSlopeLine = nil

    /**
    * The point of the current Event.
    */
    private var currentEventPoint : EGPoint

    /**
    * A flag to indicate if we're slightly before or after the line.
    */
    private var before : bool = true

    /**
    * The queue associated with this sweep line.
    */
    var queue : EGBentleyOttmannEventQueue = nil

    def handle(events : [EGBentleyOttmannEvent<T>]) {
        sweepTo(events[0])
        events.for(handleOne(event = _))
    }

    private def sweepTo(event : EGBentleyOttmannEvent<T>) {
        currentEventPoint = event.point
        sweepLine = EGSlopeLine(sweepLine.slope, currentEventPoint)
    }

    private def handleOne(event : EGBentleyOttmannEvent<T>) {
        if(event.isStart) {
            before = false
            events.add(event)
            above(event).for(checkIntersection(event, _))
            below(event).for(checkIntersection(event, _))
        } else if(event.isEnd) {
            before = true
            events.remove(event)
            above(event).for(a ->  below(event).for(b -> checkIntersection(a, b)))
        } else {
            before = true
            val set = intersections[event.point].get
            val toInsert = set.filter(events.remove(_)).reverse.toArray
            before = false
            toInsert.for(e -> {
                events.add(e)
                above(e).for(checkIntersection(e, _))
                below(e).for(checkIntersection(e, _))
            })
        }
    }

    private def above(event : EGBentleyOttmannEvent<T>) : EGBentleyOttmannEvent<T>? {
        return events.higherThan(event)
    }

    private def below(event : EGBentleyOttmannEvent<T>) : EGBentleyOttmannEvent<T>? {
        return events.lowerThan(event)
    }

    private def checkIntersection(a : EGBentleyOttmannPointEvent<T>, b : EGBentleyOttmannPointEvent<T>) {
        // Get the intersection point between 'a' and 'b'.
        a.segment.intersectionWith(b.segment).for(p -> {
            // If the intersection is formed by both the segment endings AND
            // ignoreSegmentEndings is true, return from this method.
            if(!a.segment.endingsContain(p) && !b.segment.endingsContain(p)/* && ignoreSegmentEndings*/) {

                // Add the intersection.
                val existing = intersections.objectFor(key = p, orUpdateWith = [])
                existing.add(a)
                existing.add(b)

                // If the intersection occurs to the right of the sweep line, OR
                // if the intersection is on the sweep line and it's above the
                // current event-point, add it as a new Event to the queue.
                if(sweepLine.isRight(p) || (sweepLine.contains(p) && p.y > currentEventPoint.y)) {
                    val intersection = EGBentleyOttmannIntersection<T>(a.data, b.data, p)
                    queue.offer(p, intersection)
                }
            }
        })
    }

    private def compareEvents(a : EGBentleyOttmannEvent<T>, b : EGBentleyOttmannEvent<T>) : int = {
        // Equal Events.
        if (a == b) return 0
        // Get both intersection points.
        val ipA = a.intersectionWith(sweepLine)
        val ipB = b.intersectionWith(sweepLine)

        // Get the difference between the Event's locations (y coordinate)
        // they pass through the sweep line.
        val deltaY = ipA.y - ipB.y

        if (!deltaY.equals(Rational.ZERO)) {
        // The intersect the sweep line at different points, let the
        // Event with the lower intersection come before the other.
            if(deltaY < 0) -1 else 1
        }
        else {
            val thisSlope = a.segment.line.slope
            val thatSlope = b.segment.line.slope

            // If the slopes differ, let the one with the Event with the least
            // slope become before the other
            if(thisSlope != thatSlope) {
                if(sweepLine.isBefore()) {
                    if(thisSlope > thatSlope) -1 else 1
                } else {
                    if(thisSlope > thatSlope) 1 else -1
                }
            } else {

                // Equal slopes and going through the same point in the sweep
                // line: find an arbitrary attribute that differs 'this' from that.

                // Check if the first (left most) point differ.
                val deltaXP1 = a.segment.p1.x - b.segment.p1.x
                if(deltaXP1 != 0) {
                    if(deltaXP1 < 0) -1 else 1
                } else {
                    // Their left most points are the same, then their right most
                    // points must be different.
                    val deltaXP2 = a.segment.p2.x - that.segment.p2.x
                    if(deltaXP2 < 0) -1 else 1
                }
            }
        }
    }
}