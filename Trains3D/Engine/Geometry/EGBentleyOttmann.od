import EGTypes
import EGFigure
import CNTreeMap
import CNTreeSet


class EGBentleyOttmann {
    static def intersectionsFor<T>(segments : [(T, EGLineSegment)]) : [EGIntersection] =
        if(segments.count < 2) []
        else {
            val sweepLine = EGSweepLine.new
            val queue = EGBentleyOttmannEventQueue.newWith(segments, sweepLine)

            while(!queue.isEmpty) {
                val events = queue.poll
                sweepLine.handle(events)
            }
            sweepLine.intersections.chain.map(p -> EGIntersection<T>(p.a, p.b.map(_.data).toArray)).toArray
        }
}

class EGIntersection<T>(point : EGPoint, data : [T])

class EGBentleyOttmannEvent<T> {
    def point : EGPoint
    def isIntersection : bool
    def isStart : bool
    def isEnd : bool = !isStart && !isIntersection
    def yFor(x : float) : float
    def slope : float
}

class EGBentleyOttmannPointEvent<T>(isStart : bool, data : T, segment : EGLineSegment, point : EGPoint) extends EGBentleyOttmannEvent<T> {
    def isIntersection = false
    def yFor(x : float) : float =
        if(segment.line.isVertical) segment.p1.y
        else segment.line.cast<EGSlopeLine>.yFor(x)
    def slope : float = segment.line.slope
}
class EGBentleyOttmannIntersectionEvent<T>(point : EGPoint) extends EGBentleyOttmannEvent<T> {
    def isIntersection = true
    def isStart = false
    def yFor(x : float) : float = point.y
    def slope : float = 0
}


class EGBentleyOttmannEventQueue<T> {
    val events = CNTreeMap<EGPoint, [var EGBentleyOttmannEvent<T>]>((a, b) -> a.compare(b))

    def isEmpty : bool = events.isEmpty

    static def newWith<T>(segments : [(T, EGLineSegment)], sweepLine : EGSweepLine) : EGBentleyOttmannEventQueue<T> {
        val ret = EGBentleyOttmannEventQueue.new<T>
        if(!(segments.isEmpty)) {
            segments.for(s -> {
                val segment : EGLineSegment = s.b
                ret.offer(segment.p1, EGBentleyOttmannPointEvent(true, s.a, segment, segment.p1))
                ret.offer(segment.p2, EGBentleyOttmannPointEvent(false, s.a, segment, segment.p2))
            })
            sweepLine.queue = ret
        }
        ret
    }

    def offer(point : EGPoint, event : EGBentleyOttmannEvent) {
        events.objectFor(key = point, orUpdateWith = []).add(event)
    }

    def poll : [EGBentleyOttmannEvent] {
        events.pollFirst.get.b
    }
}

class EGSweepLine<T>
    /**
    * Whether to ignore intersections of line segments when both
    * their end points form the intersection point.
    */
//    ignoreSegmentEndings : bool
{
    private var events = CNTreeSet.newWith<EGBentleyOttmannEvent<T>>((a, b) -> compareEvents(a, b))

    /**
    * A map holding all intersection points mapped to the Events
    * that form these intersections.
    */
    val intersections : [var EGPoint : [var EGBentleyOttmannPointEvent<T>]] = []


    /**
    * The point of the current Event.
    */
    private var currentEventPoint : EGPoint

    /**
    * The queue associated with this sweep line.
    */
    var queue : EGBentleyOttmannEventQueue = nil

    def handle(events : [EGBentleyOttmannEvent<T>]) {
        sweepTo(events[0])
        events.for(handleOne(event = _))
    }

    private def sweepTo(event : EGBentleyOttmannEvent<T>) {
        currentEventPoint = event.point
    }

    private def handleOne(event : EGBentleyOttmannEvent<T>) {
        if(event.isStart) {
            events.add(event)
            checkIntersection(event, above(event))
            checkIntersection(event, below(event))
        } else if(event.isEnd) {
            events.remove(event)
            checkIntersection(above(event), below(event))
        } else {
            val set = intersections[event.point].get
            val toInsert = set.filter(events.remove(_)).reverse.toArray
            toInsert.for(e -> {
                events.add(e)
                checkIntersection(e, above(e))
                checkIntersection(e, below(e))
            })
        }
    }

    private def above(event : EGBentleyOttmannEvent<T>) : EGBentleyOttmannPointEvent<T>? =
        return events.higherThan(event)


    private def below(event : EGBentleyOttmannEvent<T>) : EGBentleyOttmannPointEvent<T>? =
        return events.lowerThan(event)


    private def checkIntersection(a : EGBentleyOttmannEvent<T>?, b : EGBentleyOttmannEvent<T>?) {
        if(a.isDefined && b.isDefined && a.get.is<EGBentleyOttmannPointEvent<T>> && b.get.is<EGBentleyOttmannPointEvent<T>>) {
            val aa = a.get.cast<EGBentleyOttmannPointEvent<T>>
            val bb = b.get.cast<EGBentleyOttmannPointEvent<T>>
            // Get the intersection point between 'a' and 'b'.
            aa.segment.intersectionWith(bb.segment).for(pp -> {
                val p : EGPoint = pp
                // If the intersection is formed by both the segment endings AND
                // ignoreSegmentEndings is true, return from this method.
                if(!aa.segment.endingsContain(p) && !bb.segment.endingsContain(p)/* && ignoreSegmentEndings*/) {

                    // Add the intersection.
                    val existing = intersections.objectFor(key = pp, orUpdateWith = [])
                    existing.add(aa)
                    existing.add(bb)

                    // If the intersection occurs to the right of the sweep line, OR
                    // if the intersection is on the sweep line and it's above the
                    // current event-point, add it as a new Event to the queue.
                    if(p.x > currentEventPoint.x || (p.x == currentEventPoint.x && p.y > currentEventPoint.y)) {
                        val intersection = EGBentleyOttmannIntersectionEvent<T>(p)
                        queue.offer(p, intersection)
                    }
                }
            })
        }
    }

    private def compareEvents(a : EGBentleyOttmannEvent<T>, b : EGBentleyOttmannEvent<T>) : int = {
        // Equal Events.
        if (a == b) return 0

        val ay = a.yFor(currentEventPoint.x)
        val by = b.yFor(currentEventPoint.x)

        var c = ay.compare(by)
        if(c == 0) {
            c = a.slope.compare(b.slope)
            if(c == 0) {
                c = a.point.x.compare(b.point.x)
            }
        }
        c
    }
}