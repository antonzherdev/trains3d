import EGTypes

class EGLine {
    static def newWith(slope : float, point : EGPoint) : EGLine = EGSlopeLine(slope, calculateConstantWith(slope, point))
    static def newWith(p1 : EGPoint, p2 : EGPoint) : EGLine =
        if(p1.x == p2.x) EGVerticalLine(p1.x)
        else {
            val slope = calculateSlopeWith(p1, p2)
            EGSlopeLine(slope, calculateConstantWith(slope, p1))
        }

    static def calculateSlopeWith(p1 : EGPoint, p2 : EGPoint) : float = (p2.y - p1.y)/(p2.x - p1.x)
    static def calculateConstantWith(slope : float, point : EGPoint) : float = point.y - slope*point.x

    def contains(point : EGPoint) : bool
    def isVertical : bool
    def isHorizontal : bool

    def intersectionWith(line : EGLine) : EGPoint?
    def xIntersectionWith(line : EGLine) : float

    def isRight(point : EGPoint) : bool
    def slope : float
    def moveWith(distance : float) : self

    def angle : float
    def degreeAngle : float = angle*180/M_PI

    def perpendicularWith(point : EGPoint) : EGLine
}

class EGSlopeLine(slope : float, constant : float) extends EGLine {
    def contains(point : EGPoint) : bool = point.y == slope*point.x + constant
    def isVertical : bool = false
    def isHorizontal : bool = slope == 0
    def xIntersectionWith(line : EGLine) : float =
        if(line.isVertical) line.xIntersectionWith(self)
        else {
            val that = line.cast<EGSlopeLine>
            return (that.constant - self.constant)/(self.slope - that.slope)
        }
    def yFor(x : float) : float = {
        return slope*x + constant
    }
    def intersectionWith(line : EGLine) : EGPoint? =
        if (!line.isVertical && line.cast<EGSlopeLine>.slope == slope) nil
        else {
            val xInt = xIntersectionWith(line)
            EGPoint(xInt, yFor(xInt))
        }

    def isRight(point : EGPoint) : bool =
        if(contains(point)) false
        else point.y < yFor(point.x)

    def moveWith(distance : float) : self = EGSlopeLine(slope, constant + distance)

    def angle : float = {
        val a = atan(slope)
        if(a < 0) M_PI + a else a
    }

    def perpendicularWith(point : EGPoint) : EGLine =
        if(slope == 0) EGVerticalLine(point.x)
        else EGLine.newWith(slope = -slope, point = point)
}

class EGVerticalLine(x : float) extends EGLine {
    def contains(point : EGPoint) : bool = point.x == x
    def isVertical : bool = true
    def isHorizontal : bool = false
    def xIntersectionWith(line : EGLine) : float = x
    def intersectionWith(line : EGLine) : EGPoint? =
        if(line.isVertical) nil
        else line.intersectionWith(self)

    def isRight(point : EGPoint) : bool = point.x > x
    def slope : float = DBL_MAX
    def moveWith(distance : float) : self = EGVerticalLine(x + distance)
    def angle : float = M_PI_2

    def perpendicularWith(point : EGPoint) : EGLine = EGSlopeLine(0, point.y)
}

trait EGFigure {
    def boundingRect : EGRect
    def segments : [EGLineSegment]
}


class EGLineSegment(p1 : EGPoint, p2 : EGPoint) extends EGFigure {
    static def newWith(p1 : EGPoint, p2 : EGPoint) : EGLineSegment =
        if(p1.compare(p2) < 0) EGLineSegment(p1, p2) else EGLineSegment(p2, p1)
    static def newWith(x1 : float, y1 : float, x2 : float, y2 : float) : EGLineSegment =
        EGLineSegment.newWith(EGPoint(x1, y1), EGPoint(x2, y2))

    private var _line : EGLine
    def line : EGLine = {
        if(_line == nil) _line = EGLine.newWith(p1 = p1, p2 = p2)
        _line
    }
    val boundingRect : EGRect = EGRect.newXY(min(p1.x, p2.x), max(p1.x, p2.x), min(p1.y, p2.y), max(p1.y, p2.y))

    def contains(point : EGPoint) : bool = {
        p1 == point || p2 == point ||
        (line.contains(point) && boundingRect.contains(point))
    }

    def containsInBoundingRect(point : EGPoint) : bool = boundingRect.contains(point)

    def intersectionWith(segment : EGLineSegment) : EGPoint? =
        if (p1 == segment.p2) p1
        else if (p2 == segment.p1) p2
        else if(p1 == segment.p1) if(line == segment.line) nil else p1
        else if(p2 == segment.p2) if(line == segment.line) nil else p2
        else line.intersectionWith(segment.line).filter(p -> containsInBoundingRect(p) && segment.containsInBoundingRect(p))

    def endingsContain(point :EGPoint) : bool = p1 == point || p2 == point
    def segments : [EGLineSegment] = [self]
    def moveWith(point : EGPoint) : EGLineSegment = moveWith(point.x, point.y)
    def moveWith(x : float, y : float) : EGLineSegment = {
        val ret = EGLineSegment(EGPoint(p1.x + x, p1.y + y), EGPoint(p2.x + x, p2.y + y))
        if(_line != nil) ret.set(line = _line.moveWith(distance = x + y))
        ret
    }
    private def set(line : EGLine) {
        self._line = line
    }
}

class EGPolygon(points : [EGPoint]) extends EGFigure {
    def boundingRect : EGRect = {
        var minX = DBL_MAX
        var maxX = DBL_MIN
        var minY = DBL_MAX
        var maxY = DBL_MIN
        points.for(p -> {
            if(p.x < minX) minX = p.x
            if(p.x > maxX) maxX = p.x
            if(p.y < minY) minY = p.y
            if(p.y > maxY) maxY = p.y
        })
        EGRect.newXY(minX, maxX, minY, maxY)
    }

    val segments : [EGLineSegment] = points.chain.neighborsRing.map(ps -> EGLineSegment.newWith(ps.a, ps.b)).toArray
}

class EGThickLineSegment(segment : EGLineSegment, thickness : float) extends EGFigure {
    def boundingRect : EGRect = segment.boundingRect.thicken(x = thickness, y = thickness)
    private var _segments : [EGLineSegment]

    def segments : [EGLineSegment] = {
        if(_segments == nil) {
            val dx : float = 0
            val dy : float = 0
            if(segment.line.isVertical) {
                dx = thickness/2
                dy = 0
            } else {
                val k = segment.line.slope
                dx = thickness/sqrt(1 + k)/2
                dy = k * dx
            }
            val line1 = segment.moveWith(-dx, dy)
            val line2 = segment.moveWith(dx, -dy)
            val line3 = EGLineSegment(line1.p1, line2.p1)
            _segments = [line1, line2, line3, line3.moveWith(segment.p2.sub(segment.p1))]
        }
        _segments
    }
}
