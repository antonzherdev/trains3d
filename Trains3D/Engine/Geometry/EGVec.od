import EGMath

struct EGVec2(x : float4, y : float4) extends ODComparable<EGVec2> {
    static def apply(point : EGVec2I) = EGVec2(point.x, point.y)

    def add(point : EGVec2) = EGVec2(x + point.x, y + point.y)
    def sub(point : EGVec2) = EGVec2(x - point.x, y - point.y)
    def negate = EGVec2(-x, -y)
    def angle : float4 = atan2(y, x)
    def dot(point : EGVec2) : float4 = x*point.x + y*point.y
    def lengthSquare : float4 = dot(self)
    def length = sqrt(lengthSquare)
    def mul(value : float4) = EGVec2(x*value, y*value)
    def div(value : float4) = EGVec2(x/value, y/value)
    def mid(point : EGVec2) = add(point).mul(0.5)
    def distanceTo(point : EGVec2) = sub(point).length
    def set(length : float4) = mul(length/self.length)
    def normalize = set(length = 1.0)

    def compare(to : EGVec2) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }
}

struct EGVec2I(x : int, y : int) extends ODComparable<EGVec2I> {
    static def apply(point : EGVec2) = EGVec2I(lround(point.x), lround(point.y))

    def add(point : EGVec2I) = EGVec2I(x + point.x, y + point.y)
    def sub(point : EGVec2I) = EGVec2I(x - point.x, y - point.y)
    def negate = EGVec2I(-x, -y)

    def compare(to : EGVec2I) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }
}

struct EGVec3(x : float4, y : float4, z : float4) {
    static def apply(vec2 : EGVec2, z : float4) = EGVec3(vec2.x, vec2.y, z)
    def add(v : EGVec3) = EGVec3(x + v.x, y + v.y, z + v.z)
    def sqr = mul(length)
    def mul(k : float4) = EGVec3(k*x, k*y, k*z)
    def dot(vec3 : EGVec3) : float = x*vec3.x + y*vec3.y + z*vec3.z
    def lengthSquare : float = x*x + y*y + z*z
    def length = sqrt(lengthSquare)
    def set(length : float) = mul(length/self.length)
    def normalize = set(length = 1.0)
}

struct EGVec4(x : float4, y : float4, z : float4, w : float4) {
    static def apply(vec3 : EGVec3, w : float4) = EGVec4(vec3.x, vec3.y, vec3.z, w)
    def xyz = EGVec3(x, y, z)
    def mul(k : float4) = EGVec4(k*x, k*y, k*z, k*w)
    def lengthSquare : float = x*x + y*y + z*z + w*w
    def length = sqrt(lengthSquare)
    def set(length : float) = mul(length/self.length)
    def normalize = set(length = 1.0)
}
