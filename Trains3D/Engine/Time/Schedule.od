package com.antonzherdev.eg

class Schedule extends Updatable {
    private var _map = MTreeMap<float, [() -> void]>()
    private var _current = 0.0
    private var _next = -1.0

    def schedule(after : float, event : () -> void) {
        _map.modify(key = _current + after, _.getOrElse([]) + event)
        _next = _map.firstKey.get
    }

    def updateWith(delta : float) {
        _current += delta
        while(_next >= 0 && _current > _next) {
            _map.pollFirst.get.b.for {event ->
                event()
            }
            _next = _map.firstKey.getOr(-1.0)
        }
    }

    def time : float = _current

    def isEmpty : bool = _next < 0.0
}

class Counter extends Updatable {
    def isRunning : bool
    def time : float
    def invTime : float = 1.0 - time
    def isStopped : bool = !isRunning

    def for(f : float -> void) {
        if(isRunning) f(time)
    }
    def updateWith(delta : float)

    static def apply(length : float) : Counter = LengthCounter(length)
    static def apply(length : float, finish : void -> void) : Counter = Finisher(LengthCounter(length), finish)
    static def apply : Counter = EmptyCounter()

    def on(time : float, event : void -> void) : Counter = EventCounter(self, time, event)
    def onEnd(event : void -> void) : Counter = Finisher(self, event)
}

class EmptyCounter extends Counter {
    def isRunning : bool = false
    def time : float = 0
    def invTime : float = 1.0
    def updateWith(delta : float) {
    }
}

class LengthCounter(length : float) extends Counter {
    private var _time : float = 0.0
    private var _run : bool = true
    def time : float = _time
    def invTime : float = 1.0 - _time
    def isRunning : bool = _run

    def updateWith(delta : float) {
        if(_run) {
            _time += delta/length
            if(_time >= 1.0) {
                _time = 1.0
                _run = false
            }
        }
    }
}

class Finisher(counter : Counter, finish : void -> void) extends Counter {
    def isRunning : bool = counter.isRunning
    def time : float = counter.time

    def updateWith(delta : float) {
        if(counter.isRunning) {
            counter.updateWith(delta)
            if(counter.isStopped) {
                finish()
            }
        }
    }
}

class EventCounter(counter : Counter, eventTime : float, event : void -> void) extends Counter {
    def isRunning : bool = counter.isRunning
    def time : float = counter.time

    private var executed = false
    def updateWith(delta : float) {
        if(counter.isRunning) {
            counter.updateWith(delta)
            if(!executed && counter.time > eventTime) {
                event()
                executed = true
            }
        }
    }
}

class CounterData<T>(counter : Counter, data : T) extends Counter {
    def isRunning : bool = counter.isRunning
    def time : float = counter.time

    def updateWith(delta : float) {
        counter.updateWith(delta)
    }
}

class MutableCounterArray<T> extends Updatable {
    private var _counters : [CounterData<T>] = []

    def counters : [CounterData<T>] = _counters
    def append(counter : CounterData<T>) {
        _counters += counter
    }

    def append(counter : Counter, data : T) {
        _counters += CounterData<T>(counter, data)
    }

    def updateWith(delta : float) {
        var hasDied = false
        _counters.for{counter ->
            counter.updateWith(delta)
            if(counter.isStopped) hasDied = true
        }
        if(hasDied) _counters = _counters.chain.filter(_.isRunning).toArray
    }

    def for(each : (CounterData<T>) -> void) {
        _counters.for(each)
    }
}