package com.antonzherdev.eg

class Recognizer<P>(tp : RecognizerType<_, P>) {
    static def apply<P>(tp : RecognizerType<LongRecognizer, P>,
        began : Event<P> -> bool, changed : Event<P> -> void, ended : Event<P> -> void)
        : Recognizer<P>
        = LongRecognizer<P>(tp, began, changed, ended, {})
    static def apply<P>(tp : RecognizerType<LongRecognizer, P>,
        began : Event<P> -> bool, changed : Event<P> -> void, ended : Event<P> -> void, canceled : Event<P> -> void)
        : Recognizer<P>
        = LongRecognizer<P>(tp, began, changed, ended, canceled)

    static def apply<P>(tp : RecognizerType<ShortRecognizer, P>, on : Event<P> -> bool)
        = ShortRecognizer<P>(tp, on)

    def is(tp : RecognizerType<_, _>) : bool = tp == self.tp

    def add(recognizer : Recognizer<_>) : Recognizers = Recognizers([self, recognizer])
}
class LongRecognizer<P>(tp : RecognizerType<LongRecognizer, P>, began : Event<P> -> bool,
    changed : Event<P> -> void, ended : Event<P> -> void, canceled : Event<P> -> void) extends Recognizer<P>(tp)
class ShortRecognizer<P>(tp : RecognizerType<ShortRecognizer, P>, on : Event<P> -> bool) extends Recognizer<P>(tp)


trait InputProcessor {
    def isProcessorActive : bool = !Director.current.isPaused
    def recognizers : Recognizers
}


class Recognizers(items : [Recognizer<_>]) {
    static def apply(recognizer : Recognizer<_>) : Recognizers = Recognizers([recognizer])

    def on<P>(event : Event<P>) : ShortRecognizer<P>? = {
        items.find{item -> item.is(event.recognizerType) && item.cast<ShortRecognizer<P>>.on(event)}
    }

    def began<P>(event : Event<P>) : LongRecognizer? = {
        items.find{item -> item.is(event.recognizerType) && item.cast<LongRecognizer<P>>.began(event)}
    }

    def add(recognizer : Recognizer<_>) = Recognizers(items + recognizer)
    def add(recognizers : Recognizers) = Recognizers(items + recognizers.items)
    def types : Set<RecognizerType<_, _>> = items.chain.map(_.tp).toSet
}

class RecognizersState(recognizers : Recognizers) {
    def process<P>(event : Event<P>) : bool =
        if(event.phase == EventPhase.on) on(event)
        else if(event.phase == EventPhase.began) began(event)
        else if(event.phase == EventPhase.ended) ended(event)
        else if(event.phase == EventPhase.changed) changed(event)
        else canceled(event)

    def on<P>(event : Event<P>) : bool = recognizers.on(event).isDefined

    private val longMap = MutableHashMap<RecognizerType<LongRecognizer>, LongRecognizer<_>>()

    def began<P>(event : Event<P>) : bool = {
        val tp = event.recognizerType
        longMap.modify(recognizers.began(event), forKey = tp).isDefined
    }

    def changed<P>(event : Event<P>) : bool = longMap.opt(event.recognizerType).try(_.changed(event))


    def ended<P>(event : Event<P>) : bool = {
        val tp = event.recognizerType
        longMap.opt(tp).for(_.ended(event))
        longMap.removeFor(tp).isDefined
    }

    def canceled<P>(event : Event<P>) : bool = {
        val tp = event.recognizerType
        longMap.opt(tp).for(_.canceled(event))
        longMap.removeFor(tp).isDefined
    }
}


class RecognizerType<T extends Recognizer, P>

// For a computer it's mouse events. fingers 1 - left button, 2 - right
// For a touchpad "fingers + 1" is count of fingers
class Pan(fingers : uint) extends RecognizerType<LongRecognizer, Void> {
    static def apply : Pan = leftMouse
    static val leftMouse = Pan(1)
    static val rightMouse = Pan(2)
}

// For a computer it's click event. fingers 1 - left button, 2 - right
class Tap(fingers : uint, taps : uint)  extends RecognizerType<ShortRecognizer, Void> {
    static def apply() = Tap(1, 1)
}

class Pinch extends RecognizerType<LongRecognizer, PinchParameter>
class PinchParameter(scale : float, velocity : float)

enum EventPhase {
    began()
    changed()
    ended()
    canceled()
    on()
}

trait Event<P> {
    def recognizerType : RecognizerType<_, P>
    def phase : EventPhase
    def locationInView : vec2
    def viewSize : vec2
    def param : P
    def matrixModel : MatrixModel = MatrixModel.identity
    def viewport : Rect = Rect(0, 0, 1, 1)

    def locationInViewport : vec2 = locationInView
    def location : vec2 = locationInView
    def locationFor(depth : float) : vec2 = locationInView
    def segment : Line3 = Line3(vec3(locationInView, 0), vec3(0, 0, 1000))
    def checkViewport : bool = true
}

class ViewEvent<P>(recognizerType : RecognizerType<_, P>, phase : EventPhase, locationInView : vec2, viewSize : vec2, param : P) extends Event<P>

class CameraEvent<P>(event : Event<P>, matrixModel : MatrixModel, viewport : Rect) extends Event<P> {
    val recognizerType : RecognizerType<_, P> = event.recognizerType
    def phase : EventPhase = event.phase
    val locationInView = event.locationInView
    def viewSize : vec2 = event.viewSize
    def param : P = event.param

    def location : vec2 = locationFor(0)
    def locationInViewport : vec2 = {
        (locationInView - viewport.p)/viewport.size*2 - vec2(1, 1)
    }
    def locationFor(depth : float) : vec2 = segment.r(plane = Plane(vec3(0, 0, depth), vec3(0, 0, 1))).xy

    lazy val segment : Line3 = {
        val loc = locationInViewport
        val mat4 = matrixModel.wcp.inverse
        val p0 = mat4.mul(vec4 = vec4(loc.x, loc.y, -1, 1))
        val p1 = mat4.mul(vec4 = vec4(loc.x, loc.y, 1, 1))
        Line3(p0.xyz, p1.xyz - p0.xyz)
    }
    def checkViewport : bool = viewport.contains(locationInView)
}


