package com.antonzherdev.eg

trait InputProcessor {
    def process(event : Event) : bool
}

trait MouseProcessor {
    def mouseDown(event : Event) : bool = false
    def mouseDrag(event : Event)  : bool = false
    def mouseUp(event : Event) : bool = false
}

trait TouchProcessor {
    def touchBegan(event : Event) : bool = false
    def touchMoved(event : Event) : bool = false
    def touchEnded(event : Event) : bool = false
    def touchCanceled(event : Event) : bool = false
}

class Event(viewSize : vec2, camera : Camera?) {
    def set(camera : Camera?) : Event

    def locationInView : vec2
    def location = locationFor(0)
    def locationFor(depth : float) : vec2 =
        if(camera.isEmpty) locationInView
        else camera.get.translateWith(viewSize, locationInView)

    def segment : line3 =
        if(camera.isEmpty) line3(vec3(locationInView, 0), vec3(0, 0, 1000))
        else {
            val loc = (locationInView - context.viewport.origin)/context.viewport.size*2 - vec2(1, 1)
            val mat4 = camera.get.matrixModel.mwcp.inverse

            val m = camera.get.matrixModel.mwcp
            val d1 = m.mul(vec4 = vec4(0, 0, 0, 1))
            val d2 = mat4.mul(vec4 = d1)


            val p0 = mat4.mul(vec4 = vec4(loc.x, loc.y, -1, 1))
            val p1 = mat4.mul(vec4 = vec4(loc.x, loc.y, 1, 1))

            val l = line3(p0.xyz, p1.xyz - p0.xyz)

            val d3 = l.r(plane = plane(vec3(0,0,0), vec3(0, 0, 1)))
            val d4 = m.mul(vec4 = vec4(d3, 1))

            l
        }

    def isLeftMouseDown : bool
    def isLeftMouseDrag : bool
    def isLeftMouseUp : bool
    def leftMouse(processor : MouseProcessor) : bool =
        if(isLeftMouseDown) processor.mouseDown(self)
        else if(isLeftMouseDrag) processor.mouseDrag(self)
        else if(isLeftMouseUp) processor.mouseUp(self)
        else false


    def isTouchBegan : bool
    def isTouchMoved : bool
    def isTouchEnded : bool
    def isTouchCanceled : bool
    def touch(processor : TouchProcessor) : bool =
        if(isTouchBegan) processor.touchBegan(self)
        else if(isTouchMoved) processor.touchMoved(self)
        else if(isTouchEnded) processor.touchEnded(self)
        else if(isTouchCanceled) processor.touchCanceled(self)
        else false
}

class RectIndex<T>(rects : [(rect, T)]) {
    def apply(point : vec2) : T? = rects.find(_.a.contains(point)).map(_.b)
}