package com.antonzherdev.eg

class Recognizer(tp : RecognizerType) {
    static def apply(tp : RecognizerType<LongRecognizer>,
        began : Event -> bool, changed : Event -> void, ended : Event -> void)
        = LongRecognizer(tp, began, changed, ended, {})
    static def apply(tp : RecognizerType<LongRecognizer>,
        began : Event -> bool, changed : Event -> void, ended : Event -> void, canceled : Event -> void)
        = LongRecognizer(tp, began, changed, ended, canceled)

    static def apply(tp : RecognizerType<ShortRecognizer>, on : Event -> bool)
        = ShortRecognizer(tp, on)

    def is(tp : RecognizerType) : bool = tp == self.tp

    def add(recognizer : Recognizer) = Recognizers([self, recognizer])
}
class LongRecognizer(tp : RecognizerType, began : Event -> bool,
    changed : Event -> void, ended : Event -> void, canceled : Event -> void) extends Recognizer(tp)
class ShortRecognizer(tp : RecognizerType, on : Event -> bool) extends Recognizer(tp)


trait InputProcessor {
    def isProcessorActive : bool = !Director.current.isPaused
    def recognizers : Recognizers
}


class Recognizers(items : [Recognizer]) {
    static def apply(recognizer : Recognizer) = Recognizers([recognizer])

    def on(event : Event) : ShortRecognizer? = {
        items.find{item -> item.is(event.recognizerType) && item.cast<ShortRecognizer>.on(event)}
    }

    def began(event : Event) : LongRecognizer? = {
        items.find{item -> item.is(event.recognizerType) && item.cast<LongRecognizer>.began(event)}
    }

    def add(recognizer : Recognizer) = Recognizers(items + recognizer)
    def add(recognizers : Recognizers) = Recognizers(items + recognizers.items)
    def types : Set<RecognizerType<_>> = items.chain.map(_.tp).toSet
}

class RecognizersState(recognizers : Recognizers) {
    def process(event : Event) : bool =
        if(event.phase == EventPhase.on) on(event)
        else if(event.phase == EventPhase.began) began(event)
        else if(event.phase == EventPhase.ended) ended(event)
        else if(event.phase == EventPhase.changed) changed(event)
        else canceled(event)

    def on(event : Event) : bool = recognizers.on(event).isDefined

    private val longMap = MutableHashMap<RecognizerType<LongRecognizer>, LongRecognizer>()

    def began(event : Event) : bool = {
        val tp = event.recognizerType
        longMap.modify(recognizers.began(event), forKey = tp).isDefined
    }

    def changed(event : Event) : bool = longMap.opt(event.recognizerType).try(_.changed(event))


    def ended(event : Event) : bool = {
        val tp = event.recognizerType
        longMap.opt(tp).for(_.ended(event))
        longMap.removeFor(tp).isDefined
    }

    def canceled(event : Event) : bool = {
        val tp = event.recognizerType
        longMap.opt(tp).for(_.canceled(event))
        longMap.removeFor(tp).isDefined
    }
}


class RecognizerType<T extends Recognizer>

// For a computer it's mouse events. fingers 1 - left button, 2 - right
// For a touchpad "fingers + 1" is count of fingers
class Pan(fingers : uint) extends RecognizerType<ShortRecognizer> {
    static def apply : Pan = leftMouse
    static val leftMouse = Pan(1)
    static val rightMouse = Pan(2)
}

// For a computer it's click event. fingers 1 - left button, 2 - right
class Tap(fingers : uint, taps : uint)  extends RecognizerType<LongRecognizer> {
    static def apply() = Tap(1, 1)
}


enum EventPhase {
    began()
    changed()
    ended()
    canceled()
    on()
}

class EventCamera(matrixModel : MatrixModel, viewport : Rect)

class Event(viewSize : vec2, camera : EventCamera?) {
    def recognizerType : RecognizerType<_>
    def phase : EventPhase
    def set(camera : EventCamera?) : Event

    def locationInView : vec2
    def location = locationFor(0)
    def locationInViewport : vec2 = {
        val viewport = camera.get.viewport
        (locationInView - viewport.p0)/viewport.size*2 - vec2(1, 1)
    }
    def locationFor(depth : float) : vec2 =
        if(camera.isEmpty) locationInView
        else segment.r(plane = Plane(vec3(0, 0, depth), vec3(0, 0, 1))).xy

    lazy val segment : Line3 =
        if(camera.isEmpty) Line3(vec3(locationInView, 0), vec3(0, 0, 1000))
        else {
            val loc = locationInViewport
            val mat4 = camera.get.matrixModel.wcp.inverse
            val p0 = mat4.mul(vec4 = vec4(loc.x, loc.y, -1, 1))
            val p1 = mat4.mul(vec4 = vec4(loc.x, loc.y, 1, 1))
            Line3(p0.xyz, p1.xyz - p0.xyz)
        }
    def checkViewport : bool = camera.isEmpty || camera.get.viewport.contains(locationInView)
}
