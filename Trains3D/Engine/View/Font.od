package com.antonzherdev.eg

struct TextAlignment(x : float4, y : float4, baseline : bool) {
    static def apply(x : float4, y : float4) = TextAlignment(x, y, false)
    static def baseline(x : float4) = TextAlignment(x, 0, true)
    static val left = TextAlignment(-1, 0, true)
    static val right = TextAlignment(1, 0, true)
    static val center = TextAlignment(0, 0, true)
}

class Font(name : string) {
    private val texture = FileTexture("$(name).png", GL_NEAREST, GL_NEAREST)
    private val symbols : [char : FontSymbolDesc]
    val height : uint
    val size : uint
    def init {
        val charMap = MutableHashMap<char, FontSymbolDesc>()
        val ts = texture.size
        Bundle.readToString("$(name).fnt").split("\n").for{line : string ->
            val t = line.tuple(" ").get
            val name = t.a
            val map : [string : string] = t.b.split(" ").chain.flatMap<(string, string)>(_.tuple("=")).toMap
            if(name == "info") {
                size = map("size").toUInt
            } else if(name == "common") {
                height = map("lineHeight").toUInt
            } else if(name == "char") {
                val code : char = map("id").toInt
                val width : float4 = map("xadvance").toFloat
                val offset =  vec2i(map("xoffset").toInt, map("yoffset").toInt)
                val r = rect(map("x").toFloat, map("y").toFloat, map("width").toFloat, map("height").toFloat)
                charMap.set(value = FontSymbolDesc(width, offset, r.size, r/ts), forKey = code)
            }
        }
        symbols = charMap
    }

    private def parse(_rect : string) : rect = {
        val parts = _rect.split(" ").chain.toArray
        val y = parts[1].toFloat
        val h = parts[3].toFloat
        rect(parts[0].toFloat, y, parts[2].toFloat, h)
    }

    private static val vbDesc = VertexBufferDesc(FontPrintData.type, position = 0, uv = 2*4, normal = -1, color = -1, model = -1)
    private val vb = VertexBuffer(vbDesc)
    private val ib = IndexBuffer()
    private val mesh = Mesh(vb, ib)
    def draw(text : string, color : vec4, at : vec2, alignment : TextAlignment) {
        val pos = (context.matrixStack.value.wcp * vec4(at.x, at.y, 0, 1)).xy
        val symbolsArr = text.chain.flatMap<FontSymbolDesc>(symbols.opt(_)).toArray
        val vertexes = VoidRefArray(FontPrintData.type, symbolsArr.count * 4)
        val indexes = VoidRefArray(UInt4.type, symbolsArr.count * 6)
        val vpSize = context.viewport.size/2.0

        var vp = vertexes
        var ip = indexes
        var n = 0

        var x =
            if(alignment.x == -1) pos.x
            else {
                var fullWidth = 0
                symbolsArr.for{s -> fullWidth += s.width}
                pos.x - fullWidth/vpSize.x*(alignment.x/2 + 0.5)
            }
        val y =
            if(alignment.baseline) pos.y + height.cast<float4>/vpSize.y
            else pos.y - height.cast<float4>/vpSize.y*(alignment.y/2 - 0.5)
        symbolsArr.for {s ->
            val size = s.size/vpSize
            val tr = s.textureRect
            val v0 = vec2(x + s.offset.x/vpSize.x, y - s.offset.y/vpSize.y)

            vp = vp.write(vec2, v0)
            vp = vp.write(vec2, tr.leftBottom)

            vp = vp.write(vec2, vec2(v0.x, v0.y - size.y))
            vp = vp.write(vec2, tr.leftTop)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y - size.y))
            vp = vp.write(vec2, tr.rightTop)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y))
            vp = vp.write(vec2, tr.rightBottom)

            ip = ip.write(uInt4 = n)
            ip = ip.write(uInt4 = n + 1)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 3)
            ip = ip.write(uInt4 = n)

            x += s.width/vpSize.x
            n += 4
        }
        vb.set(vertexes, GL_DYNAMIC_DRAW)
        ib.set(indexes, GL_DYNAMIC_DRAW)

        BlendFunction.standard {
            glDisable(GL_CULL_FACE)
            FontShader.instance.draw(FontShaderParam(texture, color), mesh)
            glEnable(GL_CULL_FACE)
        }

    }
}

class FontShaderParam(texture : Texture, color : vec4)

class FontShader extends Shader<FontShaderParam>(ShaderProgram(FontShader.vertex, FontShader.fragment)) {
    static val instance = FontShader()
    static val vertex =
        "attribute vec2 position;
         attribute vec2 vertexUV;

         varying vec2 UV;

         void main(void) {
            gl_Position = vec4(position.x, position.y, 0, 1);
            UV = vertexUV;
         }"
    static val fragment =
        "varying vec2 UV;
         uniform sampler2D texture;
         uniform vec4 color;

         void main(void) {
            gl_FragColor = color * texture2D(texture, UV);
         }"

    val uvSlot : ShaderAttribute = attributeFor("vertexUV")
    val positionSlot : ShaderAttribute = attributeFor("position")
    val colorUniform = uniformFor("color")
    def load(vbDesc : VertexBufferDesc<_>, param : FontShaderParam) {
        param.texture.bind
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.position)
        uvSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.uv)
        colorUniform.set(vec4 = param.color)
    }
    def unload(param : FontShaderParam) {
        Texture.unbind
    }
}

class FontSymbolDesc(width : float4, offset : vec2, size : vec2, textureRect : rect)
struct FontPrintData(position : vec2, uv : vec2)