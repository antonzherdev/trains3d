package com.antonzherdev.eg

struct TextAlignment(x : float4, y : float4, baseline : bool, shift : vec2) {
    static def apply(x : float4, y : float4) = TextAlignment(x, y, false, vec2(0, 0))
    static def apply(x : float4, y : float4, shift : vec2) = TextAlignment(x, y, false, shift)
    static def baseline(x : float4) = TextAlignment(x, 0, true, vec2(0, 0))
    static val left = TextAlignment(-1, 0, true, vec2(0, 0))
    static val right = TextAlignment(1, 0, true, vec2(0, 0))
    static val center = TextAlignment(0, 0, true, vec2(0, 0))
}

abstract class Font {
    static val fontChangeNotification = NotificationHandle<Font, void>("fontChangeNotification")

    def texture : Texture

    static val newLineDesc = FontSymbolDesc(0, vec2(0, 0), vec2(0, 0), Rect(0, 0, 0, 0), true)
    static val zeroDesc = FontSymbolDesc(0, vec2(0, 0), vec2(0, 0), Rect(0, 0, 0, 0), false)

    def height : uint
    def size : uint

    //return size of text in pixels
    def measureInPoints(text : string) : vec2 = {
        val pair = buildSymbolArray(text)
        val symbolsArr = pair.a
        val newLines = pair.b

        var fullWidth = 0
        var lineWidth = 0
        symbolsArr.for{s ->
            if(s.isNewLine) {
                if(lineWidth > fullWidth) fullWidth = lineWidth
                lineWidth = 0
            } else {
                lineWidth += s.width
            }
        }
        if(lineWidth > fullWidth) fullWidth = lineWidth
        vec2(fullWidth, height.cast<float4>*(newLines + 1))/Director.current.scale
    }

    def symbolOpt(smb : char) : FontSymbolDesc?


    //return size of text in projection space
    def measureP(text : string) : vec2 = measureInPoints(text)*2.0/context.scaledViewSize.value
    def measureC(text : string) : vec2 = matrix.p.divBySelf(vec4(measureP(text), 0, 0)).xy

    static val vbDesc = VertexBufferDesc(FontPrintData.type, position = 0, uv = 2*4, normal = -1, color = -1, model = -1)

    def resymbol : bool = false

    private def buildSymbolArray(text : string) : ([FontSymbolDesc], int) = {
        var newLines = 0
        var symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
            if(s == 10) {
                newLines++
                Option.some(newLineDesc)
            } else symbolOpt(s)
        }.toArray
        if(resymbol) {
            symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
                if(s == 10) Option.some(newLineDesc) else symbolOpt(s)
            }.toArray
        }
        (symbolsArr, newLines)
    }

    def vao(text : string, at : vec3, alignment : TextAlignment) : SimpleVertexArray<FontShaderParam> = {
        val pos = matrix.wcp.mul(vec4(at, 1)).xy + (alignment.shift/context.scaledViewSize.value*2)
        val pair = buildSymbolArray(text)
        val symbolsArr = pair.a
        val newLines = pair.b
        val symbolsCount = symbolsArr.count - newLines
        val vertexes = VoidRefArray(FontPrintData.type, symbolsCount * 4)
        val indexes = VoidRefArray(UInt4.type, symbolsCount * 6)
        val vpSize = context.viewport.size/2.0

        var vp = vertexes
        var ip = indexes
        var n = 0

        var linesWidth = MArray<int>()
        var linesWidthIterator : Iterator<int>
        var x =  pos.x
        if(alignment.x != -1) {
            var lineWidth = 0
            symbolsArr.for{s ->
            if(s.isNewLine) {
                linesWidth.append(lineWidth)
                lineWidth = 0
            } else {
                lineWidth += s.width
            }
            }
            linesWidth.append(lineWidth)
            linesWidthIterator = linesWidth.iterator
            x = pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
        }
        val hh = height.cast<float4>/vpSize.y
        var y =
            if(alignment.baseline) pos.y + size.cast<float4>/vpSize.y
            else pos.y - hh*(newLines + 1)*(alignment.y/2 - 0.5)

        symbolsArr.for {s ->
        if(s.isNewLine) {
            x = if(alignment.x == -1) pos.x
            else pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
            y -= hh
        } else {
            val size = s.size/vpSize
            val tr = s.textureRect
            val v0 = vec2(x + s.offset.x/vpSize.x, y - s.offset.y/vpSize.y)

            vp = vp.write(vec2, v0)
            vp = vp.write(vec2, tr.p)

            vp = vp.write(vec2, vec2(v0.x, v0.y - size.y))
            vp = vp.write(vec2, tr.ph)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y - size.y))
            vp = vp.write(vec2, tr.phw)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y))
            vp = vp.write(vec2, tr.pw)

            ip = ip.write(uInt4 = n)
            ip = ip.write(uInt4 = n + 1)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 3)
            ip = ip.write(uInt4 = n)

            x += s.width/vpSize.x
            n += 4
        }
        }
        val vb = VBO(vbDesc, vertexes)
        val ib = IBO(indexes)
        vertexes.free
        indexes.free
        FontShader.instance.vao(vb, ib)
    }

    def draw(text : string, at : vec3, alignment : TextAlignment, color : vec4) {
        val vao = vao(text, at, alignment)
        context.cullFace.disabled {
            vao.draw(FontShaderParam(texture, color, shift = vec2(0, 0)))
        }
    }

    def beReadyFor(text : string) : Font = {
        text.chain.for{s ->
            symbolOpt(s)
        }
        self
    }
}

class BMFont(name : string) extends Font {
    val texture = FileTexture(name, TextureFileFormat.PNG, TextureFormat.RGBA8, 1.0, TextureFilter.nearest)
    private val symbols : Map<char, FontSymbolDesc>
    val height : uint
    val size : uint
    def init {
        val charMap = MHashMap<char, FontSymbolDesc>()
        val ts = texture.size
        Bundle.readToString("$(name).fnt").split("\n").for{line : string ->
            val t = line.tuple(" ").get
            val name = t.a
            val map : [string : string] = t.b.split(" ").chain.flatMap<(string, string)>(_.tuple("=")).toMap
            if(name == "info") {
                size = map("size").toUInt
            } else if(name == "common") {
                height = map("lineHeight").toUInt
            } else if(name == "char") {
                val code : char = map("id").toInt.cast<char>
                val width : float4 = map("xadvance").toFloat
                val offset =  vec2i(map("xoffset").toInt, map("yoffset").toInt)
                val r = Rect(map("x").toFloat, map("y").toFloat, map("width").toFloat, map("height").toFloat)
                charMap.set(code, value = FontSymbolDesc(width, offset, r.size, r/ts, isNewLine = false))
            }
        }
        symbols = charMap
    }

    private def parse(_rect : string) : Rect = {
        val parts = _rect.split(" ").chain.toArray
        val y = parts[1].toFloat
        val h = parts[3].toFloat
        Rect(parts[0].toFloat, y, parts[2].toFloat, h)
    }

    def symbolOpt(smb : char) : FontSymbolDesc? = symbols.opt(smb)
}

class Text(visible : React<bool> = true, font : React<Font>, text : React<string>, position : React<vec3>, alignment : React<TextAlignment>,
    color : React<vec4>, shadow : React<TextShadow?> = Option.none<TextShadow>)
{
    private var _changed = ReactFlag(initial = true, [font, text, position, alignment, shadow, context.viewSize])
    private val fontObserver = font.map{newFont ->
        Font.fontChangeNotification.observe(newFont){_, __ -> _changed.set}
    }


    private var _vao : SimpleVertexArray<FontShaderParam>
    private var _param : FontShaderParam
    private var _shadowParam : FontShaderParam

    def draw {
        if(!visible.value) return nil
        if(_changed.value) {
            _vao = font.value.vao(text.value, position.value, alignment.value)
            _changed.clear
            _param = FontShaderParam(font.value.texture, color.value, shift = vec2(0, 0))
            if(shadow.value.isDefined) {
                val sh = shadow.value.get
                _shadowParam = FontShaderParam(font.value.texture, sh.color * color.value.w, sh.shift)
            } else {
                _shadowParam = nil
            }
        }
        if(_shadowParam != nil) _vao.draw(_shadowParam)
        _vao.draw(_param)
    }

    lazy val sizeInPoints : React<vec2> = React.async(DispatchQueue.mainThread, font, text) {f, t -> f.measureInPoints(t)}
    lazy val sizeInP : React<vec2> = React.async(DispatchQueue.mainThread, sizeInPoints, context.scaledViewSize) {s, vs -> s*2/vs}

    def measureInPoints = font.value.measureInPoints(text.value)
    def measureP = font.value.measureP(text.value)
    def measureC = font.value.measureC(text.value)
}

class TextShadow(color : vec4, shift : vec2)

class FontShaderParam(texture : Texture, color : vec4, shift : vec2)

class FontShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        uniform highp vec2 shift;
        $ain highp vec2 position;
        $ain mediump vec2 vertexUV;

        $out mediump vec2 UV;

        void main(void) {
            gl_Position = vec4(position.x + shift.x, position.y + shift.y, 0, 1);
            UV = vertexUV;
        }"
    def fragment =
       "$fragmentHeader
        $in mediump vec2 UV;
        uniform lowp sampler2D txt;
        uniform lowp vec4 color;

        void main(void) {
            $fragColor = color * $texture2D\(txt, UV);
        }"

    def program = ShaderProgram("Font", vertex, fragment)
}

class FontShader extends Shader<FontShaderParam>(FontShaderBuilder().program) {
    static val instance = FontShader()

    val uvSlot : ShaderAttribute = attributeFor("vertexUV")
    val positionSlot : ShaderAttribute = attributeFor("position")
    val colorUniform = uniformVec4("color")
    val shiftSlot = uniformVec2("shift")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.position)
        uvSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.uv)
    }
    def loadUniforms(param : FontShaderParam) {
        context.bindTexture(param.texture)
        colorUniform(vec4 = param.color)
        shiftSlot(vec2 = matrix.p.mul(vec4(param.shift, 0, 0)).xy)
    }
}

class FontSymbolDesc(width : float4, offset : vec2, size : vec2, textureRect : Rect, isNewLine : bool)
struct FontPrintData(position : vec2, uv : vec2)