package com.antonzherdev.eg

struct TextAlignment(x : float4, y : float4, baseline : bool, shift : vec3) {
    static def apply(x : float4, y : float4) = TextAlignment(x, y, false, vec3(0, 0, 0))
    static def baseline(x : float4) = TextAlignment(x, 0, true, vec3(0, 0, 0))
    static val left = TextAlignment(-1, 0, true, vec3(0, 0, 0))
    static val right = TextAlignment(1, 0, true, vec3(0, 0, 0))
    static val center = TextAlignment(0, 0, true, vec3(0, 0, 0))
}

class Font(name : string) {
    private val texture = FileTexture("$(name).png", GL_NEAREST, GL_NEAREST)
    private val symbols : [char : FontSymbolDesc]
    val height : uint
    val size : uint
    def init {
        val charMap = MutableHashMap<char, FontSymbolDesc>()
        val ts = texture.size
        Bundle.readToString("$(name).fnt").split("\n").for{line : string ->
            val t = line.tuple(" ").get
            val name = t.a
            val map : [string : string] = t.b.split(" ").chain.flatMap<(string, string)>(_.tuple("=")).toMap
            if(name == "info") {
                size = map("size").toUInt
            } else if(name == "common") {
                height = map("lineHeight").toUInt
            } else if(name == "char") {
                val code : char = map("id").toInt
                val width : float4 = map("xadvance").toFloat
                val offset =  vec2i(map("xoffset").toInt, map("yoffset").toInt)
                val r = Rect(map("x").toFloat, map("y").toFloat, map("width").toFloat, map("height").toFloat)
                charMap.set(code, value = FontSymbolDesc(width, offset, r.size, r/ts, isNewLine = false))
            }
        }
        symbols = charMap
    }

    private static val newLineDesc = FontSymbolDesc(0, vec2(0, 0), vec2(0, 0), Rect(0, 0, 0, 0), true)

    private def parse(_rect : string) : Rect = {
        val parts = _rect.split(" ").chain.toArray
        val y = parts[1].toFloat
        val h = parts[3].toFloat
        Rect(parts[0].toFloat, y, parts[2].toFloat, h)
    }

    //return size of text in projection space
    def measure(text : string) : vec2 = {
        var newLines = 0
        val symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
            if(s == 10) {
                newLines++
                Option.some(newLineDesc)
            } else symbols.opt(s)
        }.toArray
        var fullWidth = 0
        var lineWidth = 0
        symbolsArr.for{s ->
            if(s.isNewLine) {
                if(lineWidth > fullWidth) fullWidth = lineWidth
                lineWidth = 0
            } else {
                lineWidth += s.width
            }
        }
        if(lineWidth > fullWidth) fullWidth = lineWidth
        val vpSize = context.viewport.size/2.0
        vec2(fullWidth.cast<float4>/vpSize.x, height.cast<float4>/vpSize.y*(newLines + 1))
    }

    private static val vbDesc = VertexBufferDesc(FontPrintData.type, position = 0, uv = 2*4, normal = -1, color = -1, model = -1)
    private val vb = VBO.mut(vbDesc)
    private val ib = IBO.mut
    private val mesh = FontShader.instance.vao(vb, ib)
    def draw(text : string, color : vec4, at : vec3, alignment : TextAlignment) {
        val pos =
            if(alignment.shift.isEmpty) matrix.wcp.mul(vec4(at, 1)).xy
            else matrix.p.mul(matrix.wc.mul(vec4(at, 1)) + alignment.shift).xy
        var newLines = 0
        val symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
            if(s == 10) {
                newLines++
                Option.some(newLineDesc)
            } else symbols.opt(s)
        }.toArray
        val symbolsCount = symbolsArr.count - newLines
        val vertexes = VoidRefArray(FontPrintData.type, symbolsCount * 4)
        val indexes = VoidRefArray(UInt4.type, symbolsCount * 6)
        val vpSize = context.viewport.size/2.0

        var vp = vertexes
        var ip = indexes
        var n = 0

        var linesWidth = MutableArray<int>()
        val linesWidthIterator : Iterator<int>
        var x =  pos.x
        if(alignment.x != -1) {
            var lineWidth = 0
            symbolsArr.for{s ->
                if(s.isNewLine) {
                    linesWidth.append(lineWidth)
                    lineWidth = 0
                } else {
                    lineWidth += s.width
                }
            }
            linesWidth.append(lineWidth)
            linesWidthIterator = linesWidth.iterator
            x = pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
        }
        val hh = height.cast<float4>/vpSize.y
        var y =
            if(alignment.baseline) pos.y + size.cast<float4>/vpSize.y
            else pos.y - hh*(newLines + 1)*(alignment.y/2 - 0.5)

        symbolsArr.for {s ->
            if(s.isNewLine) {
                x = if(alignment.x == -1) pos.x
                    else pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
                y -= hh
            } else {
                val size = s.size/vpSize
                val tr = s.textureRect
                val v0 = vec2(x + s.offset.x/vpSize.x, y - s.offset.y/vpSize.y)

                vp = vp.write(vec2, v0)
                vp = vp.write(vec2, tr.p0)

                vp = vp.write(vec2, vec2(v0.x, v0.y - size.y))
                vp = vp.write(vec2, tr.p1)

                vp = vp.write(vec2, vec2(v0.x + size.x, v0.y - size.y))
                vp = vp.write(vec2, tr.p3)

                vp = vp.write(vec2, vec2(v0.x + size.x, v0.y))
                vp = vp.write(vec2, tr.p2)

                ip = ip.write(uInt4 = n)
                ip = ip.write(uInt4 = n + 1)
                ip = ip.write(uInt4 = n + 2)
                ip = ip.write(uInt4 = n + 2)
                ip = ip.write(uInt4 = n + 3)
                ip = ip.write(uInt4 = n)

                x += s.width/vpSize.x
                n += 4
            }
        }
        vb.set(vertexes)
        ib.set(indexes)
//        val mesh = Mesh(vertex = vb, ib)
        context.cullFace.disabled {
            mesh.draw(FontShaderParam(texture, color))
        }
    }
}

class FontShaderParam(texture : Texture, color : vec4)

class FontShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        $ain highp vec2 position;
        $ain mediump vec2 vertexUV;

        $out mediump vec2 UV;

        void main(void) {
            gl_Position = vec4(position.x, position.y, 0, 1);
            UV = vertexUV;
        }"
    def fragment =
       "$fragmentHeader
        $in mediump vec2 UV;
        uniform lowp sampler2D texture;
        uniform lowp vec4 color;

        void main(void) {
            $fragColor = color * $texture2D\(texture, UV);
        }"

    def program = ShaderProgram(vertex, fragment)
}

class FontShader extends Shader<FontShaderParam>(FontShaderBuilder().program) {
    static val instance = FontShader()

    val uvSlot : ShaderAttribute = attributeFor("vertexUV")
    val positionSlot : ShaderAttribute = attributeFor("position")
    val colorUniform = uniformVec4("color")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.position)
        uvSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.uv)
    }
    def loadUniforms(param : FontShaderParam) {
        context.bindTexture(param.texture)
        colorUniform(vec4 = param.color)
    }
}

class FontSymbolDesc(width : float4, offset : vec2, size : vec2, textureRect : Rect, isNewLine : bool)
struct FontPrintData(position : vec2, uv : vec2)