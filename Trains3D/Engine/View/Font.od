package com.antonzherdev.eg

struct TextAlignment(x : float4, y : float4, baseline : bool, shift : vec3) {
    static def apply(x : float4, y : float4) = TextAlignment(x, y, false, vec3(0, 0, 0))
    static def baseline(x : float4) = TextAlignment(x, 0, true, vec3(0, 0, 0))
    static val left = TextAlignment(-1, 0, true, vec3(0, 0, 0))
    static val right = TextAlignment(1, 0, true, vec3(0, 0, 0))
    static val center = TextAlignment(0, 0, true, vec3(0, 0, 0))
}

class Font {
    static val fontChangeNotification = NotificationHandle<Font, void>("fontChangeNotification")

    def texture : Texture

    static val newLineDesc = FontSymbolDesc(0, vec2(0, 0), vec2(0, 0), Rect(0, 0, 0, 0), true)
    static val zeroDesc = FontSymbolDesc(0, vec2(0, 0), vec2(0, 0), Rect(0, 0, 0, 0), false)

    def height : uint
    def size : uint

    //return size of text in pixels
    def measureInPixels(text : string) : vec2 = {
        val pair = buildSymbolArray(text)
        val symbolsArr = pair.a
        val newLines = pair.b

        var fullWidth = 0
        var lineWidth = 0
        symbolsArr.for{s ->
            if(s.isNewLine) {
                if(lineWidth > fullWidth) fullWidth = lineWidth
                lineWidth = 0
            } else {
                lineWidth += s.width
            }
        }
        if(lineWidth > fullWidth) fullWidth = lineWidth
        vec2(fullWidth, height.cast<float4>*(newLines + 1))
    }

    def symbolOpt(smb : char) : FontSymbolDesc?


    //return size of text in projection space
    def measureP(text : string) : vec2 = measureInPixels(text)*2.0/context.viewport.size
    def measureC(text : string) : vec2 = matrix.p.divBySelf(vec4(measureP(text), 0, 0)).xy

    static val vbDesc = VertexBufferDesc(FontPrintData.type, position = 0, uv = 2*4, normal = -1, color = -1, model = -1)

    def resymbol : bool = false

    private def buildSymbolArray(text : string) : ([FontSymbolDesc], int) = {
        var newLines = 0
        var symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
        if(s == 10) {
            newLines++
            Option.some(newLineDesc)
        } else symbolOpt(s)
        }.toArray
        if(resymbol) {
            symbolsArr = text.chain.flatMap<FontSymbolDesc>{s ->
                if(s == 10) Option.some(newLineDesc) else symbolOpt(s)
            }.toArray
        }
        (symbolsArr, newLines)
    }

    def vao(text : string, at : vec3, alignment : TextAlignment) : SimpleVertexArray<FontShaderParam> = {
        val pos =
            if(alignment.shift.isEmpty) matrix.wcp.mul(vec4(at, 1)).xy
            else matrix.p.mul(matrix.wc.mul(vec4(at, 1)) + alignment.shift).xy
        val pair = buildSymbolArray(text)
        val symbolsArr = pair.a
        val newLines = pair.b
        val symbolsCount = symbolsArr.count - newLines
        val vertexes = VoidRefArray(FontPrintData.type, symbolsCount * 4)
        val indexes = VoidRefArray(UInt4.type, symbolsCount * 6)
        val vpSize = context.viewport.size/2.0

        var vp = vertexes
        var ip = indexes
        var n = 0

        var linesWidth = MutableArray<int>()
        var linesWidthIterator : Iterator<int>
        var x =  pos.x
        if(alignment.x != -1) {
            var lineWidth = 0
            symbolsArr.for{s ->
            if(s.isNewLine) {
                linesWidth.append(lineWidth)
                lineWidth = 0
            } else {
                lineWidth += s.width
            }
            }
            linesWidth.append(lineWidth)
            linesWidthIterator = linesWidth.iterator
            x = pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
        }
        val hh = height.cast<float4>/vpSize.y
        var y =
            if(alignment.baseline) pos.y + size.cast<float4>/vpSize.y
            else pos.y - hh*(newLines + 1)*(alignment.y/2 - 0.5)

        symbolsArr.for {s ->
        if(s.isNewLine) {
            x = if(alignment.x == -1) pos.x
            else pos.x - linesWidthIterator.next/vpSize.x*(alignment.x/2 + 0.5)
            y -= hh
        } else {
            val size = s.size/vpSize
            val tr = s.textureRect
            val v0 = vec2(x + s.offset.x/vpSize.x, y - s.offset.y/vpSize.y)

            vp = vp.write(vec2, v0)
            vp = vp.write(vec2, tr.p)

            vp = vp.write(vec2, vec2(v0.x, v0.y - size.y))
            vp = vp.write(vec2, tr.ph)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y - size.y))
            vp = vp.write(vec2, tr.phw)

            vp = vp.write(vec2, vec2(v0.x + size.x, v0.y))
            vp = vp.write(vec2, tr.pw)

            ip = ip.write(uInt4 = n)
            ip = ip.write(uInt4 = n + 1)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 2)
            ip = ip.write(uInt4 = n + 3)
            ip = ip.write(uInt4 = n)

            x += s.width/vpSize.x
            n += 4
        }
        }
        val vb = VBO(vbDesc, vertexes)
        val ib = IBO(indexes)
        vertexes.free
        indexes.free
        FontShader.instance.vao(vb, ib)
    }

    def draw(text : string, at : vec3, alignment : TextAlignment, color : vec4) {
        val vao = vao(text, at, alignment)
        context.cullFace.disabled {
            vao.draw(FontShaderParam(texture, color, shift = vec2(0, 0)))
        }
    }

    def beReadyFor(text : string) {
        text.chain.for{s ->
            symbolOpt(s)
        }
    }
}

class BMFont(name : string) extends Font {
    val texture = FileTexture("$(name).png", 1.0, GL_NEAREST, GL_NEAREST)
    private val symbols : [char : FontSymbolDesc]
    val height : uint
    val size : uint
    def init {
        val charMap = MutableHashMap<char, FontSymbolDesc>()
        val ts = texture.size
        Bundle.readToString("$(name).fnt").split("\n").for{line : string ->
            val t = line.tuple(" ").get
            val name = t.a
            val map : [string : string] = t.b.split(" ").chain.flatMap<(string, string)>(_.tuple("=")).toMap
            if(name == "info") {
                size = map("size").toUInt
            } else if(name == "common") {
                height = map("lineHeight").toUInt
            } else if(name == "char") {
                val code : char = map("id").toInt.cast<char>
                val width : float4 = map("xadvance").toFloat
                val offset =  vec2i(map("xoffset").toInt, map("yoffset").toInt)
                val r = Rect(map("x").toFloat, map("y").toFloat, map("width").toFloat, map("height").toFloat)
                charMap.set(code, value = FontSymbolDesc(width, offset, r.size, r/ts, isNewLine = false))
            }
        }
        symbols = charMap
    }

    private def parse(_rect : string) : Rect = {
        val parts = _rect.split(" ").chain.toArray
        val y = parts[1].toFloat
        val h = parts[3].toFloat
        Rect(parts[0].toFloat, y, parts[2].toFloat, h)
    }

    def symbolOpt(smb : char) : FontSymbolDesc? = symbols.opt(smb)
}

class Text {
    static def apply(font : Font, text : string, position : vec3, alignment : TextAlignment, color : vec4) : Text = {
        val t = Text()
        t.font = font
        t.text = text
        t.position = position
        t.alignment = alignment
        t.color = color
        t
    }
    private val obs = Director.reshapeNotification.observe{_, __ -> _changed = true}

    var _changed = true

    private var _font : Font
    private var _obs2 : NotificationObserver
    def font = _font
    def set(font : Font) {
       if(font != _font) {
           _changed = true
           _font = font
           weak val ws = self
           _obs2 = Font.fontChangeNotification.observe(_font){_, __ -> ws._changed = true}
       }
    }

    private var _text : string
    def text = _text
    def set(text : string) {
        if(text != _text) {
            _changed = true
            _text = text
        }
    }

    private var _position : vec3
    def position = _position
    def set(position : vec3) {
        if(position != _position) {
            _changed = true
            _position = position
        }
    }

    private var _alignment : TextAlignment
    def alignment = _alignment
    def set(alignment : TextAlignment) {
        if(alignment != _alignment) {
            _changed = true
            _alignment = alignment
        }
    }

    private var _vao : SimpleVertexArray<FontShaderParam>
    var color : vec4
    var shadow : TextShadow?

    def draw {
        if(_changed) {
            _vao = _font.vao(_text, _position, _alignment)
            _changed = false
        }
        context.cullFace.disabled {
            shadow.for { sh ->
                _vao.draw(FontShaderParam(_font.texture, sh.color * color.w, sh.shift))
            }
            _vao.draw(FontShaderParam(_font.texture, color, shift = vec2(0, 0)))
        }
    }

    def measureInPixels = _font.measureInPixels(_text)
    def measureP = _font.measureP(_text)
    def measureC = _font.measureC(_text)
}

class TextShadow(color : vec4, shift : vec2)

class FontShaderParam(texture : Texture, color : vec4, shift : vec2)

class FontShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        uniform highp vec2 shift;
        $ain highp vec2 position;
        $ain mediump vec2 vertexUV;

        $out mediump vec2 UV;

        void main(void) {
            gl_Position = vec4(position.x + shift.x, position.y + shift.y, 0, 1);
            UV = vertexUV;
        }"
    def fragment =
       "$fragmentHeader
        $in mediump vec2 UV;
        uniform lowp sampler2D txt;
        uniform lowp vec4 color;

        void main(void) {
            $fragColor = color * $texture2D\(txt, UV);
        }"

    def program = ShaderProgram("Font", vertex, fragment)
}

class FontShader extends Shader<FontShaderParam>(FontShaderBuilder().program) {
    static val instance = FontShader()

    val uvSlot : ShaderAttribute = attributeFor("vertexUV")
    val positionSlot : ShaderAttribute = attributeFor("position")
    val colorUniform = uniformVec4("color")
    val shiftSlot = uniformVec2("shift")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.position)
        uvSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.uv)
    }
    def loadUniforms(param : FontShaderParam) {
        context.bindTexture(param.texture)
        colorUniform(vec4 = param.color)
        shiftSlot(vec2 = matrix.p.mul(vec4(param.shift, 0, 0)).xy)
    }
}

class FontSymbolDesc(width : float4, offset : vec2, size : vec2, textureRect : Rect, isNewLine : bool)
struct FontPrintData(position : vec2, uv : vec2)