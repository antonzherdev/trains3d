package com.antonzherdev.eg

class ShadowMapSurface(size : vec2i) extends Surface(size) {
    val frameBuffer = egGenFrameBuffer

    val texture : Texture = {
        val t = Texture()
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glBindTexture(GL_TEXTURE_2D, t.id)

        glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, size.x, size.y, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE)
        glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, t.id, 0)
        glDrawBuffer(GL_NONE)

        val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
        if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in shadow map frame buffer: $status"

        glBindTexture(GL_TEXTURE_2D, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        t
    }

    def dealloc {
        egDeleteFrameBuffer(frameBuffer)
    }

    def bind {
        glPushAttrib(GL_VIEWPORT_BIT )
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glViewport(0, 0, size.x, size.y)
    }

    def unbind {
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        glPopAttrib
    }
}

class ShadowMap extends BaseViewportSurface {
    def createSurface : Surface = ShadowMapSurface(context.viewport.size)

    def texture : Texture = surface.get.cast<ShadowMapSurface>.texture
}