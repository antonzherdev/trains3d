package com.antonzherdev.eg

class Surface(size : vec2i) {
    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def bind

    def unbind

    def frameBuffer : int4

//    def init {
//        if(size.x <= 0 || size.y <= 0) throw "Invalid surface size"
//    }
}


class SurfaceRenderTarget(size : vec2i) {
    def link
}

class SurfaceRenderTargetTexture(texture : Texture, size : vec2i) extends SurfaceRenderTarget(size) {
    static def apply(size : vec2i) : SurfaceRenderTargetTexture = {
        val t = EmptyTexture(size)
        glBindTexture(GL_TEXTURE_2D, t.id)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, size.x, size.y, 0, GL_RGBA, GL_UNSIGNED_BYTE, VoidRef(0))
        SurfaceRenderTargetTexture(t, size)
    }

    def link {
        egFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texture.id, 0)
    }
}

class SurfaceRenderTargetRenderBuffer(renderBuffer : uint4, size : vec2i) extends SurfaceRenderTarget(size) {
    static def apply(size : vec2i) : SurfaceRenderTargetRenderBuffer = {
        val buf = egGenRenderBuffer
        context.bindRenderBuffer(buf)
        glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8_OES, size.x, size.y)
        SurfaceRenderTargetRenderBuffer(buf, size)
    }

    def link {
        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderBuffer)
    }

    def dealloc {
        egDeleteRenderBuffer(renderBuffer)
    }
}


class RenderTargetSurface(renderTarget : SurfaceRenderTarget) extends Surface(renderTarget.size) {
    def texture : Texture = renderTarget.cast<SurfaceRenderTargetTexture>.texture
    def renderBuffer : uint4 = renderTarget.cast<SurfaceRenderTargetRenderBuffer>.renderBuffer
}


class SimpleSurface(renderTarget : SurfaceRenderTarget, depth : bool) extends RenderTargetSurface(renderTarget) {
    static def toTexture(size : vec2i, depth : bool) : SimpleSurface = SimpleSurface(SurfaceRenderTargetTexture(size), depth)
    static def toRenderBuffer(size : vec2i, depth : bool) : SimpleSurface = SimpleSurface(SurfaceRenderTargetRenderBuffer(size), depth)

    val frameBuffer = egGenFrameBuffer
    private val depthRenderBuffer : uint4 = if(depth) egGenRenderBuffer else 0
    def init {
        glGetError
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        renderTarget.link
        if(glGetError != 0) {
            val e = "Error in texture creation for surface with size $(size.x)x$(size.y)"
            throw e
        }

        val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
        if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer color attachment: $status"
        if(depth) {
            context.bindRenderBuffer(depthRenderBuffer)
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, size.x, size.y)
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderBuffer)
            val status2 = glCheckFramebufferStatus(GL_FRAMEBUFFER)
            if(status2 != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer depth attachment: $status"
        }

        glBindTexture(GL_TEXTURE_2D, 0)
    }

    def dealloc {
        egDeleteFrameBuffer(frameBuffer)
        if(depth) egDeleteRenderBuffer(depthRenderBuffer)
    }

    def bind {
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        context.set(viewport = RectI(0, 0, size.x, size.y))
    }

    def unbind {
    }

}

class ViewportSurfaceShaderParam(texture : Texture, z : float4)

class ViewportShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader

        $ain highp vec2 position;
        uniform lowp float z;
        $out mediump vec2 UV;

        void main(void) {
           gl_Position = vec4(2.0*position.x - 1.0, 2.0*position.y - 1.0, z, 1);
           UV = position;
        }"
    def fragment =
       "$fragmentHeader
        $in mediump vec2 UV;

        uniform lowp sampler2D txt;

        void main(void) {
            $fragColor = $texture2D\(txt, UV);
        }"
    def program = ShaderProgram("Viewport", vertex, fragment)
}

class ViewportSurfaceShader extends Shader<ViewportSurfaceShaderParam>(ViewportShaderBuilder().program) {
    static val instance = ViewportSurfaceShader()
    val positionSlot = attributeFor("position")
    val zUniform = uniformF4("z")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, shift = vbDesc.model)
    }

    def loadUniforms(param : ViewportSurfaceShaderParam) {
        context.bindTexture(param.texture)
        zUniform(f4 = param.z)
    }
}

class BaseViewportSurface(createRenderTarget : vec2i -> SurfaceRenderTarget) {
    private var _surface : RenderTargetSurface? = nil
    def surface : RenderTargetSurface? = _surface
    private var _renderTarget : SurfaceRenderTarget? = nil
    def renderTarget : SurfaceRenderTarget = {
        if(_renderTarget.isEmpty || _renderTarget.get.size != context.viewSize) {
            _renderTarget = createRenderTarget(context.viewSize)
            _renderTarget.get
        } else {
            _renderTarget.get
        }
    }

    private def maybeRecreateSurface {
        if(needRedraw) {
            _surface = createSurface
        }
    }

    def createSurface : RenderTargetSurface

    def texture : Texture = renderTarget.cast<SurfaceRenderTargetTexture>.texture
    def renderBuffer : uint4 = renderTarget.cast<SurfaceRenderTargetRenderBuffer>.renderBuffer

    def needRedraw : bool = _surface.isEmpty || _surface.get.size != context.viewSize

    def bind {
        maybeRecreateSurface
        _surface.get.bind
    }

    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def maybe(draw : () -> void) {
        maybe(force = false, draw)
    }

    def maybe(force : bool, draw : () -> void) {
        if(force || needRedraw || _surface.isEmpty) {
            apply(draw)
        }
    }

    def unbind {
        _surface.get.unbind
    }

    static lazy val fullScreenMesh = Mesh(
        VBO.vec2([vec2(0, 0), vec2(1, 0), vec2(0, 1), vec2(1, 1)]),
        EmptyIndexSource.triangleStrip)
    static lazy val fullScreenVao = fullScreenMesh.vao(ViewportSurfaceShader.instance)
}

