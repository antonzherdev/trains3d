package com.antonzherdev.eg

class Surface(depth : bool, size : vec2i) {
    private val frameBuffer = egGenFrameBuffer
    private val depthRenderBuffer : GLuint = if(depth) egGenRenderBuffer else 0
    val texture = {
        val t = Texture()
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glBindTexture(GL_TEXTURE_2D, t.id)

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, size.x, size.y, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0)
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, t.id, 0)

        if(depth) {
            glBindRenderbuffer(GL_RENDERBUFFER, depthRenderBuffer)
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, size.x, size.y)
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderBuffer)
        }

        glBindTexture(GL_TEXTURE_2D, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        t
    }
    val material = SimpleMaterial(texture)

    def dealloc {
        egDeleteFrameBuffer(frameBuffer)
        if(depth) egDeleteRenderBuffer(depthRenderBuffer)
    }

    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def bind {
        glPushAttrib(GL_VIEWPORT_BIT)
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glViewport(0, 0, size.x, size.y)
    }

    def unbind {
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        glPopAttrib
    }

}

class FullScreenSurfaceShader extends Shader<SimpleMaterial>(ShaderProgram(vertex, fragment)) {
    static val vertex =
        "attribute vec2 position;
         varying vec2 UV;

         void main(void) {
            gl_Position = vec4(2.0*position.x - 1.0, 2.0*position.y - 1.0, 0.1, 1);
            UV = position;
        }"
    static val fragment =
        "varying vec2 UV;

         uniform sampler2D texture;

         void main(void) {
            gl_FragColor = texture2D(texture, UV);
         }"
    val positionSlot = program.attributeFor("position")
    def load(vertexBuffer : VertexBuffer<vec2>, material : SimpleMaterial) {
        material.color.cast<ColorSourceTexture>.texture.bind
        positionSlot.setFromBufferWith(vertexBuffer.stride, valuesCount = 2, GL_FLOAT, shift = 0)
    }

    def unload(material : SimpleMaterial) {
        Texture.unbind
    }
}

class FullScreenSurface(depth : bool) {
    private var surface : Surface? = nil

    private def maybeRecreateSurface {
        if(needRedraw) {
            surface = Surface(depth, context.viewport.size)
        }
    }

    def needRedraw : bool = surface.isEmpty || surface.get.size != context.viewport.size

    def bind {
        maybeRecreateSurface
        surface.get.bind
    }

    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def maybe(draw : () -> void) {
        if(needRedraw) apply(draw)
    }

    def maybe(force : bool, draw : () -> void) {
        if(force || needRedraw) apply(draw)
    }

    def unbind {
        surface.get.unbind
    }

    private lazy val fullScreenMesh = Mesh(vec2.type,
        [vec2(0, 0), vec2(1, 0), vec2(1, 1), vec2(0, 1)],
        [0, 1, 2, 2, 3, 0])
    private lazy val shader = FullScreenSurfaceShader()

    def draw {
        glDisable(GL_CULL_FACE)
        shader.draw(surface.get.material, fullScreenMesh)
        glEnable(GL_CULL_FACE)
    }
}