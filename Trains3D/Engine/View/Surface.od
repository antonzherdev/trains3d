package com.antonzherdev.eg

class Surface(size : vec2i) {
    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def bind

    def unbind

    def frameBuffer : GLint

    def init {
        if(size.x <= 0 || size.y <= 0) throw "Invalid surface size"
    }
}

class SimpleSurface(size : vec2i, depth : bool) extends Surface(size) {
    val frameBuffer = egGenFrameBuffer
    private val depthRenderBuffer : GLuint = if(depth) egGenRenderBuffer else 0
    val texture = {
        val t = Texture()
        glGetError
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glBindTexture(GL_TEXTURE_2D, t.id)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, size.x, size.y, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0)
        if(glGetError != 0) {
            val e = "Error in texture creation for surface with size $(size.x)x$(size.y)"
            throw e
        }
        glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, t.id, 0)
        val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
        if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer color attachment: $status"
        if(depth) {
            glBindRenderbuffer(GL_RENDERBUFFER, depthRenderBuffer)
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, size.x, size.y)
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderBuffer)
            val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
            if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer depth attachment: $status"
        }

        glBindTexture(GL_TEXTURE_2D, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        t
    }

    def dealloc {
        egDeleteFrameBuffer(frameBuffer)
        if(depth) egDeleteRenderBuffer(depthRenderBuffer)
    }

    def bind {
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glViewport(0, 0, size.x, size.y)
    }

    def unbind {
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
    }

}

class MultisamplingSurface(size : vec2i, depth : bool) extends Surface(size) {
    val frameBuffer = egGenFrameBuffer
    private val depthTexture : Texture? = if(depth) Texture() else nil
    val texture = {
        val t = Texture()
        glGetError
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, t.id)
        glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGBA, size.x, size.y, GL_FALSE)
        if(glGetError != 0) {
            val e = "Error in texture creation for surface with size $(size.x)x$(size.y)"
            throw e
        }
        glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, t.id, 0)
        val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
        if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer color attachment: $status"
        if(depth) {
            glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, depthTexture.get.id)
            glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_DEPTH_COMPONENT24, size.x, size.y, GL_FALSE)
            glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthTexture.get.id, 0)
            val status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
            if(status != GL_FRAMEBUFFER_COMPLETE) throw "Error in frame buffer depth attachment: $status"
        }

        glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        t
    }

    def dealloc {
        egDeleteFrameBuffer(frameBuffer)
    }

    def bind {
        glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer)
        glViewport(0, 0, size.x, size.y)
    }

    def unbind {
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
    }

}


class PairSurface(size : vec2i, depth : bool) extends  Surface(size) {
    val multisampling = MultisamplingSurface(size, depth)
    val simple = SimpleSurface(size, false)

    def bind {
        multisampling.bind
    }

    def unbind {
        multisampling.unbind

        glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampling.frameBuffer)
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, simple.frameBuffer)
        val s = size
        glBlitFramebuffer(0, 0, s.x, s.y, 0, 0, s.x, s.y, GL_COLOR_BUFFER_BIT, GL_NEAREST)
        glBindFramebuffer(GL_READ_FRAMEBUFFER, 0)
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0)
    }

    def frameBuffer : GLint = simple.frameBuffer

    def texture : Texture = simple.texture
}

class ViewportSurfaceShaderParam(texture : Texture, z : float4)

class ViewportSurfaceShader extends Shader<ViewportSurfaceShaderParam>(ShaderProgram(vertex, fragment)) {
    static val vertex =
        "#version 150
         in vec2 position;
         uniform float z;
         out vec2 UV;

         void main(void) {
            gl_Position = vec4(2.0*position.x - 1.0, 2.0*position.y - 1.0, z, 1);
            UV = position;
        }"
    static val fragment =
        "#version 150
         in vec2 UV;

         uniform sampler2D texture;
         out vec4 outColor;

         void main(void) {
            outColor = texture(texture, UV);
         }"
    val positionSlot = program.attributeFor("position")
    val zUniform = program.uniformFor("z")
    def load(vbDesc : VertexBufferDesc<_>, param : ViewportSurfaceShaderParam) {
        param.texture.bind
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, shift = vbDesc.model)
        zUniform.set(f4 = param.z)
    }

    def unload(param : ViewportSurfaceShaderParam) {
        Texture.unbind
        positionSlot.unbind
    }
}

class BaseViewportSurface {
    private var _surface : Surface? = nil
    def surface : Surface? = _surface

    private def maybeRecreateSurface {
        if(needRedraw) {
            _surface = createSurface
        }
    }

    def createSurface : Surface

    def needRedraw : bool = _surface.isEmpty || _surface.get.size != context.viewport.size

    def bind {
        maybeRecreateSurface
        _surface.get.bind
    }

    def apply(draw : () -> void) {
        bind
        draw()
        unbind
    }

    def maybe(draw : () -> void) {
        maybe(force = false, draw)
    }

    private var redrawCounter = 0 // To prevent slow resizing
    def maybe(force : bool, draw : () -> void) {
        val nr = needRedraw
        if(nr || redrawCounter > 0) redrawCounter++
        if((force && !nr) || redrawCounter > 10 || _surface.isEmpty) {
            apply(draw)
            redrawCounter = 0
        }
    }

    def unbind {
        _surface.get.unbind
    }

    static lazy val fullScreenMesh = Mesh.vec2(
        [vec2(0, 0), vec2(1, 0), vec2(1, 1), vec2(0, 1)],
        [0, 1, 2, 2, 3, 0])
}

class ViewportSurface(depth : bool, multisampling : bool) extends BaseViewportSurface {
    def createSurface : Surface =
        if(multisampling) PairSurface(context.viewport.size, depth)
        else SimpleSurface(context.viewport.size, depth)

    private lazy val shader = ViewportSurfaceShader()

    def drawWith(z : float4) {
        glDisable(GL_CULL_FACE)
        shader.draw(ViewportSurfaceShaderParam(texture, z), fullScreenMesh)
        glEnable(GL_CULL_FACE)
    }

    def texture : Texture = case(surface.get) {
        i : SimpleSurface -> i.texture
        i : PairSurface -> i.texture
    }

    def draw {
        if(surface.isEmpty) return nil
        if(needRedraw) {
            glDisable(GL_DEPTH_TEST)
            glDisable(GL_CULL_FACE)
            shader.draw(ViewportSurfaceShaderParam(texture, 0), fullScreenMesh)
            glEnable(GL_CULL_FACE)
            glEnable(GL_DEPTH_TEST)
        } else {
            glBindFramebuffer(GL_READ_FRAMEBUFFER, surface.get.frameBuffer)
            val s = surface.get.size
            val v = context.viewport
            glBlitFramebuffer(0, 0, s.x, s.y, v.x, v.y, v.x2, v.y2, GL_COLOR_BUFFER_BIT, GL_NEAREST)
            glBindFramebuffer(GL_READ_FRAMEBUFFER, 0)
        }
    }
}