package com.antonzherdev.eg

import com.antonzherdev.eg.EGGL._

class EG {
    static def director : EGDirector = context.director
    static val context : EGContext = EGContext()
    static val matrix : EGMatrixStack = context.matrixStack
    static def textureFor(file : string) : EGFileTexture = context.textureFor(file)
}

class EGContext {
    private val textureCache = MutableHashMap<string, EGFileTexture>()

    def textureFor(file : string) : EGFileTexture = textureCache.objectFor(key = file, orUpdateWith = EGFileTexture(file))

    var director : EGDirector
    var environment = EGEnvironment.default
    val matrixStack = EGMatrixStack()
}

class EGMatrixStack {
    private var stack = List<EGMatrixModel>()
    var value = EGMatrixModel.identity

    def clear {
        value = EGMatrixModel.identity
        stack = List<EGMatrixModel>()
    }

    def push {
        stack = List(value, stack)
    }

    def pop {
        value = stack.head.get
        stack = stack.tail
    }

    def apply(modify : EGMatrixModel -> EGMatrixModel, f : () -> void) {
        push
        value = modify(value)
        f()
        pop
    }
}

class EGMatrixModel(m : mat4, w : mat4, c : mat4, p : mat4,
    _mw : Lazy<mat4>, _mwc : Lazy<mat4>, _mwcp : Lazy<mat4>,
    _cp : Lazy<mat4>, _wcp : Lazy<mat4>, _wc : Lazy<mat4>)
{
    static def apply(m : mat4, w : mat4, c : mat4, p : mat4) : EGMatrixModel = {
        val _mw = Lazy(w.mul(m))
        val _mwc = Lazy(c.mul(_mw.get))
        val _cp = Lazy(p.mul(c))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(c.mul(w))
        val _wcp = Lazy(p.mul(_wc.get))
        EGMatrixModel(m, w, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }
    static val identity = EGMatrixModel(mat4.identity, mat4.identity, mat4.identity, mat4.identity)
    def mw = _mw.get
    def mwc = _mwc.get
    def mwcp = _mwcp.get
    def cp = _cp.get
    def wcp = _wcp.get
    def wc = _wc.get

    def modify(m : mat4 -> mat4) : EGMatrixModel = {
        val mm = m(self.m)
        val _mw = Lazy(w.mul(mm))
        val _mwc = Lazy(c.mul(_mw.get))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        EGMatrixModel(mm, w, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }


    def modify(w : mat4 -> mat4) : EGMatrixModel = {
        val ww = w(self.w)
        val _mw = Lazy(ww.mul(m))
        val _mwc = Lazy(c.mul(_mw.get))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(c.mul(ww))
        val _wcp = Lazy(p.mul(_wc.get))
        EGMatrixModel(m, ww, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }

    def modify(c : mat4 -> mat4) : EGMatrixModel = {
        val cc = c(self.c)
        val _mwc = Lazy(cc.mul(_mw.get))
        val _cp = Lazy(p.mul(cc))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(cc.mul(w))
        val _wcp = Lazy(p.mul(_wc.get))
        EGMatrixModel(m, w, cc, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }

    def modify(p : mat4 -> mat4) : EGMatrixModel = {
        val pp = p(self.p)
        val _cp = Lazy(pp.mul(c))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wcp = Lazy(pp.mul(_wc.get))
        EGMatrixModel(m, w, c, pp, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }
}
