import EGTexture
import EGMatrix
import EGGL


class EGContext {
    private val textureCache = CNMutableHashMap<string, EGTexture>()

    def textureFor(file : string) : EGTexture = textureCache.objectFor(key = file, orUpdateWith = EGTexture(file))


    val modelMatrix = EGMutableMatrix()
    val viewMatrix = EGMutableMatrix()
    val projectionMatrix = EGMutableMatrix()
    def mvp : EGMatrix = projectionMatrix.value.multiply(viewMatrix.value).multiply(modelMatrix.value)

    def clearMatrix {
        modelMatrix.clear
        viewMatrix.clear
        projectionMatrix.clear
    }
}

class EGMutableMatrix {
    private var _stack = CNList<EGMatrix>()
    private var _value = EGMatrix.identity

    def push {
        _stack = CNList(_value, _stack)
    }

    def pop {
        _value = _stack.head.get
        _stack = _stack.tail
    }

    def value : EGMatrix = _value
    def set(value : EGMatrix) {
        _value = value
    }

    def setIdentity {
        glLoadIdentity
        _value = EGMatrix.identity
    }

    def clear {
        setIdentity
        _stack = CNList<EGMatrix>()
    }

    def rotate(angle : float, x : float, y : float, z : float) {
        egRotate(angle, x, y, z)
        _value = _value.rotate(angle, x, y, z)
    }
    def scale(x : float, y : float, z : float) {
        egScale(x, y, z)
        _value = _value.scale(x, y, z)
    }
    def translate(x : float, y : float, z : float) {
        egTranslate(x, y, z)
        _value = _value.translate(x, y, z)
    }
    def ortho(left : float, right : float, bottom : float, top : float, zNear : float, zFar : float) {
        glOrtho(left, right, bottom, top, zNear, zFar)
        _value = EGMatrix.ortho(left, right, bottom, top, zNear, zFar)
    }
}