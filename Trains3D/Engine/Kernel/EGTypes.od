import "EGTypesAdd.h"
import EGGL

struct EGPoint(x : float, y : float) extends ODComparable<EGPoint> {
    static def apply(point : EGPointI) = EGPoint(point.x, point.y)

    def add(point : EGPoint) = EGPoint(x + point.x, y + point.y)
    def sub(point : EGPoint) = EGPoint(x - point.x, y - point.y)
    def negate = EGPoint(-x, -y)
    def angle : float = atan2(y, x)
    def dot(point : EGPoint) : float = x*point.x + y*point.y
    def lengthSquare : float = dot(self)
    def length = sqrt(lengthSquare)
    def mul(value : float) = EGPoint(x*value, y*value)
    def div(value : float) = EGPoint(x/value, y/value)
    def mid(point : EGPoint) = add(point).mul(0.5)
    def distanceTo(point : EGPoint) = sub(point).length
    def set(length : float) = mul(length/self.length)
    def normalize = set(length = 1.0)

    def compare(to : EGPoint) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }
}

struct EGPointI(x : int, y : int) extends ODComparable<EGPointI> {
    static def apply(point : EGPoint) = EGPointI(lround(point.x), lround(point.y))

    def add(point : EGPointI) = EGPointI(x + point.x, y + point.y)
    def sub(point : EGPointI) = EGPointI(x - point.x, y - point.y)
    def negate = EGPointI(-x, -y)

    def compare(to : EGPointI) : int = {
        val dX = x.compare(to.x)
        if(dX != 0) dX else y.compare(to.y)
    }
}

struct EGSize(width : float, height : float)
struct EGSizeI(width : int, height : int)
struct EGRect(x : float, width : float, y : float, height : float) {
    def contains(point : EGPoint) : bool = x <= point.x && point.x <= x + width && y <= point.y && point.y <= y + height
    def x2 : float = x + width
    def y2 : float = y + height

    static def newXY(x : float, x2: float, y : float, y2 : float) : EGRect = EGRect(x, x2 - x, y, y2 - y)

    def move(x : float, y : float) = EGRect(self.x + x, width, self.y + y, height)
    def moveToCenterFor(size : EGSize) = EGRect((size.width - width)/2, width, (size.height - height)/2, height)
    def point : EGPoint = EGPoint(x, y)
    def size : EGSize = EGSize(width, height)

    def intersects(rect : EGRect) : bool =
        x <= rect.x2 && x2 >= rect.x &&
        y <= rect.y2 && y2 >= rect.y

    def thicken(x : float, y : float) = EGRect(self.x - x, width + 2*x, self.y - y, height + 2*y)

}
struct EGRectI(x : int, width : int, y : int, height : int) {
    static def apply(rect : EGRect) = EGRectI(lround(rect.x), lround(rect.width), lround(rect.y), lround(rect.height))
    static def newXY(x : float, x2: float, y : float, y2 : float) : EGRectI = EGRectI(x, x2 - x, y, y2 - y)
    def x2 : int = x + width
    def y2 : int  = y + height
}

struct EGColor(r : float, g : float, b : float, a : float) {
    def set = egColor4(r, g, b, a)
}

stub val M_PI : float
stub val M_PI_2 : float
stub val M_PI_4 : float
stub def round(: float) : float
stub def lround(: float) : int
stub def sin(:float) : float
stub def cos(:float) : float
stub def fabs(:float) : float
stub def atan2(:float, :float) : float
stub def atan(:float) : float
stub def sqrt(:float) : float

trait EGController {
    def updateWith(delta : float)
}

trait EGCamera {
    def focusFor(viewSize : EGSize)

    def translateWith(viewSize : EGSize, viewPoint : EGPoint) : EGPoint
}

trait EGView {
    def camera : EGCamera

    def drawView
}

