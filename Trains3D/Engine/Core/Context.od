package com.antonzherdev.eg

object Global {
    def director : Director = context.director
    val context : Context = Context()
    val matrix : MatrixStack = context.matrixStack
    def textureFor(file : string) : Texture = context.textureFor(file, GL_LINEAR, GL_LINEAR)
    def nearestTextureFor(file : string) : Texture = context.textureFor(file, GL_NEAREST, GL_NEAREST)
    def textureFor(file : string, magFilter : uint4, minFilter : uint4) : Texture = context.textureFor(file, magFilter, minFilter)
    def fontWith(name : string) : Font = context.fontWith(name)
}

class Context {
    var defaultFramebuffer : GLint = 0
    private val textureCache = MutableHashMap<(string, uint4, uint4), FileTexture>()
    private val fontCache = MutableHashMap<string, Font>()

    def textureFor(file : string, magFilter : uint4, minFilter : uint4) : Texture =
        textureCache.objectFor(key = (file, magFilter.cast<uint4>, minFilter.cast<uint4>), orUpdateWith = FileTexture(file, magFilter, minFilter))
    def fontWith(name : string) : Font = fontCache.objectFor(key = name, orUpdateWith = Font(name))

    var director : Director
    var environment = Environment.default
    val matrixStack = MatrixStack()
    var renderTarget : RenderTarget = SceneRenderTarget()
    var considerShadows = true

    def clear {
        matrixStack.clear
        considerShadows = true
        _viewport = RectI(0, 0, 0, 0)
        _lastTexture2D = 0
        _lastShaderProgram = 0
        _lastIndexBuffer = 0
        _lastVertexBuffer = 0
    }

    private var _viewportStack = List<RectI>()
    private var _viewport : RectI
    def viewport = _viewport
    def set(viewport : RectI) {
        if(_viewport != viewport) {
            _viewport = viewport
            egViewport(viewport)
        }
    }
    def pushViewport {
        _viewportStack = List(viewport, _viewportStack)
    }
    def popViewport {
        set(viewport = _viewportStack.head)
        _viewportStack = _viewportStack.tail
    }
    def restoreDefaultFramebuffer {
        glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebuffer)
    }

    private var _lastTexture2D : GLuint = 0
    def bindTexture(texture : Texture) {
        val id = texture.id
        if(_lastTexture2D != id) {
            _lastTexture2D = id
            glBindTexture(GL_TEXTURE_2D, id)
        }
    }

    def bindTexture(slot : uint4, target : uint4, texture : Texture) {
        val id = texture.id
        if(slot != GL_TEXTURE0) {
            glActiveTexture(slot)
            glBindTexture(target, id)
            glActiveTexture(GL_TEXTURE0)
        } else {
            if(target == GL_TEXTURE_2D) {
                if(_lastTexture2D != id) {
                    _lastTexture2D = id
                    glBindTexture(target, id)
                }
            } else glBindTexture(target, id)
        }
    }

    private var _lastShaderProgram : GLuint = 0
    def bindShaderProgram(program : ShaderProgram) {
        val id = program.handle
        if(id != _lastShaderProgram) {
            _lastShaderProgram = id
            glUseProgram(id)
        }
    }

    private var _lastVertexBuffer : GLuint = 0
    def bindVertexBuffer(buffer : VertexBuffer<_>) {
        val id = buffer.handle
        if(id != _lastVertexBuffer) {
            _lastVertexBuffer = id
            glBindBuffer(GL_ARRAY_BUFFER, id)
        }
    }
    def vertexBufferId : GLuint = _lastVertexBuffer

    private var _lastIndexBuffer : GLuint = 0
    def bindIndexBuffer(buffer : IndexBuffer) {
        val id = buffer.handle
        if(id != _lastIndexBuffer) {
            _lastIndexBuffer = id
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id)
        }
    }
    def indexBufferId : GLuint = _lastIndexBuffer

    val cullFace : EnablingState = EnablingState(GL_CULL_FACE)
    val blend : EnablingState = EnablingState(GL_BLEND)
    def draw {
        cullFace.draw
        blend.draw
    }
}

class EnablingState(tp: uint4) {
    private var _last : bool = false
    private var _coming : bool = false

    def enable {
        _coming = true
    }

    def disable {
        _coming = false
    }

    def draw {
        if(_last != _coming) {
            if(_coming) glEnable(tp)
            else glDisable(tp)
            _last = _coming
        }
    }

    def clear {
        _last = false
        _coming = false
    }

    def disabled(f : () -> void) {
        if(_coming) {
            _coming = false
            f()
            _coming = true
        } else {
            f()
        }
    }

    def enabled(f : () -> void) {
        if(!_coming) {
            _coming = true
            f()
            _coming = false
        } else {
            f()
        }
    }
}

class RenderTarget
class SceneRenderTarget extends RenderTarget
class ShadowRenderTarget(shadowLight : Light) extends RenderTarget

class Environment(ambientColor : vec4, lights : [Light]) {
    static val default = Environment(vec4(1, 1, 1, 1), [])
    static def apply(lights : [Light]) = Environment(vec4(1, 1, 1, 1), lights)
    static def apply(light : Light) = Environment(vec4(1, 1, 1, 1), [light])
}

class Light(color : vec4, hasShadows : bool) {
    lazy val shadowMap : ShadowMap = ShadowMap(vec2(1024, 1024))

    def shadowMatrix(model : MatrixModel) : MatrixModel = throw "Shadows are not supported for $(self.type)"
}
class DirectLight(color : vec4, direction : vec3, hasShadows : bool, shadowsProjectionMatrix : mat4) extends Light(color, hasShadows) {
    static def apply(color : vec4, direction : vec3) = DirectLight(color, direction, false, mat4.identity)
    static def apply(color : vec4, direction : vec3, shadowsProjectionMatrix : mat4) = DirectLight(color, direction, true, shadowsProjectionMatrix)
    def shadowMatrix(model : MatrixModel) : MatrixModel =
        model.modify(c = mat4.lookAt((model.w * vec4(direction, 0)).xyz.normalize.negate, vec3(0, 0, 0), vec3(0, 1, 0)))
             .modify(p = shadowsProjectionMatrix)
}

class MatrixStack {
    private var stack = List<MatrixModel>()
    var value = MatrixModel.identity

    def clear {
        value = MatrixModel.identity
        stack = List<MatrixModel>()
    }

    def push {
        stack = List(value, stack)
    }

    def pop {
        value = stack.head
        stack = stack.tail
    }

    def apply(modify : MatrixModel -> MatrixModel, f : () -> void) {
        push
        value = modify(value)
        f()
        pop
    }

    def m = value.m
    def w = value.w
    def c = value.c
    def p = value.p
    def mw = value.mw
    def mwc = value.mwc
    def mwcp = value.mwcp
    def wc = value.wc
    def wcp = value.wcp
    def cp = value.cp
}

class MatrixModel(m : mat4, w : mat4, c : mat4, p : mat4,
    _mw : Lazy<mat4>, _mwc : Lazy<mat4>, _mwcp : Lazy<mat4>,
    _cp : Lazy<mat4>, _wcp : Lazy<mat4>, _wc : Lazy<mat4>)
{
    static def apply(m : mat4, w : mat4, c : mat4, p : mat4) : MatrixModel = {
        val _mw = Lazy(w.mul(m))
        val _mwc = Lazy(c.mul(_mw.get))
        val _cp = Lazy(p.mul(c))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(c.mul(w))
        val _wcp = Lazy(p.mul(_wc.get))
        MatrixModel(m, w, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }
    static val identity = MatrixModel(mat4.identity, mat4.identity, mat4.identity, mat4.identity)
    def mw = _mw.get
    def mwc = _mwc.get
    def mwcp = _mwcp.get
    def cp = _cp.get
    def wcp = _wcp.get
    def wc = _wc.get

    def modify(m : mat4 -> mat4) : MatrixModel = {
        val mm = m(self.m)
        val _mw = Lazy(w.mul(mm))
        val _mwc = Lazy(c.mul(_mw.get))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        MatrixModel(mm, w, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }


    def modify(w : mat4 -> mat4) : MatrixModel = {
        val ww = w(self.w)
        val _mw = Lazy(ww.mul(m))
        val _mwc = Lazy(c.mul(_mw.get))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(c.mul(ww))
        val _wcp = Lazy(p.mul(_wc.get))
        MatrixModel(m, ww, c, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }

    def modify(c : mat4 -> mat4) : MatrixModel = {
        val cc = c(self.c)
        val _mwc = Lazy(cc.mul(_mw.get))
        val _cp = Lazy(p.mul(cc))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wc = Lazy(cc.mul(w))
        val _wcp = Lazy(p.mul(_wc.get))
        MatrixModel(m, w, cc, p, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }

    def modify(p : mat4 -> mat4) : MatrixModel = {
        val pp = p(self.p)
        val _cp = Lazy(pp.mul(c))
        val _mwcp = Lazy(_cp.get.mul(_mw.get))
        val _wcp = Lazy(pp.mul(_wc.get))
        MatrixModel(m, w, c, pp, _mw, _mwc, _mwcp, _cp, _wcp, _wc)
    }
}
