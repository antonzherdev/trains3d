package com.antonzherdev.eg

class Director {
    static private var _current : Director
    static def current : Director = _current

    private var _scene : Scene? = nil
    private var _isStarted = false
    private var _isPaused = false
    val time : Time = Time()
    def scene = _scene
    def set(scene : () -> Scene) {
        lock
        if(_scene.isDefined) {
            _scene.get.stop
            clearRecognizers
        }

        context.scale = scale
        val sc = scene()
        _scene = sc
        context.clearCache
        if(_lastViewSize != vec2(0, 0)) sc.reshapeWith(_lastViewSize)
        sc.recognizersTypes.for(register(_))
        sc.start

        if(_isPaused) redraw
        unlock
    }

    def clearRecognizers
    def register(recognizerType : RecognizerType<_>)

    def scale : float
    def lock
    def unlock
    def redraw

    def init {
        _current = self
    }

    static val reshapeNotification = NotificationHandle<Director, vec2>("Reshape")

    private var _lastViewSize : vec2 = vec2(0, 0)
    def viewSize : vec2 = _lastViewSize

    def reshapeWith(size : vec2) {
        if(_lastViewSize != size) {
//            log("reshape($size) {")
            context.scale = scale
            _lastViewSize = size
            _scene.for(_.reshapeWith(size))
            reshapeNotification.post(sender = self, data = size)
//            log("} reshape")
        }
    }

    def draw {
        if(_scene.isEmpty) return nil
        if(_lastViewSize.x <= 0 || _lastViewSize.y <= 0) return nil
//        log("draw {")
        val sc = _scene.get

        _current = self
        context.clear
        context.depthTest.enable

        sc.prepareWith(_lastViewSize)
        context.clearColor(_scene.get.backgroundColor)
        glClear(GL_COLOR_BUFFER_BIT + GL_DEPTH_BUFFER_BIT)
        sc.drawWith(_lastViewSize)

        context.depthTest.disable
        matrix.clear
        context.set(viewport = Rect(vec2(0, 0), _lastViewSize))
        _stat.for(_.draw)
//        log("} draw")
    }


    def process(event : Event) {
        _scene.for(_.process(event))
    }

    def isStarted = _isStarted
    def start {
        _isStarted = true
        time.start
    }
    def stop {
        _isStarted = false
    }

    def isPaused = _isPaused
    def pause {
        _isPaused = true
        _scene.for(_.pause)
        redraw
    }

    def resume {
        if(_isPaused) {
            _isPaused = false
            time.start
            _scene.for(_.resume)
        }
    }

    private var _timeSpeed = 1.0
    def timeSpeed = _timeSpeed
    def set(timeSpeed : float) {
        if(_timeSpeed != timeSpeed) {
            _timeSpeed = timeSpeed
            SoundDirector.instance.timeSpeed = _timeSpeed
        }
    }

    def tick {
//        log("tick {")
        _current = self
        time.tick
        _scene.for(_.updateWith(time.delta*_timeSpeed))
        _stat.for(_.tickWith(time.delta))
//        log("} tick")
    }

    private var _stat : Stat? = nil
    def stat = _stat
    def isDisplayingStats = _stat.isDefined
    def displayStats {
        _stat = Stat()
    }
    def cancelDisplayingStats {_stat = nil}
}