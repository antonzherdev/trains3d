package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def focus {}

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : [Layer]) {
    def drawWith(viewSize : vec2) {
        layers.for(_.drawWith(viewSize))
    }

    def process(event : Event) = layers.chain.reverse.fold((r, layer) -> r || layer.process(event), false)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.for(_.updateWith(delta))
    }
}

class Layer(view : LayerView, processor : InputProcessor?) extends Controller {
    def drawWith(viewSize : vec2) {
        context.environment = view.environment
        val camera = view.camera
        context.set(viewport = viewportWith(viewSize))
        matrix.value = camera.matrixModel
        camera.focus
        view.drawView
    }

    def process(event : Event) : bool = {
        processor.map{ p ->
            val cam = EventCamera(inverseMatrix = view.camera.matrixModel.wcp.inverse, viewportWith(event.viewSize))
            val e = event.set(camera = cam)
            p.process(e)
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) : rect = {
        val vpr = view.camera.viewportRatio
        val srt =  viewSize/vpr
        val vpSize = if(viewSize.x/viewSize.y < vpr) vec2(viewSize.x, viewSize.x/vpr) else vec2(viewSize.y*vpr, viewSize.y)
        vpSize.rectInCenterWith(viewSize)
    }
}

trait LayerView extends Controller {
    def camera : Camera

    def drawView

    def environment = Environment.default

    def updateWith(delta : float) {}
}
