package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def cullFace : uint = GL_NONE

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : Layers) {
    def drawWith(viewSize : vec2) {
        layers.drawWith(viewSize)
    }

    def process(event : Event) : bool = layers.process(event)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.updateWith(delta)
    }
}

class Layers {
    static def apply(layer : Layer) = SingleLayer(layer)

    def layers : [Layer]

    def viewportsWith(viewSize : vec2) : [(Layer, Rect)]

    def drawWith(viewSize : vec2) {
        viewportsWith(viewSize).for{p -> p.a.drawWith(viewport = p.b)}
    }

    def process(event : Event) : bool = {
        var r = false
        viewportsWith(event.viewSize).for{p -> r = (r || p.a.process(event, viewport = p.b))}
        r
    }

    def updateWith(delta : float) {
        layers.for(_.updateWith(delta))
    }
}

class SingleLayer(layer : Layer) extends Layers {
    val layers = [layer]
    def viewportsWith(viewSize : vec2) = [(layer, layer.viewportWith(viewSize))]
}

class Layer(view : LayerView, processor : InputProcessor?) extends Controller {
    static def apply(view : LayerView) : Layer = Layer(view, view.as<InputProcessor>)
    def drawWith(viewport : Rect) {
        val env = view.environment
        context.environment = env
        val camera = view.cameraWith(viewport)
        val cullFace = camera.cullFace
        if(cullFace != GL_NONE) glEnable(GL_CULL_FACE)

        val shadowLights = env.lights.chain.filter(_.hasShadows).toArray
        env.lights.chain.filter(_.hasShadows).for{light ->
            context.isShadowsDrawing = true
            context.shadowLight = light
            matrix.value = light.shadowMatrix(camera.matrixModel)
            light.shadowMap.biasDepthCp = ShadowMap.biasMatrix *matrix.value.cp
            light.shadowMap{
                glClear(GL_DEPTH_BUFFER_BIT)
                if(cullFace != GL_NONE) glCullFace(if(cullFace == GL_BACK) GL_FRONT else GL_BACK)
                view.draw
            }
            context.shadowLight = nil
            context.isShadowsDrawing = false
//            light.shadowMap.draw
        }
        context.set(viewport = viewport)
        matrix.value = camera.matrixModel
        if(cullFace != GL_NONE) glCullFace(cullFace)

        view.draw
        if(cullFace != GL_NONE) glDisable(GL_CULL_FACE)
//        if(director.isPaused) { if(!env.lights.isEmpty)env.lights[0].shadowMap.draw}
//        else view.draw
    }

    def process(event : Event, viewport : Rect) : bool = {
        processor.map{ p ->
            if(p.isProcessorActive) {
                val cam = EventCamera(matrix = view.cameraWith(viewport).matrixModel.wcp, viewport)
                val e = event.set(camera = cam)
                p.process(e)
            } else false
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) = viewportWith(viewSize, viewportLayout = Rect(0, 0, 1, 1))

    def viewportWith(viewSize : vec2, viewportLayout : Rect) : Rect = {
        val layout = viewportLayout
        val vpr = view.camera.viewportRatio

        val size = viewSize*viewportLayout.size
        val vpSize =
        if(size.x == 0 && size.y == 0) vec2(viewSize.x, viewSize.y)
        else if(size.x == 0) vec2(viewSize.x, size.y)
        else if(size.y == 0) vec2(size.x, viewSize.y)
        else if(size.x/size.y < vpr) vec2(size.x, size.x/vpr) else vec2(size.y*vpr, size.y)
        val po = viewportLayout.p0/2 + 0.5
        Rect((viewSize - vpSize) * po, vpSize)
    }
}

trait LayerView extends Controller {
    def camera : Camera = cameraWith(viewport = Rect(-1, -1, 2, 2))

    def cameraWith(viewport : Rect) : Camera = camera

    def draw

    def environment = Environment.default

    def updateWith(delta : float) {}
}
