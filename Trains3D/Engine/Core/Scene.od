package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def cullFace : uint = GL_NONE

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : Layers, soundPlayer : SoundPlayer?) {
    private var _lastViewSize : vec2 = vec2(0, 0)
    def prepareWith(viewSize : vec2) {
        if(_lastViewSize != viewSize) {
            _lastViewSize = viewSize
            layers.reshapeWith(viewSize)
        }
        layers.prepare
    }

    def drawWith(viewSize : vec2) {
        layers.draw
    }

    def process(event : Event) : bool = layers.process(event)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.updateWith(delta)
        soundPlayer.for(_.updateWith(delta))
    }

    def start {
        soundPlayer.for(_.start)
    }

    def stop {
        soundPlayer.for(_.stop)
    }

    def pause {
        soundPlayer.for(_.pause)
    }

    def resume {
        soundPlayer.for(_.resume)
    }

    def scaleWith(viewSize : vec2) : float = layers.scaleWith(viewSize)
}

class Layers {
    static def apply(layer : Layer) = SingleLayer(layer)

    def layers : [Layer]

    def viewportsWith(viewSize : vec2) : [(Layer, Rect)]
    private val _viewports : [(Layer, Rect)] = []
    def prepare {
        egPushGroupMarker("Prepare")
        _viewports.for{p -> p.a.prepareWith(viewport = p.b)}
        egPopGroupMarker

    }
    def draw {
       egPushGroupMarker("Draw")
        _viewports.for{p -> p.a.drawWith(viewport = p.b)}
       egPopGroupMarker
    }

    def process(event : Event) : bool = {
        var r = false
        viewportsWith(event.viewSize).for{p -> r = (r || p.a.process(event, viewport = p.b))}
        r
    }

    def updateWith(delta : float) {
        layers.for(_.updateWith(delta))
    }

    def reshapeWith(viewSize : vec2) {
        _viewports = viewportsWith(viewSize)
        _viewports.for{p -> p.a.reshapeWith(viewport = p.b)}
    }

    def scaleWith(viewSize : vec2) : float = 1.0
}

class SingleLayer(layer : Layer) extends Layers {
    val layers = [layer]
    def viewportsWith(viewSize : vec2) = [(layer, layer.viewportWith(viewSize))]
}

class Layer(view : LayerView, inputProcessor : InputProcessor?) extends Controller {
    static def apply(view : LayerView) : Layer = Layer(view, view.as<InputProcessor>)
    def prepareWith(viewport : Rect) {
        egPushGroupMarker(view.name)
        val env = view.environment
        context.environment = env
        val camera = view.camera
        val cullFace = camera.cullFace
        if(cullFace != GL_NONE) context.cullFace.enable


        context.renderTarget = SceneRenderTarget()
        context.set(viewport = viewport)
        matrix.value = camera.matrixModel
        if(cullFace != GL_NONE) glCullFace(cullFace)
        view.prepare

        if(egPlatform.shadows) {
            val shadowLights = env.lights.chain.filter(_.hasShadows).toArray
            env.lights.chain.filter(_.hasShadows).for{light ->
                drawShadowFor(camera, light)
            }
        }
        if(cullFace != GL_NONE) context.cullFace.disable

        egCheckError
        egPopGroupMarker
    }

    def reshapeWith(viewport : Rect) {
        context.set(viewport = viewport)
        view.reshapeWith(viewport)
    }

    def drawWith(viewport : Rect) {
        egPushGroupMarker(view.name)
        val env = view.environment
        context.environment = env
        val camera = view.camera
        val cullFace = camera.cullFace
        if(cullFace != GL_NONE) context.cullFace.enable
        context.renderTarget = SceneRenderTarget()
        context.set(viewport = viewport)
        matrix.value = camera.matrixModel
        if(cullFace != GL_NONE) glCullFace(cullFace)
        view.draw
        if(cullFace != GL_NONE) context.cullFace.disable
        egCheckError
        egPopGroupMarker
    }

    def drawShadowFor(camera : Camera, light : Light) {
        egPushGroupMarker("Shadow")
        context.renderTarget = ShadowRenderTarget(light)
        matrix.value = light.shadowMatrix(camera.matrixModel)
        light.shadowMap.biasDepthCp = ShadowMap.biasMatrix *matrix.value.cp
        light.shadowMap{
            glClear(GL_DEPTH_BUFFER_BIT)
            val cullFace = camera.cullFace
            if(cullFace != GL_NONE) glCullFace(if(cullFace == GL_BACK) GL_FRONT else GL_BACK)
            view.draw
        }
        egCheckError
        egPopGroupMarker
    }

    def process(event : Event, viewport : Rect) : bool = {
        inputProcessor.map{ p ->
            if(p.isProcessorActive) {
                val camera = view.camera
                matrix.value = camera.matrixModel
                val cam = EventCamera(camera.matrixModel, viewport)
                val e = event.set(camera = cam)
                p.process(e)
            } else false
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) = viewportWith(viewSize, viewportLayout = Rect(0, 0, 1, 1))

    def viewportWith(viewSize : vec2, viewportLayout : Rect) : Rect = {
        val layout = viewportLayout
        val vpr = view.camera.viewportRatio

        val size = viewSize*viewportLayout.size
        val vpSize =
        if(size.x == 0 && size.y == 0) vec2(viewSize.x, viewSize.y)
        else if(size.x == 0) vec2(viewSize.x, size.y)
        else if(size.y == 0) vec2(size.x, viewSize.y)
        else if(size.x/size.y < vpr) vec2(size.x, size.x/vpr) else vec2(size.y*vpr, size.y)
        val po = viewportLayout.p0/2 + 0.5
        Rect((viewSize - vpSize) * po, vpSize)
    }
}

trait LayerView extends Controller {
    def name : string

    def camera : Camera

    def prepare {}

    def draw

    def environment = Environment.default

    def updateWith(delta : float) {}

    def reshapeWith(viewport : Rect) {}
}
