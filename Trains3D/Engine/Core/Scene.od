package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def focus {}

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : [Layer]) {
    def drawWith(viewSize : vec2) {
        layers.for(_.drawWith(viewSize))
    }

    def process(event : Event) = layers.chain.reverse.fold((r, layer) -> r || layer.process(event), false)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.for(_.updateWith(delta))
    }
}

class Layer(view : LayerView, processor : InputProcessor?) extends Controller {
    def drawWith(viewSize : vec2) {
        context.environment = view.environment
        val camera = view.camera
        context.set(viewport = viewportWith(viewSize))
        matrix.value = camera.matrixModel
        camera.focus
        view.drawView
    }

    def process(event : Event) : bool = {
        processor.map{ p ->
            val cam = EventCamera(inverseMatrix = view.camera.matrixModel.wcp.inverse, viewportWith(event.viewSize))
            val e = event.set(camera = cam)
            p.process(e)
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) : rect = {
        val layout = view.viewportLayout
        val vpr = view.camera.viewportRatio

        val size = viewSize*layout.size
        val vpSize = if(size.x/size.y < vpr) vec2(size.x, size.x/vpr) else vec2(size.y*vpr, size.y)
        val po = layout.origin/2 + 0.5
        rect((viewSize - vpSize) * po, vpSize)
    }
}

trait LayerView extends Controller {
    def camera : Camera

    def drawView

    def environment = Environment.default

    def updateWith(delta : float) {}

    def viewportLayout : rect = rect(0, 0, 1, 1)
}
