package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def focus {}

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : Layers) {
    def drawWith(viewSize : vec2) {
        layers.drawWith(viewSize)
    }

    def process(event : Event) : bool = layers.process(event)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.updateWith(delta)
    }
}

class Layers {
    static def apply(layer : Layer) = SingleLayer(layer)

    def layers : [Layer]

    def viewportsWith(viewSize : vec2) : [(Layer, rect)]

    def drawWith(viewSize : vec2) {
        viewportsWith(viewSize).for{p -> p.a.drawWith(viewport = p.b)}
    }

    def process(event : Event) : bool = {
        var r = false
        viewportsWith(event.viewSize).for{p -> r = (r || p.a.process(event, viewport = p.b))}
        r
    }

    def updateWith(delta : float) {
        layers.for(_.updateWith(delta))
    }
}

class SingleLayer(layer : Layer) extends Layers {
    val layers = [layer]
    def viewportsWith(viewSize : vec2) = [(layer, layer.viewportWith(viewSize))]
}

class Layer(view : LayerView, processor : InputProcessor?) extends Controller {
    def drawWith(viewport : rect) {
        context.environment = view.environment
        context.set(viewport = viewport)
        val camera = view.cameraWith(viewport)
        matrix.value = camera.matrixModel
        camera.focus
        view.draw
    }

    def process(event : Event, viewport : rect) : bool = {
        processor.map{ p ->
            val cam = EventCamera(matrix = view.cameraWith(viewport).matrixModel.wcp, viewport)
            val e = event.set(camera = cam)
            p.process(e)
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) = viewportWith(viewSize, viewportLayout = rect(0, 0, 1, 1))

    def viewportWith(viewSize : vec2, viewportLayout : rect) : rect = {
        val layout = viewportLayout
        val vpr = view.camera.viewportRatio

        val size = viewSize*viewportLayout.size
        val vpSize =
        if(size.x == 0 && size.y == 0) vec2(viewSize.x, viewSize.y)
        else if(size.x == 0) vec2(viewSize.x, size.y)
        else if(size.y == 0) vec2(size.x, viewSize.y)
        else if(size.x/size.y < vpr) vec2(size.x, size.x/vpr) else vec2(size.y*vpr, size.y)
        val po = viewportLayout.origin/2 + 0.5
        rect((viewSize - vpSize) * po, vpSize)
    }
}

trait LayerView extends Controller {
    def camera : Camera = cameraWith(viewport = rect(-1, -1, 2, 2))

    def cameraWith(viewport : rect) : Camera = camera

    def draw

    def environment = Environment.default

    def updateWith(delta : float) {}
}
