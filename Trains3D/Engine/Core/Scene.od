package com.antonzherdev.eg

trait Controller {
    def updateWith(delta : float)
}

trait Camera {
    def focus {}

    def matrixModel : MatrixModel

    def viewportRatio : float //width/height
}


class Scene(backgroundColor : vec4, controller : Controller, layers : Layers) {
    def drawWith(viewSize : vec2) {
        layers.drawWith(viewSize)
    }

    def process(event : Event) : bool = layers.process(event)

    def updateWith(delta : float) {
        controller.updateWith(delta)
        layers.updateWith(delta)
    }
}

class Layers {
    static def apply(layer : Layer) = SingleLayer(layer)

    def layers : [Layer]

    def viewportsWith(viewSize : vec2) : [(Layer, Rect)]

    def drawWith(viewSize : vec2) {
        viewportsWith(viewSize).for{p -> p.a.drawWith(viewport = p.b)}
    }

    def process(event : Event) : bool = {
        var r = false
        viewportsWith(event.viewSize).for{p -> r = (r || p.a.process(event, viewport = p.b))}
        r
    }

    def updateWith(delta : float) {
        layers.for(_.updateWith(delta))
    }
}

class SingleLayer(layer : Layer) extends Layers {
    val layers = [layer]
    def viewportsWith(viewSize : vec2) = [(layer, layer.viewportWith(viewSize))]
}

class Layer(view : LayerView, processor : InputProcessor?) extends Controller {
    static def apply(view : LayerView) : Layer = Layer(view, view.as<InputProcessor>)
    private var _shadowMaps = List<ShadowMap>()
    def drawWith(viewport : Rect) {
        val env = view.environment
        context.environment = env
        context.set(viewport = viewport)
        val camera = view.cameraWith(viewport)
        matrix.value = camera.matrixModel
        camera.focus

        val shadowLights = env.lights.chain.filter(_.hasShadows).toArray
        if(!shadowLights.isEmpty) {
            while(_shadowMaps.count < shadowLights.count) _shadowMaps = List(ShadowMap(), _shadowMaps)
            context.isShadowsDrawing = true
            val i = _shadowMaps.iterator
            shadowLights.for {light ->
                val shadowMap = i.next
                shadowMap.maybe(true) {
                    egClear
                    view.draw
//                    shadowMap.texture.saveTo("$(Directory.sandbox)/dev/test.png")
                }
            }
            context.isShadowsDrawing = false
        }
        view.draw
    }

    def process(event : Event, viewport : Rect) : bool = {
        processor.map{ p ->
            if(p.isProcessorActive) {
                val cam = EventCamera(matrix = view.cameraWith(viewport).matrixModel.wcp, viewport)
                val e = event.set(camera = cam)
                p.process(e)
            } else false
        }.getOr(false)
    }

    def updateWith(delta : float) {
        view.updateWith(delta)
    }

    def viewportWith(viewSize : vec2) = viewportWith(viewSize, viewportLayout = Rect(0, 0, 1, 1))

    def viewportWith(viewSize : vec2, viewportLayout : Rect) : Rect = {
        val layout = viewportLayout
        val vpr = view.camera.viewportRatio

        val size = viewSize*viewportLayout.size
        val vpSize =
        if(size.x == 0 && size.y == 0) vec2(viewSize.x, viewSize.y)
        else if(size.x == 0) vec2(viewSize.x, size.y)
        else if(size.y == 0) vec2(size.x, viewSize.y)
        else if(size.x/size.y < vpr) vec2(size.x, size.x/vpr) else vec2(size.y*vpr, size.y)
        val po = viewportLayout.p0/2 + 0.5
        Rect((viewSize - vpSize) * po, vpSize)
    }
}

trait LayerView extends Controller {
    def camera : Camera = cameraWith(viewport = Rect(-1, -1, 2, 2))

    def cameraWith(viewport : Rect) : Camera = camera

    def draw

    def environment = Environment.default

    def updateWith(delta : float) {}
}
