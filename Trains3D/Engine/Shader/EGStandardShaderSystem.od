import EGShader
import EGMaterial
import EG
import EGTypes
import EGTexture
import EGGL

class EGStandardShaderSystem extends EGShaderSystem<EGStandardMaterial> {
    static val instance = EGStandardShaderSystem()
    def shaderFor(context : EGContext, material : EGStandardMaterial) : EGShader = {
        val lightMap = context.environment.lights.chain.group(_.type).toMap
        val directLights = lightMap[EGDirectLight.type].getOrElse([])
        val key = EGStandardShaderKey(directLights.count, material.diffuse.is<EGColorSourceTexture>)

        shaders.objectFor(key, orUpdateWith = key.shader)
    }

    private static val shaders = CNMutableHashMap<EGStandardShaderKey, EGStandardShader>()
}

class EGStandardShaderKey(directLightCount : uint, texture : bool) {
    def shader : EGStandardShader = {
        val vertexShader =
            "attribute vec3 normal;
             attribute vec2 vertexUV; $when(texture)
             attribute vec3 position;
             uniform mat4 mwcp;
             uniform mat4 m;
             uniform vec3 eyeDirection;
             $lightsVertexUniform

             varying vec2 UV; $when(texture)
             $lightsVaryings

             void main(void) {
                vec3 normalM = normalize((m * vec4(normal, 0)).xyz);
                gl_Position = mwcp * vec4(position, 1);
                UV = vertexUV; $when(texture)
                $lightsCalculateVaryings
             }"
        val fragmentShader =
            "
            $if(texture)
             varying vec2 UV;
             uniform sampler2D diffuse;
            $else
             uniform vec4 diffuse;
            $endif
             uniform vec4 ambientColor;
             uniform vec4 specularColor;
             uniform float specularSize;
             $lightsVaryings
             $lightsFragmentUniform

             void main(void) {
                vec4 materialColor = diffuse; $when(!texture)
                vec4 materialColor = texture2D(diffuse, UV); $when(texture)
                vec4 color = ambientColor * materialColor;
                $lightsDiffuse
                gl_FragColor = color;
             }"
        EGStandardShader(self, EGShaderProgram(vertexShader, fragmentShader))
    }

    def lightsVertexUniform : string = directLightCount.range.chain.map{i -> "uniform vec3 dirLightDirection$i;"}.toStringWith("\n")
    def lightsVaryings : string = directLightCount.range.chain.map{i ->
        "varying float dirLightDirectionCos$i;
         varying float dirLightDirectionCosA$i;"}.toStringWith("\n")
    def lightsCalculateVaryings : string = directLightCount.range.chain.map{i ->
        "dirLightDirectionCos$i = max(dot(normalM, -normalize(dirLightDirection$i)), 0.0);
         dirLightDirectionCosA$i = max(dot(eyeDirection, reflect(normalize(dirLightDirection$i), normalM)), 0.0);
        "
    }.toStringWith("\n")


    def lightsFragmentUniform : string = directLightCount.range.chain.map{i -> "uniform vec4 dirLightColor$i;"}.toStringWith("\n")
    def lightsDiffuse : string =  directLightCount.range.chain.map{i ->
        "color += dirLightDirectionCos$i * (materialColor * dirLightColor$i);
         color += specularColor * dirLightColor$i * pow(dirLightDirectionCosA$i, 5.0/specularSize);
        "
    }.toStringWith("\n")

}

class EGStandardShader(key : EGStandardShaderKey, program : EGShaderProgram) extends EGShader<EGStandardMaterial>(program) {
    static val STRIDE = 8*4
    static val UV_SHIFT = 0
    static val NORMAL_SHIFT = 2*4
    static val POSITION_SHIFT = 5*4

    val positionSlot : EGShaderAttribute = attributeFor("position")
    val normalSlot : EGShaderAttribute? = if(key.directLightCount > 0) attributeFor("normal") else nil
    val uvSlot : EGShaderAttribute? = if(key.texture) attributeFor("vertexUV") else nil

    val ambientColor : EGShaderUniform = uniformFor("ambientColor")
    val specularColor : EGShaderUniform = uniformFor("specularColor")
    val specularSize : EGShaderUniform = uniformFor("specularSize")
    val diffuseUniform : EGShaderUniform = uniformFor("diffuse")
    val mwcpUniform : EGShaderUniform = uniformFor("mwcp")
    val mUniform : EGShaderUniform? = if(key.directLightCount > 0) uniformFor("m") else nil
    val eyeDirectionUniform : EGShaderUniform? = if(key.directLightCount > 0) uniformFor("eyeDirection") else nil

    val directLightDirections : [EGShaderUniform] = key.directLightCount.range.chain.map{i -> uniformFor("dirLightDirection$i")}.toArray
    val directLightColors : [EGShaderUniform] = key.directLightCount.range.chain.map{i -> uniformFor("dirLightColor$i")}.toArray

    def load(context : EGContext, material : EGStandardMaterial) {
        positionSlot.setFromBufferWith(STRIDE, valuesCount = 3, GL_FLOAT, POSITION_SHIFT)
        mwcpUniform.set(matrix = context.matrixStack.value.mwcp)
        if(key.texture) {
            uvSlot.get.setFromBufferWith(STRIDE, valuesCount = 2, GL_FLOAT, UV_SHIFT)
            material.diffuse.cast<EGColorSourceTexture>.texture.bind
        } else {
            diffuseUniform.set(color = material.diffuse.cast<EGColorSourceColor>.color)
        }
        specularColor.set(color = material.specularColor)
        specularSize.set(number = material.specularSize)
        val env = context.environment
        ambientColor.set(color = env.ambientColor)
        if(key.directLightCount > 0) {
            mUniform.get.set(matrix = context.matrixStack.value.m)
            eyeDirectionUniform.get.set(vec3 = context.eyeDirection)
            normalSlot.get.setFromBufferWith(STRIDE, valuesCount = 3, GL_FLOAT, NORMAL_SHIFT)
            env.lights.chain.filterCast(EGDirectLight.type).zip3(directLightDirections, directLightColors){light, dirSlot, colorSlot ->
                dirSlot.set(vec3 = light.direction)
                colorSlot.set(color = light.color)
                light
            }.count
        }
    }
}