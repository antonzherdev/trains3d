package com.antonzherdev.eg

class ShaderProgram(handle : GLuint) {
    static def loadFromFiles(vertex : string, fragment : string) : ShaderProgram =
        ShaderProgram(Bundle.readToString(vertex), Bundle.readToString(fragment))

    static def apply(vertex : string, fragment : string) : ShaderProgram =  {
        val vertexShader = compileShaderFor(GL_VERTEX_SHADER, vertex)
        val fragmentShader = compileShaderFor(GL_FRAGMENT_SHADER, fragment)
        val program = linkFromShaders(vertexShader, fragmentShader)
        glDeleteShader(vertexShader)
        glDeleteShader(fragmentShader)
        program
    }


    static def linkFromShaders(vertex : GLuint, fragment : GLuint) : ShaderProgram = {
        val handle = glCreateProgram
        glAttachShader(handle, vertex)
        glAttachShader(handle, fragment)
        glLinkProgram(handle)
        egGetProgramError(handle).for(throw "Error in shader program linking: " + _)
        ShaderProgram(handle)
    }

    static def compileShaderFor(shaderType : GLenum, source : string) : GLuint = {
        val shader = glCreateShader(shaderType)
        egShaderSource(shader, source)
        glCompileShader(shader)
        egGetShaderError(shader).for(throw  "Error in shader compiling : " + _ + source)
        shader
    }

    def dealoc {
        glDeleteProgram(handle)
    }

    def set {
        glUseProgram(handle)
    }

    def clear {
        glUseProgram(0)
    }

    def apply(draw : () -> void) {
        glUseProgram(handle)
        draw()
        glUseProgram(0)
    }

    def attributeFor(name : string ) : ShaderAttribute = {
        val h = egGetAttribLocation(handle, name)
        if(h < 0) throw "Could not found attribute for name " + name
        val ret = ShaderAttribute(h)
        ret
    }
    def uniformFor(name : string ) : ShaderUniform = {
        val h = egGetUniformLocation(handle, name)
        if(h < 0) throw "Could not found attribute for name " + name
        ShaderUniform(h)
    }
}

class Shader<P>(program : ShaderProgram) {
    def draw(param : P, mesh : Mesh<_>) {
        draw(param, mesh, 0, mesh.indexBuffer.count)
    }

    def draw(param : P, mesh : Mesh<_>, start : uint, count : uint) {
        glUseProgram(program.handle)
        mesh.vertexBuffer {
            load(mesh.vertexBuffer.desc, param)
            mesh.indexBuffer.drawWith(start, count)
            unload(param)
        }
        glUseProgram(0)
    }

    def draw(param : P, vb : VertexBuffer<_>, index : PArray<uint4>, mode : GLenum) {
        glUseProgram(program.handle)
        vb {
            load(vb.desc, param)
            glDrawElements(mode, index.count, GL_UNSIGNED_INT, index.bytes)
            unload(param)
        }
        glUseProgram(0)
    }

    def draw(param : P, vb : VertexBuffer<_>, mode : GLenum) {
        glUseProgram(program.handle)
        vb {
            load(vb.desc, param)
            glDrawArrays(mode, 0, vb.count)
            unload(param)
        }
        glUseProgram(0)
    }

    def load(vbDesc : VertexBufferDesc<_>, param : P)
    def unload(param : P)

    def attributeFor(name : string ) = program.attributeFor(name)
    def uniformFor(name : string ) = program.uniformFor(name)
}

class ShaderAttribute(handle : GLuint) {
    def setFromBufferWith(stride : uint, valuesCount : uint, valuesType : GLenum, shift : uint) {
        glEnableVertexAttribArray(handle)
        egVertexAttribPointer(handle, valuesCount, valuesType, GL_FALSE, stride, shift)
    }

    def unbind {
        glDisableVertexAttribArray(handle)
    }
}

class ShaderUniform(handle : GLuint) {
    def set(matrix : mat4) {
        glUniformMatrix4fv(handle, 1, GL_FALSE, matrix.array)
    }
    def set(vec4 : vec4) {
        egUniformVec4(handle, vec4)
    }
    def set(vec3 : vec3) {
        egUniformVec3(handle, vec3)
    }
    def set(f4 : float4) {
        glUniform1f(handle, f4)
    }
}

class ShaderSystem<M extends Material> {
    def draw(material : M, mesh : Mesh<_>) {
        val shader = shaderFor(material)
        shader.draw(material, mesh)
    }

    def draw(material : M, vb : VertexBuffer<_>, index : PArray<uint4>, mode : GLenum) {
        val shader = shaderFor(material)
        shader.draw(material, vb = vb, index, mode)
    }

    def draw(material : M, vb : VertexBuffer<_>, mode : GLenum) {
        val shader = shaderFor(material)
        shader.draw(material, vb = vb, mode)
    }

    def shaderFor(material : M) : Shader
}


