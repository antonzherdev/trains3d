package com.antonzherdev.eg



class StandardShaderSystem extends ShaderSystem<StandardMaterial> {
    static val instance = StandardShaderSystem()
    def shaderFor(param : StandardMaterial) : Shader<Material> =
        if(context.renderTarget.is<ShadowRenderTarget>)
            if(ShadowShaderSystem.isColorShaderFor(param.diffuse)) StandardShadowShader.instanceForColor
            else StandardShadowShader.instanceForTexture
        else {
            val lights = context.environment.lights
            val directLightsWithShadowsCount = lights.chain.filter(_.is<DirectLight> && _.hasShadows).count
            val directLightsWithoutShadowsCount = lights.chain.filter(_.is<DirectLight> && !_.hasShadows).count
            val key =
                if(egPlatform.shadows && context.considerShadows)
                    StandardShaderKey(directLightsWithShadowsCount, directLightsWithoutShadowsCount, param.diffuse.texture.isDefined)
                else StandardShaderKey(0, directLightsWithShadowsCount + directLightsWithoutShadowsCount, param.diffuse.texture.isDefined)

            shaders.objectFor(key, orUpdateWith = key.shader)
        }

    private static val shaders = MutableHashMap<StandardShaderKey, StandardShader>()
}

class StandardShadowShader(shadowShader : ShadowShader) extends Shader<StandardMaterial>(shadowShader.program) {
    static val instanceForColor = StandardShadowShader(ShadowShader.instanceForColor)
    static val instanceForTexture = StandardShadowShader(ShadowShader.instanceForTexture)

    def load(vbDesc : VertexBufferDesc<_>, param : StandardMaterial) {
        shadowShader.load(vbDesc, param.diffuse)
    }
}

class StandardShaderKey(directLightWithShadowsCount : uint, directLightWithoutShadowsCount : uint, texture : bool) extends ShaderTextBuilder {
    val directLightCount = directLightWithShadowsCount + directLightWithoutShadowsCount
    def shader : StandardShader = {
        val vertexShader =
            "$vertexHeader
             $ain mediump vec3 normal;

             $ain highp vec3 position;
             uniform mat4 mwcp;
             uniform mat4 mwc;
             $lightsVertexUniform

            $if(texture)
             $ain mediump vec2 vertexUV;
             $out mediump vec2 UV;
            $endif
             $lightsOut

             void main(void) {
                vec3 normalMWC = normalize((mwc * vec4(normal, 0)).xyz);
                vec3 eyeDirection = normalize(-(mwc * vec4(position, 1)).xyz);
                gl_Position = mwcp * vec4(position, 1);
                UV = vertexUV; $when(texture)
                $lightsCalculateVaryings
             }"
        val fragmentShader =
            "$fragmentHeader
            $if(texture)
             $in mediump vec2 UV;
             uniform lowp sampler2D diffuseTexture;
            $endif
             uniform lowp vec4 diffuseColor;
             uniform lowp vec4 ambientColor;
             uniform lowp vec4 specularColor;
             uniform lowp float specularSize;
             $lightsIn
             $lightsFragmentUniform

             void main(void) {
                mediump float visibility;$when(directLightWithShadowsCount > 0)
               $if(texture)
                lowp vec4 materialColor = diffuseColor * $texture2D\(diffuseTexture, UV);
               $else
                lowp vec4 materialColor = diffuseColor;
               $endif
                lowp vec4 color = ambientColor * materialColor;
                $lightsDiffuse
                $fragColor = color;
             }"
        StandardShader(self, ShaderProgram(vertexShader, fragmentShader))
    }

    def lightsVertexUniform : string = directLightCount.range.chain.map{i ->
        "uniform mediump vec3 dirLightDirection$i;
        $if(i < directLightWithShadowsCount)
         uniform mat4 dirLightDepthMwcp$i;
        $endif
        "}.toStringWith("\n")
    def lightsIn : string = directLightCount.range.chain.map{i ->
        "$in mediump float dirLightDirectionCos$i;
         $in mediump float dirLightDirectionCosA$i;
        $if(i < directLightWithShadowsCount)
         $in mediump vec3 dirLightShadowCoord$i;
        $endif
        "}.toStringWith("\n")
    def lightsOut : string = directLightCount.range.chain.map{i ->
        "$out mediump float dirLightDirectionCos$i;
         $out mediump float dirLightDirectionCosA$i;
        $if(i < directLightWithShadowsCount)
         $out mediump vec3 dirLightShadowCoord$i;
        $endif
        "}.toStringWith("\n")
    def lightsCalculateVaryings : string = directLightCount.range.chain.map{i ->
        "dirLightDirectionCos$i = max(dot(normalMWC, -dirLightDirection$i), 0.0);
         dirLightDirectionCosA$i = max(dot(eyeDirection, reflect(dirLightDirection$i, normalMWC)), 0.0);
        $if(i < directLightWithShadowsCount)
         dirLightShadowCoord$i = (dirLightDepthMwcp$i * vec4(position, 1)).xyz;
        $endif
        "
    }.toStringWith("\n")


    def lightsFragmentUniform : string = directLightCount.range.chain.map{i ->
        "uniform lowp vec4 dirLightColor$i;
        $if(i < directLightWithShadowsCount)
         uniform mediump sampler2DShadow dirLightShadow$i;
        $endif"}.toStringWith("\n")
    def lightsDiffuse : string =  directLightCount.range.chain.map{i ->
        "
        $if(i < directLightWithShadowsCount)
         visibility = texture(dirLightShadow$i, vec3(dirLightShadowCoord$i.xy, dirLightShadowCoord$i.z - 0.005));
         color += visibility * dirLightDirectionCos$i * (materialColor * dirLightColor$i);
         color += visibility * specularColor * dirLightColor$i * pow(dirLightDirectionCosA$i, 5.0/specularSize);
        $else
         color += dirLightDirectionCos$i * (materialColor * dirLightColor$i);
         color += specularColor * dirLightColor$i * pow(dirLightDirectionCosA$i, 5.0/specularSize);
        $endif
        "
    }.toStringWith("\n")

}

class StandardShader(key : StandardShaderKey, program : ShaderProgram) extends Shader<StandardMaterial>(program) {
    val positionSlot : ShaderAttribute = attributeFor("position")
    val normalSlot : ShaderAttribute? = if(key.directLightCount > 0) attributeFor("normal") else nil
    val uvSlot : ShaderAttribute? = if(key.texture) attributeFor("vertexUV") else nil

    val diffuseTexture : ShaderUniformI4? = if(key.texture) uniformI4("diffuseTexture") else nil
    val ambientColor = uniformVec4("ambientColor")
    val specularColor = uniformVec4("specularColor")
    val specularSize = uniformF4("specularSize")
    val diffuseColorUniform = uniformVec4("diffuseColor")
    val mwcpUniform = uniformMat4("mwcp")
    val mwcUniform : ShaderUniformMat4? = if(key.directLightCount > 0) uniformMat4("mwc") else nil

    val directLightDirections : [ShaderUniformVec3] = key.directLightCount.range.chain.map{i -> uniformVec3("dirLightDirection$i")}.toArray
    val directLightColors : [ShaderUniformVec4] = key.directLightCount.range.chain.map{i -> uniformVec4("dirLightColor$i")}.toArray
    val directLightShadows : [ShaderUniformI4] = key.directLightWithShadowsCount.range.chain.map{i -> uniformI4("dirLightShadow$i")}.toArray
    val directLightDepthMwcp : [ShaderUniformMat4] = key.directLightWithShadowsCount.range.chain.map{i -> uniformMat4("dirLightDepthMwcp$i")}.toArray

    def load(vbDesc :VertexBufferDesc<_>, param : StandardMaterial) {
        positionSlot.setFromBufferWith(vbDesc.stride, valuesCount = 3, GL_FLOAT, vbDesc.position)
        mwcpUniform(matrix = matrix.value.mwcp)
        if(key.texture) {
            uvSlot.get.setFromBufferWith(vbDesc.stride, valuesCount = 2, GL_FLOAT, vbDesc.uv)
            param.diffuse.texture.get.bind
            diffuseTexture.get.apply(i4 = 0)
        }
        diffuseColorUniform(vec4 = param.diffuse.color)
        specularColor(vec4 = param.specularColor)
        specularSize(f4 = param.specularSize)
        val env = context.environment
        ambientColor(vec4 = env.ambientColor)
        if(key.directLightCount > 0) {
            mwcUniform.get(matrix = context.matrixStack.value.mwc)
            normalSlot.get.setFromBufferWith(vbDesc.stride, valuesCount = 3, GL_FLOAT, vbDesc.normal)
            var i : uint = 0
            if(key.directLightWithShadowsCount > 0) {
                env.lights.chain.filter(_.is<DirectLight> && _.hasShadows).for { light ->
                    val dir = matrix.value.wc.mul(vec3 = light.cast<DirectLight>.direction, 0).xyz
                    directLightDirections[i].apply(vec3 = dir.normalize)
                    directLightColors[i].apply(vec4 = light.color)
                    directLightDepthMwcp[i].apply(matrix = light.shadowMap.biasDepthCp * matrix.mw)
                    directLightShadows[i].apply(i4 = i + 1)
                    glActiveTexture(GL_TEXTURE0 + i + 1)
                    light.shadowMap.texture.bind
                    glActiveTexture(GL_TEXTURE0)
                    i++
                }
            }
            if(key.directLightWithoutShadowsCount > 0) {
                env.lights.chain.filter(_.is<DirectLight> && (!_.hasShadows || !context.considerShadows)).for { light ->
                    val dir = matrix.value.wc.mul(vec3 = light.cast<DirectLight>.direction, 0).xyz
                    directLightDirections[i].apply(vec3 = dir.normalize)
                    directLightColors[i].apply(vec4 = light.color)
                }
            }
        }
    }
}