package com.antonzherdev.eg

struct MeshData(uv : vec2, normal : vec3, position : vec3) {
    def mul(mat4 : mat4) : MeshData =
        MeshData(uv, (mat4 * vec4(normal, 0)).xyz, (mat4 * vec4(position, 1)).xyz)

    def uvAdd(vec2 : vec2) = MeshData(uv + vec2, normal, position)
}

class MeshDataModel(vertex : PArray<MeshData>, index : PArray<uint4>)

class Mesh(vertex : VertexBuffer<_>, index : IndexSource) {
    static def vec2(vertexData : PArray<vec2>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO.vec2(vertexData),
            index = IBO(indexData))

    static def apply(vertexData : PArray<MeshData>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO.mesh(vertexData),
            index = IBO(indexData))

    static def apply<T>(desc : VertexBufferDesc<T>, vertexData : PArray<T>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO<T>(desc, vertexData),
            index = IBO(indexData))

    def vao<N>(shader : Shader<N>) : VertexArray<N> = shader.vao(vertex, index.cast<IndexBuffer>)
    def vaoShadow : VertexArray<ColorSource> = vao(ShadowShaderSystem.instance, ColorSource(vec4(1, 1, 1, 1)), false)
    def vaoShadow(material : ColorSource) : VertexArray<ColorSource> = vao(ShadowShaderSystem.instance, material, false)
    def vao<N extends Material>(material : N, shadow : bool) : VertexArray<N> = {
        val std = MaterialVertexArray(material.shader.vao(vertex, index.cast<IndexBuffer>), material)
        if(shadow && egPlatform.shadows) RouteVertexArray(std,
            MaterialVertexArray(material.shaderSystem.shaderFor(material,
                ShadowRenderTarget.default).vao(vertex, index.cast<IndexBuffer>), material))
        else std
    }
    def vao<N>(shaderSystem : ShaderSystem<N>, material : N, shadow : bool) : VertexArray<N> = {
        val std = MaterialVertexArray(shaderSystem.shaderFor(material).vao(vertex, index.cast<IndexBuffer>), material)
        if(shadow && egPlatform.shadows) RouteVertexArray(std,
            MaterialVertexArray(shaderSystem.shaderFor(material,
                ShadowRenderTarget.default).vao(vertex, index.cast<IndexBuffer>), material))
        else std
    }

    def draw(material : Material) {
        material.draw(self)
    }
}

class MeshModel(arrays : [VertexArray<Material>]) {
    static def apply(meshes : [(Mesh, Material)]) : MeshModel = MeshModel(false, meshes)
    static def apply(shadow : bool, meshes : [(Mesh, Material)]) : MeshModel = MeshModel(arrays = meshes.chain.map{p ->
        p.a.vao(p.b, shadow)
    }.toArray)
    def draw {
        arrays.for(_.draw)
    }

    def draw(only : uint4) {
        if(only == 0) return nil
        var o =  only
        arrays.go {a ->
            a.draw
            o--
            o > 0
        }
    }
}



class MeshUnite(vertexSample : PArray<MeshData>, indexSample : PArray<uint4>, createVao : Mesh -> VertexArray<_>) {
    static def apply(meshModel : MeshDataModel, createVao : Mesh -> VertexArray<_>) : MeshUnite =
        MeshUnite(meshModel.vertex, meshModel.index, createVao)

    private val vbo = VBO.mutMesh
    private val ibo = IBO.mut
    val mesh = Mesh(vbo, ibo)
    val vao = createVao(mesh)
    private var _count :  uint4 = 0

    def write(count : uint4, f : MeshWriter -> void) {
        val w = writer(count)
        f(w)
        w.flush
    }

    def write(mat4Array : Iterable<mat4>) {
        val w = writer(mat4Array.count)
        mat4Array.for(w.write(_))
        w.flush
    }

    def writer(count : uint4) = {
        _count = count
        MeshWriter(vbo, ibo, count, vertexSample, indexSample)
    }

    def draw {
        if(_count > 0) {
            matrix.identity{
                vao.draw
            }
        }
    }
}

class MeshWriter(vbo : MutableVertexBuffer<MeshData>, ibo : MutableIndexBuffer,
    count : uint4, vertexSample : PArray<MeshData>, indexSample : PArray<uint4>)
{
    private val vertex = VoidRefArray(MeshData.type, vertexSample.count * count)
    private val index = VoidRefArray(UInt4.type, indexSample.count * count)
    private var _vp = vertex
    private var _ip = index
    private var _indexShift : uint4 = 0
    def write(mat4 : mat4) {
        write(vertexSample, indexSample, mat4)
    }

    def write(vertex : PArray<MeshData>, mat4 : mat4) {
        write(vertex, indexSample, mat4)
    }

    def write(vertex : PArray<MeshData>, index : PArray<uint4>, mat4 : mat4) {
        vertex.forRef{ r ->
            _vp = _vp.write(MeshData, r.get<MeshData> * mat4)
        }
        index.forRef {r ->
            _ip = _ip.write(uInt4 = r.get<uint4> + _indexShift)
        }
        _indexShift += vertex.count
    }

    def write(map : MeshData -> MeshData) {
        write(vertexSample, indexSample, map)
    }

    def write(vertex : PArray<MeshData>, map : MeshData -> MeshData) {
        write(vertex, indexSample, map)
    }

    def write(vertex : PArray<MeshData>, index : PArray<uint4>, map : MeshData -> MeshData) {
        vertex.forRef{ r ->
            _vp = _vp.write(MeshData, map(r.get<MeshData>))
        }
        index.forRef {r ->
            _ip = _ip.write(uInt4 = r.get<uint4> + _indexShift)
        }
        _indexShift += vertex.count
    }

    def flush {
        vbo.set(vertex)
        ibo.set(index)
    }

    override def dealloc {
        vertex.free
        index.free
    }
}

