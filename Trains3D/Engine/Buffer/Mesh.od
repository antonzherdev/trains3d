package com.antonzherdev.eg

struct MeshData(uv : vec2, normal : vec3, position : vec3)

class Mesh(vertex : VertexBuffer<_>, index : IndexSource) {
    static def vec2(vertexData : PArray<vec2>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO.vec2(vertexData),
            index = IBO(indexData))

    static def apply(vertexData : PArray<MeshData>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO.mesh(vertexData),
            index = IBO(indexData))

    static def apply<T>(desc : VertexBufferDesc<T>, vertexData : PArray<T>, indexData : PArray<uint4>) : Mesh = Mesh(
            vertex = VBO<T>(desc, vertexData),
            index = IBO(indexData))

    def vao<N>(shader : Shader<N>) : VertexArray<N> = shader.vao(vertex, index)
    def vaoShadow : VertexArray<ColorSource> = vao(ShadowShaderSystem.instance, ColorSource(vec4(1, 1, 1, 1)), false)
    def vaoShadow(material : ColorSource) : VertexArray<ColorSource> = vao(ShadowShaderSystem.instance, material, false)
    def vao<N extends Material>(material : N, shadow : bool) : VertexArray<N> = {
        val std = MaterialVertexArray(material.shader.vao(vertex, index), material)
        if(shadow && egPlatform.shadows) RouteVertexArray(std,
            MaterialVertexArray(material.shaderSystem.shaderFor(material, ShadowRenderTarget.default).vao(vertex, index), material))
        else std
    }
    def vao<N>(shaderSystem : ShaderSystem<N>, material : N, shadow : bool) : VertexArray<N> = {
        val std = MaterialVertexArray(shaderSystem.shaderFor(material).vao(vertex, index), material)
        if(shadow && egPlatform.shadows) RouteVertexArray(std,
            MaterialVertexArray(shaderSystem.shaderFor(material, ShadowRenderTarget.default).vao(vertex, index), material))
        else std
    }

    def draw(material : Material) {
        material.draw(self)
    }
}

class MeshModel(arrays : [VertexArray<Material>]) {
    static def apply(meshes : [(Mesh, Material)]) : MeshModel = MeshModel(false, meshes)
    static def apply(shadow : bool, meshes : [(Mesh, Material)]) : MeshModel = MeshModel(arrays = meshes.chain.map{p ->
        p.a.vao(p.b, shadow)
    }.toArray)
    def draw {
        arrays.for(_.draw)
    }
}


class VertexArray<P> {
    def draw(param : P)

    def draw
}

class RouteVertexArray<P>(standard : VertexArray<P>, shadow : VertexArray<P>) extends VertexArray<P> {
    def mesh : VertexArray<P> =
        if(context.renderTarget.is<ShadowRenderTarget>) shadow
        else standard

    def draw(param : P) {
        mesh.draw(param)
    }

    def draw {
        mesh.draw
    }
}


class SimpleVertexArray<P>(handle : GLuint, shader : Shader<P>, buffers : [VertexBuffer<_>], index : IndexSource) extends VertexArray<P> {
    static def apply<P>(shader : Shader<P>, buffers : [VertexBuffer<_>], index : IndexSource) : SimpleVertexArray<P> =
        SimpleVertexArray<P>(egGenVertexArray, shader, buffers, index)

    def bind {
        context.bindVertexArray(handle, buffers.head.count)
    }

    def unbind {
        context.bindDefaultVertexArray
    }

    def dealloc {
        egDeleteVertexArray(handle)
    }

    def count = buffers.head.count

    def draw(param : P) {
        shader.draw(param, self)
    }

    def draw {
        throw "No default material"
    }
}

class MaterialVertexArray<P>(vao : VertexArray<P>, material : P) extends VertexArray<P>
{
    def draw {
        vao.draw(material)
    }

    def draw(param : P) {
        vao.draw(param)
    }
}
