package com.antonzherdev.eg

abstract class Buffer<T>(dataType : PType<T>, bufferType : uint4, handle : uint4) {
    def length : uint
    def count : uint

    override def dealloc {
        context.deleteBuffer(handle)
    }

    def bind {
        glBindBuffer(bufferType, handle)
    }

    def stride : uint4 = dataType.size
}


abstract class MutableBuffer<T>(dataType : PType<T>, bufferType : uint4, handle : uint4) extends Buffer<T>(dataType, bufferType, handle) {
    private var _length : uint = 0
    private var _count : uint = 0
    override def length : uint = _length
    override def count : uint = _count
    def isEmpty = _count > 0
    private val usage : uint4 = GL_DYNAMIC_DRAW

    def set(data : PArray<T>) : self = {
        bind
        glBufferData(bufferType, data.length, data.bytes, usage)
        _length = data.length
        _count = data.count
        self
    }


    def set(array : Pointer<T>, count : uint4) : self = {
        bind
        _length = count * dataType.size
        glBufferData(bufferType, _length, array, usage)
        _count = count
        self
    }

    def write(count : uint4, f : Pointer<T> -> void) {
        map(count, GL_WRITE_ONLY, f)
    }


    def map(count : uint4, access : uint4, f : Pointer<T> -> void) {
        bind
        _count = count
        _length = count * dataType.size
        glBufferData(bufferType, _length, Pointer.null<T>, usage)
        f(egMapBuffer<T>(bufferType, access))
        egUnmapBuffer(bufferType)
//        glMap
    }

    def beginWrite(count : uint4) : Pointer<T> = {
        map(count, GL_WRITE_ONLY)
    }
    def map(count : uint4, access : uint4) : Pointer<T> = {
        bind
        _count = count
        _length = count * dataType.size
        glBufferData(bufferType, _length, Pointer.null<T>, usage)
        egMapBuffer<T>(bufferType, access)
    }

    def unmap {
        bind
        egUnmapBuffer(bufferType)
    }

    def endWrite {
        bind
        egUnmapBuffer(bufferType)
    }
}

class BufferRing<T, B extends MutableBuffer<T>>(ringSize : uint4, creator : () -> B) {
    private val _ring = MQueue<B>()

    def next : B = {
        val buffer = if(_ring.count >= ringSize) _ring.dequeue.get else creator()
        _ring.enqueue(buffer)
        buffer
    }

    def write(count : uint4, f : Pointer<T> -> void) {
        next.write(count, f)
    }

    def map(count : uint4, access : uint4, f : Pointer<T> -> void) {
        next.map(count, access, f)
    }
}