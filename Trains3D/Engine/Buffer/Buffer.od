package com.antonzherdev.eg

class Buffer<T>(dataType : PType<T>, bufferType : uint4, handle : uint4) {
    def length : uint
    def count : uint
    static def apply<T>(dataType : PType<T>, bufferType : uint4) : Buffer = Buffer<T>(dataType, bufferType, egGenBuffer)

    override def dealloc {
        context.deleteBuffer(handle)
    }

    def bind {
        glBindBuffer(bufferType, handle)
    }

    def stride : uint4 = dataType.size
}


class MutableBuffer<T>(dataType : PType<T>, bufferType : uint4, handle : uint4) extends Buffer<T>(dataType, bufferType, handle) {
    private var _length : uint = 0
    private var _count : uint = 0
    override def length : uint = _length
    override def count : uint = _count
    def isEmpty = _count > 0
    private val usage : uint4 = GL_DYNAMIC_DRAW

    def set(data : PArray<T>) : self = {
        bind
        glBufferData(bufferType, data.length, data.bytes, usage)
        _length = data.length
        _count = data.count
        self
    }

    def set(array : VoidRefArray<T>) : self = {
        bind
        glBufferData(bufferType, array.length, array.bytes, usage)
        _length = array.length
        _count = array.length/dataType.size
        self
    }

    def set(array : VoidRefArray<T>, count : uint4) : self = {
        bind
        _length = count * dataType.size
        glBufferData(bufferType, _length, array.bytes, usage)
        _count = count
        self
    }

    def update(start : uint, count : uint, array : VoidRefArray) : self = {
        bind
        glBufferSubData(bufferType, start*dataType.size, count*dataType.size, array.bytes)
        self
    }

    def write(count : uint4, f : VoidRefArray -> void) {
        map(count, GL_WRITE_ONLY, f)
    }


    def map(count : uint4, access : uint4, f : VoidRefArray -> void) {
        bind
        _count = count
        _length = count * dataType.size
        glBufferData(bufferType, _length, nil, usage)
        val ref = egMapBuffer(bufferType, access)
        f(VoidRefArray(_length, ref))
        egUnmapBuffer(bufferType)
//        glMap
    }

    private var _mapRef : VoidRefArray
    def beginWrite(count : uint4) : VoidRefArray = {
        map(count, GL_WRITE_ONLY)
    }
    def map(count : uint4, access : uint4) : VoidRefArray = {
        bind
        _count = count
        _length = count * dataType.size
        glBufferData(bufferType, _length, nil, usage)
        VoidRefArray(_length, egMapBuffer(bufferType, access))
    }

    def unmap {
        bind
        egUnmapBuffer(bufferType)
    }

    def endWrite {
        bind
        egUnmapBuffer(bufferType)
    }
}

class BufferRing<T, B extends MutableBuffer<T>>(ringSize : uint4, creator : () -> B) {
    private val _ring = MQueue<B>()

    def next : B = {
        val buffer = if(_ring.count >= ringSize) _ring.dequeue?! else creator()
        _ring.enqueue(buffer)
        buffer
    }

    def write(count : uint4, f : VoidRefArray<T> -> void) {
        next.write(count, f)
    }

    def map(count : uint4, access : uint4, f : VoidRefArray<T> -> void) {
        next.map(count, access, f)
    }
}