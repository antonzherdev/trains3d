package com.antonzherdev.eg

class Collision<T>(bodies : Pair<CollisionBody<T>>, contacts : [Contact])
class DynamicCollision<T>(bodies : Pair<RigidBody<T>>, contacts : [Contact]) {
    def impulse : float4 = contacts.chain.map(_.impulse).max.get
}
class CrossPoint<T>(body : CollisionBody<T>, point : vec3)
class Contact(a : vec3, b : vec3, distance : float4, impulse : float4, lifeTime : uint4)

class IndexFunFilteredIterable<T>(maxCount : uint, f : uint -> T?) extends ImIterable<T> {
    def iterator : Iterator<T> = IndexFunFilteredIterator<T>(maxCount, f)
}

class IndexFunFilteredIterator<T>(maxCount : uint, f : uint -> T?) extends Iterator<T> {
    private var i : uint = 0
    private var _next : T? = roll

    def hasNext = _next.isDefined

    def next : T = {
        val ret = _next.get
        _next = roll
        ret
    }

    private def roll : T? = {
        var ret : T? = nil
        while(ret.isEmpty && i < maxCount ) {
            ret = f(i)
            i++
        }
        ret
    }
}

trait PhysicsBody<T> {
    def data : T
    def shape : CollisionShape
    def isKinematic : bool
}

class PhysicsWorld<T> {
    private val _bodiesMap = MHashMap<T, PhysicsBody<T>>()
    private val _bodies = MArray<PhysicsBody<T>>()

    def add(body : PhysicsBody<T>) {
        _bodies.append(body)
        val data =  body.data
        if(data != nil) _bodiesMap.set(key = body.data, value = body)
    }
    def remove(body : PhysicsBody<T>) : bool = {
        val data =  body.data
        if(data != nil) _bodiesMap.removeFor(key = body.data)
        _bodies.remove(body)
    }
    def remove(item : T) : bool = {
        val body = _bodiesMap.take(key = item)
        if(body.isDefined) {
            remove(body = body.get)
        } else false
    }

    def bodyFor(item : T) : CollisionBody<T>? = _bodiesMap.opt(item)
    def clear {
        _bodiesMap.clear
        _bodies.clear
    }

    def bodies : Iterable<PhysicsBody<T>> = _bodies
}