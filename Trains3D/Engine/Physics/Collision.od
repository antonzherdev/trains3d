package com.antonzherdev.eg

class Collision<T>(bodies : Pair<CollisionBody<T>>, contacts : [Contact])
class DynamicCollision<T>(bodies : Pair<RigidBody<T>>, contacts : [Contact]) {
    def impulse : float4 = contacts.chain.map(_.impulse).max.get
}
class CrossPoint<T>(body : CollisionBody<T>, point : vec3)
class Contact(a : vec3, b : vec3, distance : float4, impulse : float4, lifeTime : uint4)

class IndexFunFilteredIterable<T>(maxCount : uint, f : uint -> T?) extends Iterable<T> {
    def iterator : Iterator<T> = IndexFunFilteredIterator<T>(maxCount, f)
}

class IndexFunFilteredIterator<T>(maxCount : uint, f : uint -> T?) extends Iterator<T> {
    private var i : uint = 0
    private var _next : T? = roll

    def hasNext = _next.isDefined

    def next : T = {
        val ret = _next.get
        _next = roll
        ret
    }

    private def roll : T? = {
        var ret : T? = nil
        while(ret.isEmpty && i < maxCount ) {
            ret = f(i)
            i++
        }
        ret
    }
}

trait PhysicsBody<T> {
    def data : T
    def shape : CollisionShape
    def isKinematic : bool
}

class PhysicsWorld<T> {
    private val _bodiesMap = MutableHashMap<T, PhysicsBody<T>>()

    def add(body : PhysicsBody<T>) {
        _bodiesMap.set(key = body.data, value = body)
    }
    def remove(body : PhysicsBody<T>) {
        _bodiesMap.removeFor(key = body.data)
    }
    def remove(item : T) {
        _bodiesMap.take(key = item).for{body ->
        remove(body = body)
        }
    }
    def bodyFor(item : T) : CollisionBody<T>? = _bodiesMap.opt(item)
    def clear {
        _bodiesMap.clear
    }

    def bodies : Iterable<PhysicsBody<T>> = _bodiesMap.values
}