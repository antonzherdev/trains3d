package com.antonzherdev.eg

case class Collision<T>(bodies : Pair<CollisionBody<T>>, contacts : Iterable<Contact>)
case class DynamicCollision<T>(bodies : Pair<RigidBody<T>>, contacts : Iterable<Contact>) {
    def impulse : float4 = contacts.chain.map(_.impulse).max?:0.0
}
case class CrossPoint<T>(body : CollisionBody<T>, point : vec3)
case class Contact(a : vec3, b : vec3, distance : float4, impulse : float4, lifeTime : uint4)

class IndexFunFilteredIterable<T>(maxCount : uint, f : uint -> T?) extends ImIterable<T> {
    override def iterator : Iterator<T> = IndexFunFilteredIterator<T>(maxCount, f)
}

class IndexFunFilteredIterator<T>(maxCount : uint, f : uint -> T?) extends Iterator<T> {
    private var i : uint = 0
    private var _next : T? = roll

    override def hasNext = _next != nil

    override def next : T = {
        val ret = _next?!
        _next = roll
        ret
    }

    private def roll : T? = {
        var ret : T? = nil
        while(ret == nil && i < maxCount ) {
            ret = f(i)
            i++
        }
        ret
    }
}

trait PhysicsBody<T> {
    def data : T
    def shape : CollisionShape
    def isKinematic : bool
    def matrix : mat4
    def set(matrix : mat4)
}

class PhysicsWorld<T> {
    private val _bodiesMap = MHashMap<T, PhysicsBody<T>>()
    private var _bodies : [PhysicsBody<T>] = []

    def add(body : PhysicsBody<T>) {
        _bodies += body
        val data = body.data
        if(data != nil) _bodiesMap.set(key = body.data, value = body)
        _add(body)
    }

    def _add(body : PhysicsBody<T>)

    def remove(body : PhysicsBody<T>) {
        _remove(body)
        val data = body.data
        if(data != nil) _bodiesMap.removeFor(key = body.data)
        val bs = _bodies
        _bodies = bs - body
    }
    def remove(item : T) : bool = {
        _bodiesMap.take(key = item) ?> { body ->
            remove(body)
            true
        } ?: false
    }
    def _remove(body : PhysicsBody<T>)

    def bodyFor(item : T) : PhysicsBody<T>? = _bodiesMap.opt(item)
    def clear {
        _bodies.for{body -> _remove(body)}
        _bodies = []
        _bodiesMap.clear
    }

    def bodies : Iterable<PhysicsBody<T>> = _bodies
}