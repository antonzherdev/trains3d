import CNChain
import CNRange
import CNData

import EGTypes
import EG
import EGGL
import EGMap
import EGModel
import EGStandardShader
import EGBuffer
import EGShader
import EGContext

class EGMapSso(size : EGSizeI) {
    static val ISO = 0.70710676908493

    val limits = EGRectI.newXY((1 - size.height)/2 - 1,
                         (2*size.width + size.height - 3)/2 + 1,
                         (1 - size.width)/2 - 1,
                         (size.width + 2*size.height - 3)/2 + 1)
    val fullTiles : [EGPointI] = allPosibleTiles.filter(isFull(_)).toArray
    val partialTiles : [EGPointI] = allPosibleTiles.filter(isPartial(_)).toArray
    val allTiles : [EGPointI] = fullTiles + partialTiles

    def isFull(tile : EGPointI) : bool =
        tile.y + tile.x >= 0 //left
        && tile.y - tile.x <= size.height - 1 //top
        && tile.y + tile.x <= size.width + size.height - 2 //right
        && tile.y - tile.x >= -size.width + 1

    def isPartial(tile : EGPointI) : bool =
        tile.y + tile.x >= -1 //left
        && tile.y - tile.x <= size.height //top
        && tile.y + tile.x <= size.width + size.height - 1 //right
        && tile.y - tile.x >= -size.width && (
            tile.y + tile.x == -1 //left
            || tile.y - tile.x == size.height //top
            || tile.y + tile.x == size.width + size.height - 1 //right
            || tile.y - tile.x == -size.width //bottom
        )

    private def allPosibleTiles : CNChain<EGPointI> =
        CNRange(start = limits.x, end = limits.x2, step = 1).chain
            .mul<int>(CNRange(start = limits.y, end = limits.y2, step = 1))
            .map(EGPointI(_.a, _.b))

    private def tileCutAxis(less : int, more : int) : int =
        if(less == more) 1
        else if(less < more) 0
        else 2

    def cutRectFor(tile : EGPointI) = EGRectI.newXY(
        tileCutAxis(0, tile.x + tile.y),
        tileCutAxis(tile.x + tile.y, size.width + size.height - 2),
        tileCutAxis(tile.y - tile.x, size.height - 1),
        tileCutAxis(-size.width + 1, tile.y - tile.x))
}

class EGMapSsoView(map : EGMapSso) {
    def drawLayout {
        glPushMatrix
        egRotate(45, 0, 0, 1)
        glBegin(GL_LINES)
        {
            val ISO = EGMapSso.ISO
            val size = map.size
            val left = -ISO
            val top = ISO*size.height
            val bottom = ISO*(-size.width)
            val right = ISO*(size.width + size.height - 1)
            egNormal3(0, 0, 1)
            egVertex3(left, top, 0.0)
            egVertex3(left, bottom, 0.0)

            egVertex3(left, bottom, 0.0)
            egVertex3(right, bottom, 0.0)

            egVertex3(right, bottom, 0.0)
            egVertex3(right, top, 0.0)

            egVertex3(right, top, 0.0)
            egVertex3(left, top, 0.0)
        }
        glEnd
        glPopMatrix

        egColor3(1.0, 1.0, 1.0)
        glBegin(GL_LINES)
        {
            map.fullTiles.for(tile -> {
                val p = tile
                egNormal3(0, 0, 1)
                egVertex3(p.x - 0.5, p.y - 0.5, 0.0)
                egVertex3(p.x + 0.5, p.y - 0.5, 0.0)

                egVertex3(p.x + 0.5, p.y - 0.5, 0.0)
                egVertex3(p.x + 0.5, p.y + 0.5, 0.0)

                egVertex3(p.x + 0.5, p.y + 0.5, 0.0)
                egVertex3(p.x - 0.5, p.y + 0.5, 0.0)

                egVertex3(p.x - 0.5, p.y + 0.5, 0.0)
                egVertex3(p.x - 0.5, p.y - 0.5, 0.0)
            })
        }
        glEnd
        egMapDrawAxis
    }


    val plane : EGMesh = createPlane
    def createPlane : EGMesh = {
        val limits = map.limits
        val l = limits.x - 1.5
        val r = limits.x2 + 1.5
        val t = limits.y - 1.5
        val b = limits.y2 + 1.5
        val w = limits.width + 3
        val h = limits.height + 3
        EGMesh([
            0, 0, 0, 0, 1, l, b, 0,
            w, 0, 0, 0, 1, r, b, 0,
            w, h, 0, 0, 1, r, t, 0,
            0, h, 0, 0, 1, l, t, 0
        ], [0, 1, 2,
            2, 3, 0])
    }

    def drawPlane {
        plane.draw
    }
}
