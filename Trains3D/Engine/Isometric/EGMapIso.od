import EGTypes
import EGGL
import EGMap
import CNChain
import CNRange

class EGMapSso(size : EGSizeI) {
    val limits = EGRectI.newXY((1 - size.height)/2 - 1,
                         (2*size.width + size.height - 3)/2 + 1,
                         (1 - size.width)/2 - 1,
                         (size.width + 2*size.height - 3)/2 + 1)
    val fullTiles : [EGPointI] = allPosibleTiles.filter(isFull(_)).toArray
    val partialTiles : [EGPointI] = allPosibleTiles.filter(isPartial(_)).toArray
    val allTiles : [EGPointI] = fullTiles + partialTiles

    def isFull(tile : EGPointI) : bool =
        tile.y + tile.x >= 0 //left
        && tile.y - tile.x <= size.height - 1 //top
        && tile.y + tile.x <= size.width + size.height - 2 //right
        && tile.y - tile.x >= -size.width + 1

    def isPartial(tile : EGPointI) : bool =
        tile.y + tile.x >= -1 //left
        && tile.y - tile.x <= size.height //top
        && tile.y + tile.x <= size.width + size.height - 1 //right
        && tile.y - tile.x >= -size.width && (
            tile.y + tile.x == -1 //left
            || tile.y - tile.x == size.height //top
            || tile.y + tile.x == size.width + size.height - 1 //right
            || tile.y - tile.x == -size.width //bottom
        )

    def drawLayout {
        glPushMatrix
        egRotate(45, 0, 0, 1)
        glBegin(GL_LINES)
        {
            val left = -ISO
            val top = ISO*size.height
            val bottom = ISO*(-size.width)
            val right = ISO*(size.width + size.height - 1)
            egNormal3(0, 0, 1)
            egVertex3(left, top, 0.0)
            egVertex3(left, bottom, 0.0)

            egVertex3(left, bottom, 0.0)
            egVertex3(right, bottom, 0.0)

            egVertex3(right, bottom, 0.0)
            egVertex3(right, top, 0.0)

            egVertex3(right, top, 0.0)
            egVertex3(left, top, 0.0)
        }
        glEnd
        glPopMatrix

        egColor3(1.0, 1.0, 1.0)
        glBegin(GL_LINES)
        {
            fullTiles.for(tile -> {
                val p = tile
                egNormal3(0, 0, 1)
                egVertex3(p.x - 0.5, p.y - 0.5, 0.0)
                egVertex3(p.x + 0.5, p.y - 0.5, 0.0)

                egVertex3(p.x + 0.5, p.y - 0.5, 0.0)
                egVertex3(p.x + 0.5, p.y + 0.5, 0.0)

                egVertex3(p.x + 0.5, p.y + 0.5, 0.0)
                egVertex3(p.x - 0.5, p.y + 0.5, 0.0)

                egVertex3(p.x - 0.5, p.y + 0.5, 0.0)
                egVertex3(p.x - 0.5, p.y - 0.5, 0.0)
            })
        }
        glEnd
        egMapDrawAxis
    }

    def drawPlane {
        glBegin(GL_QUADS)
        {
            val l = limits.x - 1.5
            val r = limits.x2 + 1.5
            val t = limits.y - 1.5
            val b = limits.y2 + 1.5
            val w = limits.width + 3
            val h = limits.height + 3
            egNormal3(0, 0, 1)
            egTexCoord2(0.0, 0.0) egVertex3(l, b, 0)
            egTexCoord2(w, 0.0) egVertex3(r, b, 0)
            egTexCoord2(w, h) egVertex3(r, t, 0)
            egTexCoord2(0.0, h) egVertex3(l, t, 0)
        }
        glEnd
        glPopMatrix
    }

    private def allPosibleTiles : CNChain<EGPointI> =
        CNRange(start = limits.x, end = limits.x2, step = 1).chain
            .mul<int>(CNRange(start = limits.y, end = limits.y2, step = 1))
            .map(EGPointI(_.a, _.b))

    private def tileCutAxis(less : int, more : int) : int =
        if(less == more) 1
        else if(less < more) 0
        else 2

    def cutRectFor(tile : EGPointI) = EGRectI.newXY(
        tileCutAxis(0, tile.x + tile.y),
        tileCutAxis(tile.x + tile.y, size.width + size.height - 2),
        tileCutAxis(tile.y - tile.x, size.height - 1),
        tileCutAxis(-size.width + 1, tile.y - tile.x))
}
