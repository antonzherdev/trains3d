import EG
import EGGL
import EGTypes
import EGMapIso
import EGMatrix
import EGVec

class EGCameraIso(tilesOnScreen : EGVec2I, center : EGVec2) extends EGCamera {
    private static val ISO = EGMapSso.ISO

    def calculateViewportSizeWith(viewSize : EGVec2) : EGRect = {
        val ww = tilesOnScreen.x + tilesOnScreen.y
        val tileSize = min(viewSize.x / ww, 2*viewSize.y/ ww)
        val viewportWidth = tileSize * ww
        val viewportHeight = tileSize * ww / 2
        EGRect((viewSize.x - viewportWidth)/2, viewportWidth,
            (viewSize.y - viewportHeight)/2, viewportHeight)
    }

    private val matrixModel : EGMatrixModel = {
        val ww : float = tilesOnScreen.x + tilesOnScreen.y
        val isoWW2 = ww*ISO/2
        val isoWW4 = isoWW2/2

        EGMatrixModel(
            m = EGMatrix.identity.rotate(90, 1, 0, 0),
            w = EGMatrix.identity.rotate(-90, 1, 0, 0),
            c = EGMatrix.identity
                    .translate(-isoWW2 + ISO, -ISO*(tilesOnScreen.y - tilesOnScreen.x)/4 + isoWW4, -1000)
                    .rotate(30, 1, 0, 0)
                    .rotate(-45.0, 0, 1, 0),
            p = EGMatrix.ortho(-isoWW2, isoWW2, 0, isoWW2, 0.0, 2000.0)
        )
    }

    def focusFor(viewSize : EGVec2) {
        val vps = calculateViewportSizeWith(viewSize)
        glViewport(vps.x, vps.y, vps.width, vps.height)
        EG.matrix.value = matrixModel
        glCullFace(GL_FRONT)
    }

    def translateWith(viewSize : EGVec2, viewPoint : EGVec2) : EGVec2 = {
        val vps = calculateViewportSizeWith(viewSize)
        val x = viewPoint.x - vps.x
        val y = viewPoint.y - vps.y
        val vw = vps.size.x
        val vh = vps.size.y
        val ww2 : float = (tilesOnScreen.x + tilesOnScreen.y)/2.0
        val tw : float = tilesOnScreen.x
        EGVec2((x/vw - y/vh)*ww2 + tw/2 - 0.5 + center.x, (x/vw + y/vh)*ww2 - tw/2 - 0.5 + center.y)
    }
}

