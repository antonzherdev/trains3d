import EG
import EGGL
import EGTypes
import EGMapIso
import EGContext
import EGVec

class EGCameraIso(tilesOnScreen : EGVec2I, center : EGVec2) extends EGCamera {
    private static val ISO = EGMapSso.ISO

    def calculateViewportSizeWith(viewSize : EGVec2) : EGRect = {
        val ww = tilesOnScreen.x + tilesOnScreen.y
        val tileSize = min(viewSize.x / ww, 2*viewSize.y/ ww)
        val viewportWidth = tileSize * ww
        val viewportHeight = tileSize * ww / 2
        EGRect((viewSize.x - viewportWidth)/2, viewportWidth,
            (viewSize.y - viewportHeight)/2, viewportHeight)
    }


    def focusFor(viewSize : EGVec2) {
        val vps = calculateViewportSizeWith(viewSize)
        glViewport(vps.x, vps.y, vps.width, vps.height)

        val mm = EG.modelMatrix
        mm.setIdentity
        mm.rotate(90, 1, 0, 0)

        val wm = EG.worldMatrix
        wm.setIdentity
        wm.translate(0, 0, -100)
        wm.rotate(30, 1, 0, 0)
        wm.rotate(-45.0, 0, 1, 0)
        wm.rotate(-90, 1, 0, 0)

        val cm = EG.cameraMatrix
        cm.setIdentity
        cm.translate(-center.x, 0, -center.y)

        val pm = EG.projectionMatrix
        pm.setIdentity
        val ww : float = tilesOnScreen.x + tilesOnScreen.y
        pm.ortho(-ISO, ISO*ww - ISO, -ISO*tilesOnScreen.x/2, ISO*tilesOnScreen.y/2, 0.0, 1000.0)

        glCullFace(GL_FRONT)
    }

    def translateWith(viewSize : EGVec2, viewPoint : EGVec2) : EGVec2 = {
        val vps = calculateViewportSizeWith(viewSize)
        val x = viewPoint.x - vps.x
        val y = viewPoint.y - vps.y
        val vw = vps.size.x
        val vh = vps.size.y
        val ww2 : float = (tilesOnScreen.x + tilesOnScreen.y)/2.0
        val tw : float = tilesOnScreen.x
        EGVec2((x/vw - y/vh)*ww2 + tw/2 - 0.5 + center.x, (x/vw + y/vh)*ww2 - tw/2 - 0.5 + center.y)
    }

    val eyeDirection : EGVec3 = EGVec3(1, -1, 0.5)
}

