package com.antonzherdev.eg


import core.math._

class CameraIso(tilesOnScreen : vec2, reserve : CameraReserve, viewportRatio : float, center : vec2) extends Camera {
    static def apply(tilesOnScreen : vec2, reserve : CameraReserve, viewportRatio : float) =
        CameraIso(tilesOnScreen, reserve, viewportRatio, (tilesOnScreen - vec2(1, 1))/2.0)
    private static val ISO = MapSso.ISO

    private val ww : float = tilesOnScreen.x + tilesOnScreen.y
//    val viewportRatio : float = 2*ww/(yReserve*2 + ww)

    static val m = mat4.identity.rotate(90, 1, 0, 0)
    static val w = mat4.identity.rotate(-90, 1, 0, 0)

    val matrixModel : MatrixModel = {
        val isoWW = ww*ISO
        val isoWW2 = isoWW/2
        val as = (isoWW - viewportRatio*reserve.height + reserve.width)/(isoWW*viewportRatio)
        val angleSin = if(as > 1.0) 1.0 else as
        ImMatrixModel(
            m = m,
            w = w,
            c = {
                val ang = asin(angleSin)*180/M_PI
                val t = mat4.identity.translate(-center.x, 0, center.y)
                val r = mat4.identity
                    .rotate(ang, 1, 0, 0)
                    .rotate(-45.0, 0, 1, 0)
                r * t
            },
            p = mat4.ortho(
                -isoWW2 - reserve.left, isoWW2 + reserve.right,
                -isoWW2*angleSin - reserve.bottom, isoWW2*angleSin + reserve.top,
                -1000.0, 1000.0)
        )
    }

    def cullFace : uint = GL_FRONT
    def naturalCenter : vec2 = (tilesOnScreen - vec2(1, 1))/2.0
}


class CameraIsoMove(base : CameraIso, misScale : float, maxScale : float, panFingers : uint, tapFingers : uint) extends InputProcessor {
    private var _scale : float = 1.0
    private var _currentBase : CameraIso = base
    private var _camera : CameraIso = base
    def camera : CameraIso = _camera

    static val cameraChangedNotification = NotificationHandle<CameraIsoMove, void>("cameraChangedNotification")
    def scale : float = _scale
    def set(scale : float) {
        var s = scale.max(misScale).min(maxScale)
        if(s != _scale) {
            _scale = s
            _camera = CameraIso(_currentBase.tilesOnScreen/s, _currentBase.reserve/s, _currentBase.viewportRatio, _camera.center)
            cameraChangedNotification.post(self)
        }
    }

    def center : vec2 = _camera.center
    def set(center : vec2) {
        var c = if(_scale <= 1) _currentBase.naturalCenter else {
            val centerP = _currentBase.matrixModel.wcp.mul(vec4(center, 0, 1)).xy
            val cp = centerBounds.closestPointFor(vec2 = centerP)
            if(cp == centerP) center
            else {
                val mat4 = _currentBase.matrixModel.wcp.inverse
                val p0 = mat4.mul(vec4 = vec4(cp.x, cp.y, -1, 1))
                val p1 = mat4.mul(vec4 = vec4(cp.x, cp.y, 1, 1))
                val line = Line3(p0.xyz, p1.xyz - p0.xyz)
                line.r(plane = Plane(vec3(0, 0, 0), vec3(0, 0, 1))).xy
            }
        }
        if(c != _camera.center) {
            _camera = CameraIso(camera.tilesOnScreen, camera.reserve, camera.viewportRatio, c)
            cameraChangedNotification.post(self)
        }
    }

    private var _startPan : vec2
    private var _startScale : float = 1.0
    private var _pinchLocation : vec2
    private var _startCenter : vec2

    def viewportRatio : float = _currentBase.viewportRatio
    def set(viewportRatio : float) {
        _currentBase = CameraIso(_currentBase.tilesOnScreen, _currentBase.reserve, viewportRatio, _currentBase.center)
        _camera = CameraIso(_camera.tilesOnScreen, _camera.reserve, viewportRatio, _camera.center)
    }
    def reserve : CameraReserve = _currentBase.reserve
    def set(reserve : CameraReserve) {
        _currentBase = CameraIso(_currentBase.tilesOnScreen, reserve, _currentBase.viewportRatio, _currentBase.center)
        _camera = CameraIso(_camera.tilesOnScreen, reserve, _camera.viewportRatio, _camera.center)
    }

    var panEnabled = true
    var tapEnabled = true
    var pinchEnabled = true
    def recognizers : Recognizers = [Recognizer<PinchParameter>(Pinch(),
        began = event -> {
            if(pinchEnabled) {
                _startScale = _scale
                _pinchLocation = event.location
                _startCenter = _camera.center
                true
            } else false
        },
        changed = event -> {
            val s = event.param.scale
            set(scale = _startScale * s)
            set(center =
                if(s <= 1.0) _startCenter
                else if(s < 2.0) _startCenter + (_pinchLocation - _startCenter)*(s - 1.0)
                else _pinchLocation
            )
        },
        ended = event -> {
        }
    ),
    Recognizer<Void>(Pan(panFingers),
        began = event -> {
            _startPan = event.location
            panEnabled && _scale > 1.0
        },
        changed = event -> {
            set(center = _camera.center + _startPan - event.location)
        },
        ended = event -> {
        }
    ),
    Recognizer<Void>(Tap(tapFingers, 2),
        on = event -> {
            if(tapEnabled) {
                if(_scale != maxScale) {
                    val loc = event.location
                    set(scale = maxScale)
                    set(center = loc)
                } else {
                    set(scale = 1.0)
                    set(center = _currentBase.naturalCenter)
                }
                true
            } else false
        })
    ]

    private def centerBounds : Rect = {
        val sizeP = vec2(2 - 2/_scale)
        Rect(sizeP/-2, sizeP)
    }
}