package com.antonzherdev.eg


import core.math._

class CameraIso(tilesOnScreen : vec2, yReserve : float4, viewportRatio : float, center : vec2) extends Camera {
    static def apply(tilesOnScreen : vec2, yReserve : float4, viewportRatio : float) =
        CameraIso(tilesOnScreen, yReserve, viewportRatio, (tilesOnScreen - vec2(1, 1))/2.0)
    private static val ISO = MapSso.ISO

    private val ww : float = tilesOnScreen.x + tilesOnScreen.y
//    val viewportRatio : float = 2*ww/(yReserve*2 + ww)

    static val m = mat4.identity.rotate(90, 1, 0, 0)
    static val w = mat4.identity.rotate(-90, 1, 0, 0)

    val matrixModel : MatrixModel = {
        val isoWW = ww*ISO
        val isoWW2 = isoWW/2
        val as = (isoWW - viewportRatio*yReserve)/(isoWW*viewportRatio)
        val angleSin = if(as > 1.0) 1.0 else as
        MatrixModel(
            m = m,
            w = w,
            c = {
                val ang = asin(angleSin)*180/M_PI
                val t = mat4.identity.translate(-center.x, 0, center.y)
                val r = mat4.identity
                    .rotate(ang, 1, 0, 0)
                    .rotate(-45.0, 0, 1, 0)
                r * t
            },
            p = mat4.ortho(-isoWW2, isoWW2, -isoWW2*angleSin, isoWW2*angleSin + yReserve, -1000.0, 1000.0)
        )
    }

    def cullFace : uint = GL_FRONT
    def naturalCenter : vec2 = (tilesOnScreen - vec2(1, 1))/2.0
}


class CameraIsoMove(base : CameraIso, misScale : float, maxScale : float, panFingers : float) extends InputProcessor {
    private var _scale : float = 1.0
    private var _currentBase : CameraIso = base
    private var _camera : CameraIso = base
    def camera : CameraIso = _camera

    static val cameraChangedNotification = NotificationHandle<CameraIsoMove>("cameraChangedNotification")
    def scale : float = _scale
    def set(scale : float) {
        var s = scale.max(misScale).min(maxScale)
        if(s != _scale) {
            _scale = s
            _camera = CameraIso(_currentBase.tilesOnScreen/s, _currentBase.yReserve/s, _currentBase.viewportRatio, _camera.center)
            cameraChangedNotification.post(self)
        }
    }

    def center : vec2 = _camera.center
    def set(center : vec2) {
        var c = if(_scale <= 1) _currentBase.naturalCenter else centerBounds.closestPointFor(vec2 = center)
        if(c != _camera.center) {
            _camera = CameraIso(camera.tilesOnScreen, camera.yReserve, camera.viewportRatio, c)
            cameraChangedNotification.post(self)
        }
    }

    private var _startPan : vec2
    private var _startScale : float = 1.0
    private var _pinchLocation : vec2
    private var _startCenter : vec2

    def viewportRatio : float = _currentBase.viewportRatio
    def set(viewportRatio : float) {
        _currentBase = CameraIso(_currentBase.tilesOnScreen, _currentBase.yReserve, viewportRatio, _currentBase.center)
        _camera = CameraIso(_camera.tilesOnScreen, _camera.yReserve, viewportRatio, _camera.center)
    }
    def yReserve : float = _currentBase.yReserve
    def set(yReserve : float) {
        _currentBase = CameraIso(_currentBase.tilesOnScreen, yReserve, _currentBase.viewportRatio, _currentBase.center)
        _camera = CameraIso(_camera.tilesOnScreen, yReserve, _camera.viewportRatio, _camera.center)
    }

    def recognizers : Recognizers = [Recognizer<PinchParameter>(Pinch(),
        began = event -> {
            _startScale = _scale
            _pinchLocation = event.location
            _startCenter = _camera.center
            true
        },
        changed = event -> {
            val s = event.param.scale
            set(scale = _startScale * s)
            set(center =
                if(s <= 1.0) _startCenter
                else if(s < 2.0) _startCenter + (_pinchLocation - _startCenter)*(s - 1.0)
                else _pinchLocation
            )
        },
        ended = event -> {
        }
    ),
    Recognizer<PinchParameter>(Pan(panFingers),
        began = event -> {
            _startPan = event.location
            true
        },
        changed = event -> {
            set(center = _camera.center + _startPan - event.location)
        },
        ended = event -> {
        }
    )
    ]

    def centerBounds : Quad = {
        val o = base.naturalCenter
        if(_scale < 1) Rect(o, vec2(0, 0)).stripQuad
        else {
            val size = base.tilesOnScreen - base.tilesOnScreen/_scale
            val s2 = size/2
            val rect = Rect(o - size/2, size)
            Quad(rect.p + vec2(-s2.x, s2.y), rect.ph + vec2(s2.x, s2.y),
                rect.phw + vec2(s2.x, -s2.y),
                rect.pw + vec2(-s2.x, -s2.y))
        }
    }
}