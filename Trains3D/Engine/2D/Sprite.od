package com.antonzherdev.eg

import core.math._

object D2D {
    def install {}

    private val vertexes = VoidRefArray(BillboardBufferData.type, 4)
    private val vb = VBO.mut(Sprite.vbDesc)
    private val vaoForColor = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShaderSystem.shaderFor(key = BillboardShaderKey(
        texture = false, alpha = false, shadow = false, modelSpace = BillboardShaderSpace.camera
    )))
    private val vaoForTexture = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShaderSystem.shaderFor(key = BillboardShaderKey(
        texture = true, alpha = false, shadow = false, modelSpace = BillboardShaderSpace.camera
    )))
    def drawSprite(material : ColorSource, at : vec3, rect : Rect) {
        drawSprite(material, at, rect.stripQuad)
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad) {
        if(material.texture.isDefined) {
            drawSprite(material, at, quad, material.texture.get.uv.upsideDownStripQuad)
        } else {
            drawSprite(material, at, quad, Rect(0, 0, 1, 1).upsideDownStripQuad)
        }
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad, uv : Quad) {
//        if(true) return nil
        var v = vertexes
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p0, material.color, uv.p0))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p1, material.color, uv.p1))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p2, material.color, uv.p2))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p3, material.color, uv.p3))
        vb.set(vertexes)
        context.cullFace.disabled {
            if(material.texture.isEmpty) vaoForColor.draw(material)
            else vaoForTexture.draw(material)
        }
    }

    def writeSprite(in : VoidRefArray, material : ColorSource, at : vec3, quad : Quad, uv : Quad) : VoidRefArray = {
        var v = in.write(BillboardBufferData, BillboardBufferData(at, quad.p0, material.color, uv.p0))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p1, material.color, uv.p1))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p2, material.color, uv.p2))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p3, material.color, uv.p3))
        v
    }

    def writeQuadIndex(in : VoidRefArray, i : uint4) : VoidRefArray = {
        in
            .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
            .write(uInt4 = i + 1).write(uInt4 = i + 2).write(uInt4 = i + 3)
    }

    private val lineVb = VBO.mutMesh
    private val lineVertexes = VoidRefArray(MeshData.type, 2)
    private val lineVao = Mesh(lineVb, EmptyIndexSource.lines).vao(SimpleShaderSystem.colorShader)
    def drawLine(material : ColorSource, p0 : vec2, p1 : vec2) {
        var v = lineVertexes
        v = v.write(MeshData, MeshData(vec2(0, 0), vec3(0, 0, 1), vec3(p0, 0)))
        v = v.write(MeshData, MeshData(vec2(1, 1), vec3(0, 0, 1), vec3(p1, 0)))
        lineVb.set(lineVertexes)

        context.cullFace.disabled {
            lineVao.draw(material)
        }
    }

    private lazy val circleVaoWithSegment = Mesh(
        VBO.vec2([vec2(-1, -1), vec2(-1, 1), vec2(1, -1), vec2(1, 1)]),
        EmptyIndexSource.triangleStrip).vao(CircleShader.withSegment)
    def drawCircle(backColor : vec4, strokeColor : vec4, at : vec3, radius : float4, relative : vec2, segmentColor : vec4,
        start : float, end : float)
    {
        context.cullFace.disabled {
            circleVaoWithSegment.draw(CircleParam(backColor, strokeColor, at, radiusP(radius), relative, CircleSegment(segmentColor, start, end)))
        }
    }
    private lazy val circleVaoWithoutSegment = Mesh(
        VBO.vec2([vec2(-1, -1), vec2(-1, 1), vec2(1, -1), vec2(1, 1)]),
        EmptyIndexSource.triangleStrip).vao(CircleShader.withoutSegment)

    def drawCircle(backColor : vec4, strokeColor : vec4, at : vec3, radius : float4, relative : vec2) {
        context.cullFace.disabled {
            circleVaoWithoutSegment.draw(CircleParam(backColor, strokeColor, at, radiusP(radius), relative, nil))
        }
    }

    private def radiusP(r : float4) : vec2 = {
        val l = (matrix.value.wcp * vec4(r, 0, 0, 0)).xy.length
        val vps = context.viewport.size

        if(vps.y <= vps.x) vec2(l * vps.y/vps.x, l)
        else vec2(l, l * vps.x/vps.y)
    }
}

class CircleShaderBuilder(segment : bool) extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        $ain lowp vec2 model;

        uniform highp vec4 position;
        uniform mat4 p;
        uniform lowp vec2 radius;
        $out highp vec2 coord;

        void main(void) {
            highp vec4 pos = p*position;
            pos.xy += model*radius;
            gl_Position = pos;
            coord = model;
        }"
    def fragment =
       "$fragmentHeader

        $in highp vec2 coord;
        uniform lowp vec4 color;
        uniform lowp vec4 strokeColor;
       $if(segment)
        uniform lowp vec4 sectorColor;
        uniform lowp float startTg;
        uniform lowp float endTg;
       $endif

        void main(void) {
            lowp float tg = atan(coord.y, coord.x);
            highp float dt = dot(coord, coord);
            lowp float alpha = 0.0;
       $if(segment)
            if(endTg < startTg) {
                alpha = sectorColor.w * clamp(
                    1.0 - smoothstep(0.95, 1.0, dt)
                    - (clamp(smoothstep(endTg - 0.1, endTg, tg) + 1.0 - smoothstep(startTg, startTg + 0.1, tg), 1.0, 2.0) - 1.0)
                , 0.0, 1.0);
            } else {
                alpha = sectorColor.w * clamp(
                        1.0 - smoothstep(0.95, 1.0, dt)
                        - (1.0 - smoothstep(startTg, startTg + 0.1, tg))
                        - (smoothstep(endTg - 0.1, endTg, tg))
                , 0.0, 1.0);
            }
            $fragColor = vec4(mix(
                    mix(color.xyz, sectorColor.xyz, alpha),
                    strokeColor.xyz, strokeColor.w*(smoothstep(0.75, 0.8, dt) - smoothstep(0.95, 1.0, dt))),
                color.w * (1.0 - smoothstep(0.95, 1.0, dt)));
       $else
            $fragColor = vec4(mix(color.xyz, strokeColor.xyz, strokeColor.w*(smoothstep(0.75, 0.8, dt) - smoothstep(0.95, 1.0, dt))),
                color.w * (1.0 - smoothstep(0.95, 1.0, dt)));
       $endif
        }"

    def program = ShaderProgram("Circle", vertex, fragment)
}

class CircleParam(color : vec4, strokeColor : vec4, position : vec3, radius : vec2, relative : vec2, segment : CircleSegment?)
class CircleSegment(color : vec4, start : float4, end : float4)

class CircleShader(segment : bool) extends Shader<CircleParam>(CircleShaderBuilder(segment).program) {
    static val withSegment = CircleShader(true)
    static val withoutSegment = CircleShader(false)

    val model = attributeFor("model")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        model.setFromBufferWith(vbDesc.stride, 2, GL_FLOAT, vbDesc.model)
    }

    val pos = uniformVec4("position")
    val p = uniformMat4("p")
    val radius = uniformVec2("radius")
    val color = uniformVec4("color")
    val strokeColor = uniformVec4("strokeColor")
    val sectorColor : ShaderUniformVec4? = if(segment) uniformVec4("sectorColor") else nil
    val startTg : ShaderUniformF4? = if(segment) uniformF4("startTg") else nil
    val endTg : ShaderUniformF4? = if(segment) uniformF4("endTg") else nil
    def loadUniforms(param : CircleParam) {
        pos(matrix.value.wc * vec4(param.position, 1) + param.relative)
        p(matrix.value.p)
        radius(param.radius)
        color(param.color)
        strokeColor(param.strokeColor)
        if(segment) {
            val sec = param.segment.get
            sectorColor.get.apply(sec.color)
            if(sec.start < sec.end) {
                startTg.get.apply(clamp(sec.start))
                endTg.get.apply(clamp(sec.end))
            } else {
                startTg.get.apply(clamp(sec.end))
                endTg.get.apply(clamp(sec.start))
            }
        }
    }
    private def clamp(p : float4) : float4 =
        if(p < -M_PI) 2*M_PI + p
        else if(p > M_PI) -2*M_PI + p
        else p
}

class Sprite(visible : React<bool> = true, material : React<ColorSource>, position : React<vec3>,
    rect : React<Rect> = rectReact(material, anchor = vec2(0, 0)))
{
    static def apply(visible : React<bool> = true, material : React<ColorSource>, position : React<vec3>, anchor : vec2) : Sprite =
        Sprite(visible, material, position, rect = rectReact(material, anchor))
    static def rectReact(material : React<ColorSource>, anchor : vec2) : React<Rect> =
        material.map{m ->
            val s = m.texture.get.size/Director.current.scale
            Rect(s*((anchor + 1)/-2), s)
        }

    static val vbDesc = VertexBufferDesc<BillboardBufferData>(BillboardBufferData.type,
        position = 0, uv = 9*4, normal = -1, color = 5*4, model = 3*4)

    private val vb = VBO.mut(vbDesc)
    private var vao : VertexArray<ColorSource>

    private var _changed = ReactFlag(initial = true, [material, position, rect, context.viewSize])
    private var _materialChanged = ReactFlag(initial = true, [material])

    def draw {
        if(!visible.value) return nil
        if(_materialChanged.value) {
            vao = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShaderSystem.projectionSpace, material.value, false)
            _materialChanged.clear
        }
        if(_changed.value) {
            val vertexes = VoidRefArray(BillboardBufferData.type, 4)
            val m = material.value
            D2D.writeSprite(vertexes, m, position.value, (rect.value/context.scaledViewSize.value*2).stripQuad,
                if(m.texture.isDefined) m.texture.get.uv.upsideDownStripQuad
                else Rect(0, 0, 1, 1).upsideDownStripQuad)
            vb.set(vertexes)
            vertexes.free
            _changed.clear
        }
        context.cullFace.disabled {
            vao.draw
        }
    }

    def rectInViewport : Rect = {
        val pp = matrix.value.wcp.mul(vec4(position.value, 1))
        (rect.value/context.scaledViewSize.value*2) + pp.xy
    }
    def containsViewport(vec2 : vec2) : bool = visible.value && rectInViewport.contains(vec2)

    val tap = Signal<void>()
    def tap(event : Event) : bool =
        if(containsViewport(event.locationInViewport)) {
            tap.post
            true
        } else false
}

class Button(sprite : Sprite, text : Text) {
    def tap : Signal<void> = sprite.tap

    def draw {
        sprite.draw
        text.draw
    }
    def tap(event : Event) : bool = sprite.tap(event)

    static def apply(visible : React<bool> = true, font : React<Font>, text : React<string>, textColor : React<vec4>,
        backgroundMaterial : React<ColorSource>, position : React<vec3>, rect : React<Rect>) : Button =
        Button(
            Sprite(visible, backgroundMaterial, position, rect),
            Text(visible, font, text, position,
                alignment = rect.map{r -> TextAlignment(x = 0, y = 0, baseline = false, shift = r.center)},
                textColor)
        )
}