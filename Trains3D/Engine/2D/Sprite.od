package com.antonzherdev.eg

import core.math._

object D2D {
    private val vertexes = VoidRefArray(BillboardBufferData.type, 4)
    private val vb = VBO.mut(Billboard.vbDesc)
    private val vaoForColor = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForColor)
    private val vaoForTexture = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForTexture)
    def drawSprite(material : ColorSource, at : vec3, rect : Rect) {
        drawSprite(material, at, rect.stripQuad)
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad) {
        if(material.texture.isDefined) {
            drawSprite(material, at, quad, material.texture.get.uv.upsideDownStripQuad)
        } else {
            drawSprite(material, at, quad, Rect(0, 0, 1, 1).upsideDownStripQuad)
        }
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad, uv : Quad) {
//        if(true) return nil
        var v = vertexes
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p0, material.color, uv.p0))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p1, material.color, uv.p1))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p2, material.color, uv.p2))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p3, material.color, uv.p3))
        vb.set(vertexes)
        context.cullFace.disabled {
            if(material.texture.isEmpty) vaoForColor.draw(material)
            else vaoForTexture.draw(material)
        }
    }

    def writeSprite(in : VoidRefArray, material : ColorSource, at : vec3, quad : Quad, uv : Quad) : VoidRefArray = {
        var v = in.write(BillboardBufferData, BillboardBufferData(at, quad.p0, material.color, uv.p0))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p1, material.color, uv.p1))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p2, material.color, uv.p2))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p3, material.color, uv.p3))
        v
    }

    def writeQuadIndex(in : VoidRefArray, i : uint4) : VoidRefArray = {
        in
            .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
            .write(uInt4 = i + 1).write(uInt4 = i + 2).write(uInt4 = i + 3)
    }

    private val lineVb = VBO.mutMesh
    private val lineVertexes = VoidRefArray(MeshData.type, 2)
    private val lineVao = Mesh(lineVb, EmptyIndexSource.lines).vao(SimpleShaderSystem.colorShader)
    def drawLine(material : ColorSource, p0 : vec2, p1 : vec2) {
        var v = lineVertexes
        v = v.write(MeshData, MeshData(vec2(0, 0), vec3(0, 0, 1), vec3(p0, 0)))
        v = v.write(MeshData, MeshData(vec2(1, 1), vec3(0, 0, 1), vec3(p1, 0)))
        lineVb.set(lineVertexes)

        context.cullFace.disabled {
            lineVao.draw(material)
        }
    }

    private lazy val circleVaoForColor = Mesh(
        VBO.vec2([vec2(-1, -1), vec2(-1, 1), vec2(1, -1), vec2(1, 1)]),
        EmptyIndexSource.triangleStrip).vao(CircleShader.instance)
    def drawCircle(backColor : vec4, strokeColor : vec4, at : vec3, radius : float4, relative : vec2, segmentColor : vec4,
        start : float, end : float)
    {
        BlendFunction.standard { context.cullFace.disabled {
            val vps = context.viewport.size
            val rad = if(vps.y <= vps.x) vec2(radius * vps.y/vps.x, radius)
                else vec2(radius, radius * vps.x/vps.y)
            circleVaoForColor.draw(CircleParam(backColor, strokeColor, at, rad, relative, CircleSegment(segmentColor, start, end)))
        }}
    }
}

class CircleShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        $ain lowp vec2 model;

        uniform highp vec4 position;
        uniform mat4 p;
        uniform lowp vec2 radius;
        $out highp vec2 coord;

        void main(void) {
            highp vec4 pos = p*position;
            pos.xy += model*radius;
            gl_Position = pos;
            coord = model;
        }"
    def fragment =
       "$fragmentHeader

        $in highp vec2 coord;
        uniform lowp vec4 color;
        uniform lowp vec4 strokeColor;
        uniform lowp vec4 sectorColor;
        uniform lowp float startTg;
        uniform lowp float endTg;

        void main(void) {
            lowp float tg = atan(coord.y, coord.x);
            highp float dt = dot(coord, coord);
            lowp float alpha = 0.0;
            if(endTg < startTg) {
                alpha = sectorColor.w * clamp(
                    1.0 - smoothstep(0.95, 1.0, dt)
                    - (clamp(smoothstep(endTg - 0.1, endTg, tg) + 1.0 - smoothstep(startTg, startTg + 0.1, tg), 1.0, 2.0) - 1.0)
                , 0.0, 1.0);
            } else {
                alpha = sectorColor.w * clamp(
                        1.0 - smoothstep(0.95, 1.0, dt)
                        - (1.0 - smoothstep(startTg, startTg + 0.1, tg))
                        - (smoothstep(endTg - 0.1, endTg, tg))
                , 0.0, 1.0);
            }
            $fragColor = vec4(mix(
                    mix(color.xyz, sectorColor.xyz, alpha),
                    strokeColor.xyz, strokeColor.w*(smoothstep(0.75, 0.8, dt) - smoothstep(0.95, 1.0, dt))),
                color.w * (1.0 - smoothstep(0.95, 1.0, dt)));

        }"

    def program = ShaderProgram("Circle", vertex, fragment)
}

class CircleParam(color : vec4, strokeColor : vec4, position : vec3, radius : vec2, relative : vec2, segment : CircleSegment)
class CircleSegment(color : vec4, start : float4, end : float4)

class CircleShader extends Shader<CircleParam>(CircleShaderBuilder().program) {
    static val instance = CircleShader()

    val model = attributeFor("model")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        model.setFromBufferWith(vbDesc.stride, 2, GL_FLOAT, vbDesc.model)
    }

    val pos = uniformVec4("position")
    val p = uniformMat4("p")
    val radius = uniformVec2("radius")
    val color = uniformVec4("color")
    val strokeColor = uniformVec4("strokeColor")
    val sectorColor = uniformVec4("sectorColor")
    val startTg = uniformF4("startTg")
    val endTg = uniformF4("endTg")
    def loadUniforms(param : CircleParam) {
        pos(matrix.value.wc * vec4(param.position, 1) + param.relative)
        p(matrix.value.p)
        radius(param.radius)
        color(param.color)
        strokeColor(param.strokeColor)
        val sec = param.segment
        sectorColor(sec.color)
        if(sec.start < sec.end) {
            startTg(clamp(sec.start))
            endTg(clamp(sec.end))
        } else {
            startTg(clamp(sec.end))
            endTg(clamp(sec.start))
        }
    }
    private def clamp(p : float4) : float4 =
        if(p < -M_PI) 2*M_PI + p
        else if(p > M_PI) -2*M_PI + p
        else p
}

class Sprite {
    static def apply(material : ColorSource) : Sprite = {
        val s = Sprite()
        s.material = material
        s
    }

    static def apply(material : ColorSource, rect : Rect) : Sprite = {
        val s = Sprite()
        s.material = material
        s.rect = rect
        s
    }

    private val vb = VBO.mut(Billboard.vbDesc)
    private var vao : VertexArray<ColorSource>

    private var _changed = true
    private var _material : ColorSource
    def material = _material
    def set(material : ColorSource) {
        if(_material != material) {
            _material = material
            _changed = true
            vao = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShaderSystem.instance, material, false)
        }
    }

    def draw {
        if(_changed) {
            val vertexes = VoidRefArray(BillboardBufferData.type, 4)
            D2D.writeSprite(vertexes, _material, vec3(_position, 0), Rect(vec2(0, 0), _size).stripQuad,
                if(_material.texture.isDefined) material.texture.get.uv.upsideDownStripQuad
                else Rect(0, 0, 1, 1).upsideDownStripQuad)
            vb.set(vertexes)
            vertexes.free
            _changed = false
        }
        context.cullFace.disabled {
            vao.draw
        }
    }

    private var _position : vec2 = vec2(0, 0)
    def position = _position
    def set(position : vec2) {
        if(_position != position) {
            _position = position
            _changed = true
        }
    }
    private var _size : vec2 = vec2(1, 1)
    def size = _size
    def set(size : vec2) {
        if(_size != size) {
            _size = size
            _changed = true
        }
    }
    def rect : Rect = Rect(_position, _size)
    def set(rect : Rect) {
        position = rect.p
        size = rect.size
    }

    static def apply(texture : Texture) : Sprite = {
        val s = Sprite()
        s.material = ColorSource(texture)
        s
    }

    def adjustSize {
        if(_material.texture.isDefined) {
            size = _material.texture.get.scaledSize
        }
    }

    def contains(vec2 : vec2) : bool = Rect(_position, _size).contains(vec2)
}

class Line2d {
    static def apply(material : ColorSource) = {
        val l = Line2d()
        l.material = material
        l
    }

    var material : ColorSource
    var p0 : vec2 = vec2(0, 0)
    var p1 : vec2 = vec2(1, 1)

    def draw {
        D2D.drawLine(material, p0, p1)
    }
}

class Button(onDraw : (Rect) -> void, onClick : () -> void) {
    static def apply(rect : Rect, onDraw : (Rect) -> void, onClick : () -> void) = {
        val b = Button(onDraw, onClick)
        b.rect = rect
        b
    }

    var rect : Rect = Rect(0, 0, 1, 1)
    def tap(event : Event) : bool =
        if(rect.contains(event.location)) {
            onClick()
            true
        } else false

    def draw {
        onDraw(rect)
    }


    static def drawText(font : () -> Font, color : vec4, text : string) : Rect -> void = {
        val tc = Text(nil, text, vec3(0, 0, 0), TextAlignment(0, 0), color)
        (rect : Rect) -> {
            tc.font = font()
            tc.position = rect.center
            tc.draw
        }
    }
}