package com.antonzherdev.eg

import core.math._

object D2D {
    private val vertexes = VoidRefArray(BillboardBufferData.type, 4)
    private val vb = VBO.mut(Billboard.vbDesc)
    private val vaoForColor = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForColor)
    private val vaoForTexture = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForTexture)
    def drawSprite(material : ColorSource, at : vec3, rect : Rect) {
        drawSprite(material, at, rect.quad)
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad) {
        if(material.texture.isDefined) {
            drawSprite(material, at, quad, material.texture.get.uv.upsideDownQuad)
        } else {
            drawSprite(material, at, quad, Rect(0, 0, 1, 1).upsideDownQuad)
        }
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad, uv : Quad) {
//        if(true) return nil
        var v = vertexes
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[0], material.color, uv.p[0]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[1], material.color, uv.p[1]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[2], material.color, uv.p[2]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[3], material.color, uv.p[3]))
        vb.set(vertexes)
        context.cullFace.disabled {
            if(material.texture.isEmpty) vaoForColor.draw(material)
            else vaoForTexture.draw(material)
        }
    }

    def writeSprite(in : VoidRefArray, material : ColorSource, at : vec3, quad : Quad, uv : Quad) : VoidRefArray = {
        var v = in.write(BillboardBufferData, BillboardBufferData(at, quad.p[0], material.color, uv.p[0]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[1], material.color, uv.p[1]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[2], material.color, uv.p[2]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[3], material.color, uv.p[3]))
        v
    }

    def writeQuadIndex(in : VoidRefArray, i : uint4) : VoidRefArray = {
        in
            .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
            .write(uInt4 = i + 1).write(uInt4 = i + 2).write(uInt4 = i + 3)
    }

    private val lineVb = VBO.mutMesh
    private val lineVertexes = VoidRefArray(MeshData.type, 2)
    private val lineVao = Mesh(lineVb, EmptyIndexSource.lines).vao(SimpleShaderSystem.colorShader)
    def drawLine(material : ColorSource, p0 : vec2, p1 : vec2) {
        var v = lineVertexes
        v = v.write(MeshData, MeshData(vec2(0, 0), vec3(0, 0, 1), vec3(p0, 0)))
        v = v.write(MeshData, MeshData(vec2(1, 1), vec3(0, 0, 1), vec3(p1, 0)))
        lineVb.set(lineVertexes)

        context.cullFace.disabled {
            lineVao.draw(material)
        }
    }

    private lazy val circleVaoForColor = Mesh(
        VBO.vec2([vec2(-1, -1), vec2(-1, 1), vec2(1, -1), vec2(1, 1)]),
        EmptyIndexSource.triangleStrip).vao(CircleShader.instance)
    def drawCircle(material : ColorSource, at : vec3, radius : float4, relative : vec2, start : float, end : float) {
        BlendFunction.standard { context.cullFace.disabled {
            circleVaoForColor.draw(CircleParam(material.color, at, radius, relative, start, end))
        }}
    }
}

class CircleShaderBuilder extends ShaderTextBuilder {
    def vertex =
       "$vertexHeader
        $ain lowp vec2 model;

        uniform highp vec4 position;
        uniform mat4 p;
        uniform lowp float radius;
        $out highp vec2 coord;

        void main(void) {
            highp vec4 pos = position;
            pos.x += model.x*radius;
            pos.y += model.y*radius;
            gl_Position = p*pos;
            coord = model;
        }"
    def fragment =
       "$fragmentHeader

        $in highp vec2 coord;
        uniform lowp vec4 color;
        uniform lowp float startTg;
        uniform lowp float endTg;

        void main(void) {
            lowp float tg = atan(coord.y, coord.x);
            if(endTg < startTg) {
               $fragColor = vec4(color.xyz, color.w * (
                        1.0 - smoothstep(0.95, 1.0, dot(coord, coord))
                        - (clamp(smoothstep(endTg - 0.1, endTg, tg) + 1.0 - smoothstep(startTg, startTg + 0.1, tg), 1.0, 2.0) - 1.0)
               ));
            } else {
                $fragColor = vec4(color.xyz, color.w * (
                        1.0 - smoothstep(0.95, 1.0, dot(coord, coord))
                        - (1.0 - smoothstep(startTg, startTg + 0.1, tg))
                        - (smoothstep(endTg - 0.1, endTg, tg))
                ));
            }
        }"

    def program = ShaderProgram("Circle", vertex, fragment)
}

class CircleParam(color : vec4, position : vec3, radius : float4, relative : vec2, start : float4, end : float4)

class CircleShader extends Shader<CircleParam>(CircleShaderBuilder().program) {
    static val instance = CircleShader()

    val model = attributeFor("model")
    def loadAttributes(vbDesc : VertexBufferDesc<_>) {
        model.setFromBufferWith(vbDesc.stride, 2, GL_FLOAT, vbDesc.model)
    }

    val pos = uniformVec4("position")
    val p = uniformMat4("p")
    val radius = uniformF4("radius")
    val color = uniformVec4("color")
    val startTg = uniformF4("startTg")
    val endTg = uniformF4("endTg")
    def loadUniforms(param : CircleParam) {
        pos(matrix.value.wc * vec4(param.position, 1) + param.relative)
        p(matrix.value.p)
        radius(param.radius)
        color(param.color)
        if(param.start < param.end) {
            startTg(clamp(param.start))
            endTg(clamp(param.end))
        } else {
            startTg(clamp(param.end))
            endTg(clamp(param.start))
        }
    }
    private def clamp(p : float4) : float4 =
        if(p < -M_PI) 2*M_PI + p
        else if(p > M_PI) -2*M_PI + p
        else p
}

class Sprite {
    static def apply(material : ColorSource) : Sprite = {
        val s = Sprite()
        s.material = material
        s
    }

    static def apply(material : ColorSource, rect : Rect) : Sprite = {
        val s = Sprite()
        s.material = material
        s.rect = rect
        s
    }

    private val vb = VBO.mut(Billboard.vbDesc)
    private var vao : VertexArray<ColorSource>

    private var _changed = true
    private var _material : ColorSource
    def material = _material
    def set(material : ColorSource) {
        if(_material != material) {
            _material = material
            _changed = true
            vao = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShaderSystem.instance, material, false)
        }
    }

    def draw {
        if(_changed) {
            val vertexes = VoidRefArray(BillboardBufferData.type, 4)
            D2D.writeSprite(vertexes, _material, vec3(_position, 0), Rect(vec2(0, 0), _size).quad,
                if(_material.texture.isDefined) material.texture.get.uv.upsideDownQuad
                else Rect(0, 0, 1, 1).upsideDownQuad)
            vb.set(vertexes)
            _changed = false
        }
        context.cullFace.disabled {
            vao.draw
        }
    }

    private var _position : vec2 = vec2(0, 0)
    def position = _position
    def set(position : vec2) {
        if(_position != position) {
            _position = position
            _changed = true
        }
    }
    private var _size : vec2 = vec2(1, 1)
    def size = _size
    def set(size : vec2) {
        if(_size != size) {
            _size = size
            _changed = true
        }
    }
    def rect : Rect = Rect(_position, _size)
    def set(rect : Rect) {
        position = rect.p0
        size = rect.size
    }

    static def apply(texture : Texture) : Sprite = {
        val s = Sprite()
        s.material = ColorSource(texture)
        s
    }

    def adjustSize {
        if(_material.texture.isDefined) {
            size = _material.texture.get.scaledSize
        }
    }

    def contains(vec2 : vec2) : bool = Rect(_position, _size).contains(vec2)
}

class Line2d {
    static def apply(material : ColorSource) = {
        val l = Line2d()
        l.material = material
        l
    }

    var material : ColorSource
    var p0 : vec2 = vec2(0, 0)
    var p1 : vec2 = vec2(1, 1)

    def draw {
        D2D.drawLine(material, p0, p1)
    }
}

class Button(onDraw : (Rect) -> void, onClick : () -> void) extends TapProcessor {
    static def apply(rect : Rect, onDraw : (Rect) -> void, onClick : () -> void) = {
        val b = Button(onDraw, onClick)
        b.rect = rect
        b
    }

    var rect : Rect = Rect(0, 0, 1, 1)
    def tap(event : Event) : bool =
        if(rect.contains(event.location)) {
            onClick()
            true
        } else false

    def draw {
        onDraw(rect)
    }


    static def drawText(font : () -> Font, color : vec4, text : string) : Rect -> void = {
        val tc = Text(nil, text, vec3(0, 0, 0), TextAlignment(0, 0), color)
        (rect : Rect) -> {
            tc.font = font()
            tc.position = rect.center
            tc.draw
        }
    }
}