package com.antonzherdev.eg

import core.math._

object D2D {
    private val vertexes = VoidRefArray(BillboardBufferData.type, 4)
    private val vb = VBO.mut(Billboard.vbDesc)
    private val vaoForColor = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForColor)
    private val vaoForTexture = Mesh(vb, EmptyIndexSource.triangleStrip).vao(BillboardShader.instanceForTexture)
    def drawSprite(material : ColorSource, at : vec3, rect : Rect) {
        drawSprite(material, at, rect.quad)
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad) {
        if(material.texture.isDefined) {
            drawSprite(material, at, quad, material.texture.get.uv.upsideDownQuad)
        } else {
            drawSprite(material, at, quad, Rect(0, 0, 1, 1).upsideDownQuad)
        }
    }

    def drawSprite(material : ColorSource, at : vec3, quad : Quad, uv : Quad) {
        var v = vertexes
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[0], material.color, uv.p[0]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[1], material.color, uv.p[1]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[2], material.color, uv.p[2]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[3], material.color, uv.p[3]))
        vb.set(vertexes)
        context.cullFace.disabled {
            if(material.texture.isEmpty) vaoForColor.draw(material)
            else vaoForTexture.draw(material)
        }
    }

    def writeSprite(in : VoidRefArray, material : ColorSource, at : vec3, quad : Quad, uv : Quad) : VoidRefArray = {
        var v = in.write(BillboardBufferData, BillboardBufferData(at, quad.p[0], material.color, uv.p[0]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[1], material.color, uv.p[1]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[2], material.color, uv.p[2]))
        v = v.write(BillboardBufferData, BillboardBufferData(at, quad.p[3], material.color, uv.p[3]))
        v
    }

    def writeQuadIndex(in : VoidRefArray, i : uint4) : VoidRefArray = {
        in
            .write(uInt4 = i).write(uInt4 = i + 1).write(uInt4 = i + 2)
            .write(uInt4 = i + 1).write(uInt4 = i + 2).write(uInt4 = i + 3)
    }

    private val lineVb = VBO.mutMesh
    private val lineVertexes = VoidRefArray(MeshData.type, 2)
    private val lineVao = Mesh(lineVb, EmptyIndexSource.lines).vao(SimpleShaderSystem.colorShader)
    def drawLine(material : ColorSource, p0 : vec2, p1 : vec2) {
        var v = lineVertexes
        v = v.write(MeshData, MeshData(vec2(0, 0), vec3(0, 0, 1), vec3(p0, 0)))
        v = v.write(MeshData, MeshData(vec2(1, 1), vec3(0, 0, 1), vec3(p1, 0)))
        lineVb.set(lineVertexes)

        context.cullFace.disabled {
            lineVao.draw(material)
        }
    }

    private lazy val circleVb = VBO.mut(Billboard.vbDesc)
    private lazy val circleVaoForColor = Mesh(circleVb, EmptyIndexSource.triangleFan).vao(BillboardShader.instanceForColor)
    def drawCircle(material : ColorSource, at : vec3, radius : float4, segments : uint4, start : float, end : float) {
        val theta = 2 * M_PI / segments

        val c = cos(theta)
        val s = sin(theta)
        var t = 0.0
        var a = 0.0

        val st : float
        val ed : float
        if(start < end) {
            st = start
            ed = end - start
        } else {
            st = end
            ed = start - end
        }
        var x = radius * cos(st)
        var y = radius * sin(st)

        val vertexes = VoidRefArray(BillboardBufferData.type, segments + 2)
        var v = vertexes
        var ii = 0
        var n = 1
        v = v.write(BillboardBufferData, BillboardBufferData(at, vec2(0, 0), material.color, vec2(0, 0)))

        while(ii <= segments) {
            if(a <= ed) {
                v = v.write(BillboardBufferData, BillboardBufferData(at, vec2(x, y), material.color, vec2(0, 0)))
                n++
            }
            t = x
            x = c * x - s * y
            y = s * t + c * y
            ii++
            a += theta
        }
        circleVb.set(vertexes, n)
        context.cullFace.disabled {
            circleVaoForColor.draw(material)
        }
    }
}

class Sprite {
    var material : ColorSource

    def draw {
        D2D.drawSprite(material, at = vec3(position, 0), Rect(vec2(0, 0), size).quad)
    }

    var position : vec2 = vec2(0, 0)
    var size : vec2 = vec2(1, 1)
    def rect : Rect = Rect(position, size)

    static def apply(material : ColorSource, size : vec2) : Sprite = {
        val s = Sprite()
        s.material = material
        s.size = size
        s
    }

    static def apply(texture : Texture) : Sprite = {
        val s = Sprite()
        s.material = ColorSource(texture)
        s
    }

    def adjustSize {
        if(material.texture.isDefined) {
            size = material.texture.get.scaledSize
        }
    }

    def contains(vec2 : vec2) : bool = Rect(position, size).contains(vec2)
}

class Line2d {
    static def apply(material : ColorSource) = {
        val l = Line2d()
        l.material = material
        l
    }

    var material : ColorSource
    var p0 : vec2 = vec2(0, 0)
    var p1 : vec2 = vec2(1, 1)

    def draw {
        D2D.drawLine(material, p0, p1)
    }
}