package com.antonzherdev.trains

import com.antonzherdev.eg._

enum TrainType(obstacleProcessor : (Level, LiveTrainState, Obstacle) -> bool) {
    simple((level : Level, trainState : LiveTrainState, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) level.destroy(trainState.train)
        false
    })
    crazy((level : Level, trainState : LiveTrainState, o : Obstacle) -> {
        if(o.obstacleType !=  ObstacleType.light) {
            if(o.obstacleType == ObstacleType.end) {
                val point = trainState.head
                if(!(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))) {
                    false
                } else {
                    level.railroad.addDamageAt(point)
                    level.destroy(trainState.train)
                    false
                }
            } else {
                level.railroad.addDamageAt(trainState.head)
                level.destroy(trainState.train)
                false
            }
        } else true
    })
    fast((level : Level, trainState : LiveTrainState, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.switch) {
            level.railroad.addDamageAt(o.point)
            level.destroy(trainState.train)
        } else if(o.obstacleType ==  ObstacleType.damage) level.destroy(trainState.train)
        false
    })
    repairer((level : Level, trainState : LiveTrainState, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) {
            level.fixDamageAt(o.point)
            true
        } else false
    })
}

class TrainState(weak train : Train, time : float) {
    def carStates : [CarState]
    def isDying : bool
}
class DieTrainState(weak train : Train, time : float, carStates : [DieCarState]) extends TrainState(train, time) {
    def isDying = true
}
class LiveTrainState(weak train : Train, time : float, head : RailPoint, isBack : bool, carStates : [LiveCarState]) extends TrainState(train, time) {
    def isDying = false
}

class Train(weak level : Level, trainType : TrainType, color : CityColor, carTypes : [CarType], speed : uint) extends Actor {
    val _soundData = TrainSoundData()
    var _head : RailPoint = RailPoint()
    private var _isBack = false
    val speedFloat : float = 0.01 * speed
    val length : float = carTypes.chain.fold(0.0, (r, car) -> car.fullLength + r)
    var _isDying = false
    var _time : float = 0
    var _state : TrainState = LiveTrainState(self, time = 0, _head, isBack = false, carStates = [])
    val cars : [Car] = {
        var i = 0
        carTypes.chain.map{tp ->
            val car = Car(self, carType = tp, number = i)
            i++
            car
        }.toArray
    }

    def state = prompt {
        _state
    }

    def startFrom(city : City) = lockAndOnSuccess(level.railroad.state) { rrState ->
        _head = city.startPoint
        calculateCarPositions(rrState)
    }

    def description = "<Train: $trainType, $color>"

    def set(head : RailPoint) = lockAndOnSuccess(level.railroad.state) { rrState ->
        _head = head
        calculateCarPositions(rrState)
    }

    def die = prompt{
        _isDying = true
    }

    def set(dieCarStates : [DieCarState]) = prompt {
        _state = DieTrainState(self, _time, dieCarStates)
    }

    def carsCount = carTypes.count

    private val carsObstacleProcessor : Obstacle -> bool = (o : Obstacle) ->
        o.obstacleType ==  ObstacleType.light

    private def calculateCarPositions(rrState : RailroadState) {
        var frontConnector = _head.invert
        val carStates = cars.chain.reverse(when = _isBack).map{ car ->
            val tp : CarType = car.carType
            val fl = tp.startToWheel
            val bl = tp.wheelToEnd
            val head = rrState.moveWith(carsObstacleProcessor, if(_isBack) bl else fl, frontConnector).addErrorToPoint
            val tail = rrState.moveWith(carsObstacleProcessor, tp.betweenWheels, head).addErrorToPoint
            val backConnector = rrState.moveWith(carsObstacleProcessor, if(_isBack) fl else bl, tail).addErrorToPoint
            val fc = frontConnector

            frontConnector = backConnector
            if(_isBack) LiveCarState(car, backConnector, tail, head, fc)
            else LiveCarState(car, fc, head, tail, backConnector)
        }.reverse(when = _isBack).toArray
        _state = LiveTrainState(self, _time, _head, _isBack, carStates)
    }

    private def move(point : vec2, length : float) = vec2(point.x, point.y + length)

    static val chooNotification = NotificationHandle<Train, void>("chooNotification")
    def updateWith(rrState : RailroadState, delta : float) = future {
        if(!_isDying) {
            correct(rrState, rrState.moveWith(obstacleProcessor = trainType.obstacleProcessor(level, _state.cast<LiveTrainState>, _),
                forLength = delta*speedFloat, point = _head))
//            log("$_head")
        }
        _time += delta

        if(!_isDying) {
            if(_soundData.chooCounter > 0 && _soundData.toNextChoo <= 0.0) {
                chooNotification.post(self)
                _soundData.nextChoo
            } else {
                if(_head.tile != _soundData.lastTile) {
                    chooNotification.post(self)
                    _soundData.lastTile = _head.tile
                    _soundData.lastX = _head.x
                    _soundData.nextChoo
                } else if(_soundData.chooCounter > 0) {
                    _soundData.next(_head)
                }
            }
        }
    }

    private def correct(rrState : RailroadState, correction : RailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length - 0.5) {
                if(isMoveToCity && (color == CityColor.grey || level.cityFor(correction.point.tile).get.color == color)) {
                    if(correction.error >= length - 0.5) {
                        level.possiblyArrived(self, tile = correction.point.tile, tailX = length - correction.error)
                    }
                    _head = correction.addErrorToPoint
                } else {
                    _isBack = !_isBack
                    val lastCar = if(_isBack) _state.cast<LiveTrainState>.carStates.last else _state.cast<LiveTrainState>.carStates.head
                    _head = if(_isBack) lastCar.backConnector else lastCar.frontConnector
                }
            } else {
                _head = correction.addErrorToPoint
            }
        } else {
            _head = correction.point
        }
        calculateCarPositions(rrState)
    }


    private def isMoveToCityFor(point : RailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

   def isLocked(theSwitch : Switch) : Future<bool> = future {
        if(_isDying) return false

        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        val rp11 = theSwitch.railPoint1
        val rp12 = rp11.add(0.3)
        val rp21 = theSwitch.railPoint2
        val rp22 = rp21.add(0.3)
        _state.cast<LiveTrainState>.carStates.exists{p ->
            p.frontConnector.tile == tile && p.backConnector.tile == nextTile
            || p.frontConnector.tile == nextTile && p.backConnector.tile == tile
            || p.frontConnector.between(rp11, rp12)
            || p.backConnector.between(rp21, rp22)
        }
    }

    def lockedTiles : Future<Set<vec2i>> = future {
        val ret = MHashSet<vec2i>()
        if(!_isDying) {
            _state.cast<LiveTrainState>.carStates.for {p ->
                ret.append(p.head.tile)
                ret.append(p.tail.tile)
            }
        }
        ret
    }

    def isLocked(rail : Rail) : Future<bool> = future {
        !_isDying && _state.cast<LiveTrainState>.carStates.exists{car ->
            car.isOn(rail)
        }
    }

    def isEqual(train : Train) : bool = self === train
    def hash : uint = self.cast<uint>

//    def dealloc {
//        log("Dealloc train")
//    }
}

class TrainGenerator(trainType : TrainType, carsCount : [int], speed : [int], carTypes : [CarType]) {
    def generateCarTypes : [CarType] = {
        val count = carsCount.randomItem.get
        val engine = carTypes.chain.filter(_.isEngine).randomItem.get
        if(count <= 1) [engine]
        else (count - 1).range.chain.map(i -> carTypes.chain.filter(!_.isEngine).randomItem.get).prepend([engine]).toArray
    }
    def generateSpeed : uint = speed.randomItem.get
}

class TrainSoundData {
    var chooCounter = 0
    var toNextChoo = 0.0
    var lastTile = vec2i(0, 0)
    var lastX = 0.0

    def nextChoo {
        if(chooCounter == 0) {
            toNextChoo = 0.03
            chooCounter = 1
        } else if(chooCounter == 1) {
            chooCounter = 2
            toNextChoo = 0.15
        } else if(chooCounter == 2) {
            toNextChoo = 0.03
            chooCounter = 3
        } else if(chooCounter == 3) {
            chooCounter = 0
        }
    }

    def next(head : RailPoint) {
        toNextChoo -= (lastX - head.x).abs
        lastX = head.x
    }
}