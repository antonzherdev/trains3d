package com.antonzherdev.trains

import com.antonzherdev.eg._

enum TrainType(obstacleProcessor : (Level, Train, Obstacle) -> bool) {
    simple((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) level.destroy(train)
        false
    })
    crazy((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType !=  ObstacleType.light) {
            if(o.obstacleType == ObstacleType.end) {
                val point = train.head
                if(!(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))) {
                    false
                } else {
                    level.railroad.addDamageAt(point)
                    level.destroy(train)
                    false
                }
            } else {
                level.railroad.addDamageAt(train.head)
                level.destroy(train)
                false
            }
        } else true
    })
    fast((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.switch) {
            level.railroad.addDamageAt(o.point)
            level.destroy(train)
        } else if(o.obstacleType ==  ObstacleType.damage) level.destroy(train)
        false
    })
    repairer((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) {
            level.fixDamageAt(o.point)
            true
        } else false
    })
}

class Train(weak level : Level, trainType : TrainType, color : CityColor, __cars : (Train) ->[Car], speed : uint) extends Updatable {
    var viewData : any = nil
    var soundData : any = nil
    private var _head : RailPoint
    private var back = false
    def isBack = back
    val cars : [Car] = __cars(self)
    private val length : float = cars.chain.fold(0.0, (r, car) -> car.carType.fullLength + r)
    val speedFloat : float = 0.01 * speed
    var isDying = false

    def startFrom(city : City) {
        _head = city.startPoint
        calculateCarPositions
    }

    def description = "<Train: $trainType, $color>"

    def head = _head
    def set(head : RailPoint) {
        _head = head
        calculateCarPositions
    }
    private val carsObstacleProcessor : Obstacle -> bool = (o : Obstacle) ->
        o.obstacleType ==  ObstacleType.light

    private def calculateCarPositions {
        var frontConnector = _head.invert
        directedCars.for{ car ->
            val tp : CarType = car.carType
            val fl = tp.startToWheel
            val bl = tp.wheelToEnd
            val head = level.railroad.moveWith(carsObstacleProcessor, if(back) bl else fl, frontConnector).addErrorToPoint
            val tail = level.railroad.moveWith(carsObstacleProcessor, tp.betweenWheels, head).addErrorToPoint
            val backConnector = level.railroad.moveWith(carsObstacleProcessor, if(back) fl else bl, tail).addErrorToPoint
            car.set(position =
                if(back) CarPosition(backConnector, tail, head, frontConnector)
                else CarPosition(frontConnector, head, tail, backConnector))
            frontConnector = backConnector
        }
    }

    private def move(point : vec2, length : float) = vec2(point.x, point.y + length)

    private var _time : float = 0
    def time = _time
    def updateWith(delta : float) {
        correct(level.railroad.moveWith(obstacleProcessor = trainType.obstacleProcessor(level, self, _),
            forLength = delta*speedFloat, point = _head))
        _time += delta
    }

    private def directedCars : [Car] = if(back) cars.chain.reverse.toArray else cars

    private def correct(correction : RailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length - 0.5) {
                if(isMoveToCity && (color == CityColor.grey || level.cityFor(correction.point.tile).get.color == color)) {
                    if(correction.error >= length + 0.5) {
                        level.arrived(self)
                    } else {
                        _head = correction.addErrorToPoint
                    }
                } else {
                    back = !back
                    val lastCar = directedCars.head
                    _head = if(back) lastCar.position.backConnector else lastCar.position.frontConnector
                }
            } else {
                _head = correction.addErrorToPoint
            }
        } else {
            _head = correction.point
        }
        calculateCarPositions
    }

    def isIn(tile : vec2i) : bool = {
        cars.chain.exists{car -> car.position.isIn(tile)}
    }

    private def isMoveToCityFor(point : RailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

    def isLocked(theSwitch : Switch) : bool = {
        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        val rp11 = theSwitch.railPoint1
        val rp12 = rp11.add(0.3)
        val rp21 = theSwitch.railPoint2
        val rp22 = rp21.add(0.3)
        cars.find{car ->
            val p = car.position
            p.frontConnector.tile == tile && p.backConnector.tile == nextTile
            || p.frontConnector.tile == nextTile && p.backConnector.tile == tile
            || p.frontConnector.between(rp11, rp12)
            || p.backConnector.between(rp21, rp22)
        }.isDefined
    }

    def dealloc {
        log("Dealloc train")
    }
}

class TrainGenerator(trainType : TrainType, carsCount : [int], speed : [int], carTypes : [CarType]) {
    def generateCarsFor(train : Train) : [Car] = {
        val count = carsCount.randomItem.get
        val engine = Car(train, carTypes.chain.filter(_.isEngine).randomItem.get)
        if(count <= 1) [engine]
        else (count - 1).range.chain.map(i -> Car(train, carTypes.chain.filter(!_.isEngine).randomItem.get)).prepend([engine]).toArray
    }
    def generateSpeed : uint = speed.randomItem.get
}