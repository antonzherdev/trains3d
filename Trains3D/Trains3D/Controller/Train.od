package com.antonzherdev.trains

import com.antonzherdev.eg._

enum TrainType(obstacleProcessor : (Level, Train, Obstacle) -> bool) {
    simple((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) level.destroy(train)
        false
    })
    crazy((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType !=  ObstacleType.light) {
            if(o.obstacleType == ObstacleType.end) {
                val point = train.head
                if(!(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))) {
                    false
                } else {
                    level.railroad.addDamageAt(point)
                    level.destroy(train)
                    false
                }
            } else {
                level.railroad.addDamageAt(train.head)
                level.destroy(train)
                false
            }
        } else true
    })
    fast((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.switch) {
            level.railroad.addDamageAt(o.point)
            level.destroy(train)
        } else if(o.obstacleType ==  ObstacleType.damage) level.destroy(train)
        false
    })
    repairer((level : Level, train : Train, o : Obstacle) -> {
        if(o.obstacleType ==  ObstacleType.damage) {
            level.fixDamageAt(o.point)
            true
        } else false
    })
}

class TrainActor(_train : Train) extends TypedActor with Updatable {
    def trainType = _train.trainType
    def color = _train.color
    def speed = _train.speed
    def carsCount = _train.cars.count
    def time = _train.time
    def kinematicBodies : [RigidBody<Car>] = _train.cars.chain.map(_.kinematicBody).toArray
    def dynamicBodies : Future<[RigidBody<Car>]> = future {
        _train.cars.chain.map(_.dynamicBody).toArray
    }

    def updateWith(delta : float) = future {
        _train.updateWith(delta)
    }

    def set(head : RailPoint) = future {
        _train.head = head
    }

    def lockedTiles : Future<Set<vec2i>> = future {
        val ret = MutableHashSet<vec2i>()
        _train.cars.for {car ->
            ret.append(car.position.head.tile)
            ret.append(car.position.tail.tile)
        }
        ret
    }

    def isLocked(switch : Switch) : Future<bool> = future {
        _train.isLocked(switch)
    }

    def isLocked(rail : Rail) : Future<bool> = future {
        _train.isLocked(rail)
    }

    def startFrom(city : City) = future {
        _train.startFrom(city)
    }

    def die = prompt {
        _train.isDying = true
    }

    def isDying : Future<bool> = prompt{
        _train.isDying
    }

//    def cars : Future<[Car]> = prompt {
//        _train.cars
//    }

    def carPositions : Future<[CarPosition]> = prompt {
        _train.cars.chain.map(_.position).toArray
    }

    def carDynamicMatrix : Future<[(CarType, mat4)]> = prompt {
        _train.cars.chain.map{car ->
            (car.carType, car.dynamicBody.matrix)
        }.toArray
    }

    def writeKinematicMatrix : Future<void> = prompt{
        _train.cars.for(_.writeKinematicMatrix)
    }

    def smokeData<T>(creator : Smoke -> T) : Future<T> = prompt {
        if(_train.viewData == nil) {
            _train.viewData = creator(_train.smoke)
        }
        _train.viewData.cast<T>
    }
}

class Train(weak level : Level, trainType : TrainType, color : CityColor, __cars : (Train) -> [Car], speed : uint) extends  Updatable {
    var viewData : any = nil
    val soundData = TrainSoundData()
    private var _head : RailPoint
    private var back = false
    def isBack = back
    val cars : [Car] = __cars(self)
    val smoke = Smoke(self, level.weather)
    private val length : float = cars.chain.fold(0.0, (r, car) -> car.carType.fullLength + r)
    val speedFloat : float = 0.01 * speed
    var isDying = false

    def startFrom(city : City) {
        _head = city.startPoint
        calculateCarPositions
    }

    def description = "<Train: $trainType, $color>"

    def head = _head
    def set(head : RailPoint) {
        _head = head
        calculateCarPositions
    }
    private val carsObstacleProcessor : Obstacle -> bool = (o : Obstacle) ->
        o.obstacleType ==  ObstacleType.light

    private def calculateCarPositions {
        var frontConnector = _head.invert
        directedCars.for{ car ->
            val tp : CarType = car.carType
            val fl = tp.startToWheel
            val bl = tp.wheelToEnd
            val head = level.railroad.moveWith(carsObstacleProcessor, if(back) bl else fl, frontConnector).addErrorToPoint
            val tail = level.railroad.moveWith(carsObstacleProcessor, tp.betweenWheels, head).addErrorToPoint
            val backConnector = level.railroad.moveWith(carsObstacleProcessor, if(back) fl else bl, tail).addErrorToPoint
            car.set(position =
                if(back) CarPosition(car.carType, backConnector, tail, head, frontConnector)
                else CarPosition(car.carType, frontConnector, head, tail, backConnector))
            frontConnector = backConnector
        }
    }

    private def move(point : vec2, length : float) = vec2(point.x, point.y + length)

    private var _time : float = 0
    def time = _time

    static val chooNotification = NotificationHandle<Train, void>("chooNotification")
    def updateWith(delta : float) {
        if(!isDying) correct(level.railroad.moveWith(obstacleProcessor = trainType.obstacleProcessor(level, self, _),
            forLength = delta*speedFloat, point = _head))
        _time += delta

        if(soundData.chooCounter > 0 && soundData.toNextChoo <= 0.0) {
            chooNotification.post(self)
            soundData.nextChoo
        } else {
            if(_head.tile != soundData.lastTile) {
                chooNotification.post(self)
                soundData.lastTile = _head.tile
                soundData.lastX = _head.x
                soundData.nextChoo
            } else if(soundData.chooCounter > 0) {
                soundData.next(_head)
            }
        }

        smoke.updateWith(delta)
    }

    private def directedCars : [Car] = if(back) cars.chain.reverse.toArray else cars

    private def correct(correction : RailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length - 0.5) {
                if(isMoveToCity && (color == CityColor.grey || level.cityFor(correction.point.tile).get.color == color)) {
                    if(correction.error >= length + 0.7) {
                        level.arrived(self)
                    } else {
                        _head = correction.addErrorToPoint
                    }
                } else {
                    back = !back
                    val lastCar = directedCars.head
                    _head = if(back) lastCar.position.backConnector else lastCar.position.frontConnector
                }
            } else {
                _head = correction.addErrorToPoint
            }
        } else {
            _head = correction.point
        }
        calculateCarPositions
    }


    private def isMoveToCityFor(point : RailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

    def isLocked(theSwitch : Switch) : bool = {
        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        val rp11 = theSwitch.railPoint1
        val rp12 = rp11.add(0.3)
        val rp21 = theSwitch.railPoint2
        val rp22 = rp21.add(0.3)
        cars.find{car ->
            val p = car.position
            p.frontConnector.tile == tile && p.backConnector.tile == nextTile
            || p.frontConnector.tile == nextTile && p.backConnector.tile == tile
            || p.frontConnector.between(rp11, rp12)
            || p.backConnector.between(rp21, rp22)
        }.isDefined
    }

    def isLocked(rail : Rail) : bool = {
        cars.find{car ->
            car.position.isOn(rail)
        }.isDefined
    }

//    def dealloc {
//        log("Dealloc train")
//    }
}

class TrainGenerator(trainType : TrainType, carsCount : [int], speed : [int], carTypes : [CarType]) {
    def generateCarsFor(train : Train) : [Car] = {
        val count = carsCount.randomItem.get
        val engine = Car(train, carTypes.chain.filter(_.isEngine).randomItem.get)
        if(count <= 1) [engine]
        else (count - 1).range.chain.map(i -> Car(train, carTypes.chain.filter(!_.isEngine).randomItem.get)).prepend([engine]).toArray
    }
    def generateSpeed : uint = speed.randomItem.get
}

class TrainSoundData {
    var chooCounter = 0
    var toNextChoo = 0.0
    var lastTile = vec2i(0, 0)
    var lastX = 0.0

    def nextChoo {
        if(chooCounter == 0) {
            toNextChoo = 0.03
            chooCounter = 1
        } else if(chooCounter == 1) {
            chooCounter = 2
            toNextChoo = 0.15
        } else if(chooCounter == 2) {
            toNextChoo = 0.03
            chooCounter = 3
        } else if(chooCounter == 3) {
            chooCounter = 0
        }
    }

    def next(head : RailPoint) {
        toNextChoo -= (lastX - head.x).abs
        lastX = head.x
    }
}