import CNChain
import CNSet

import EGTypes
import EGMapIso
import EGCollisions
import EGSchedule

import TRCity
import TRTypes
import TRRailroad
import TRRailPoint
import TRTrain
import TRScore

class TRLevelRules(mapSize : EGSizeI, scoreRules : TRScoreRules, events : [(float, (TRLevel) -> void)])

class TRLevel(rules : TRLevelRules) extends EGController {
    val map : EGMapSso = EGMapSso(rules.mapSize)
    val score : TRScore = TRScore(rules.scoreRules)
    val railroad : TRRailroad = TRRailroad(map, score)
    private var _cities : [var TRCity] = []
    val schedule : EGSchedule = createSchedule
    def cities : [TRCity] = _cities
    private var _trains : [TRTrain] = []
    def trains = _trains

    private def createSchedule : EGSchedule = {
        val schedule = EGSchedule.new
        createNewCity
        createNewCity
        rules.events.for(t -> {
            val f = t.b
            schedule.schedule(event = f(self), after = t.a )
        })
        schedule
    }

    def createNewCity {
        val tile = map.partialTiles.chain.exclude(cities.chain.map(_.tile)).randomItem.get
        val city = TRCity(TRColor[cities.count], tile, randomCityDirectionFor(tile))
        railroad.tryAdd(TRRail(tile, city.angle.form))
        _cities.add(city)
    }

    private def randomCityDirectionFor(tile : EGPointI) = {
        val cut = map.cutRectFor(tile)
        TRCityAngle.values.chain.filter(a -> {
            val angle = a.angle
            {(angle == 0 && cut.x2 == 0 && cut.y2 == 0)
            || (angle == 90 && cut.x == 0 && cut.y2 == 0)
            || (angle == 180 && cut.x == 0 && cut.y == 0)
            || (angle == 270 && cut.x2 == 0 && cut.y == 0)}
        }).randomItem.get
    }

    private def run(train : TRTrain, fromCity : TRCity) {
        fromCity.expectedTrainAnimation = EGAnimation(3, {
            fromCity.expectedTrainAnimation = nil
            train.startFrom(fromCity)
            _trains += train
            score.run(train)
        })
    }

    def runTrainWith(generator : TRTrainGenerator) {
        val city = _cities.randomItem.get
        run(
            train = TRTrain(self, city.color, generator.generateCars, generator.generateSpeed),
            fromCity = _cities.chain.filter(_ != city).randomItem.get)
    }

    def testRun(train : TRTrain, fromPoint : TRRailPoint) {
        train.set(head = fromPoint)
        _trains += train
        score.run(train)
    }

    def runSample {
        val city0 = _cities[0]
        val city1 = _cities[1]
        run(TRTrain(self, city1.color, [TRCar.new, TRCar.new], 0.3), city0)
        run(TRTrain(self, city0.color, [TRCar.new], 0.6), city1)
    }

    def updateWith(delta : float) {
        score.updateWith(delta)
        _trains.for(_.updateWith(delta))
        _cities.for(_.updateWith(delta))
        processCollisions
        schedule.updateWith(delta)
    }

    def tryTurn(theSwitch : TRSwitch) {
        if(!isLocked(theSwitch)){
            theSwitch.turn
        }
    }

    private def isLocked(theSwitch : TRSwitch) : bool = _trains.find(_.isLocked(theSwitch)).isDefined

    def cityFor(tile : EGPointI) : TRCity? = _cities.find(_.tile == tile)

    def arrived(train : TRTrain) {
        _trains -= train
        score.arrived(train)
    }

    private def processCollisions {
        detectCollisions.for(collision ->
            collision.items.for(destroy(_))
        )
    }

    def detectCollisions : CNSet<EGCollision<TRTrain>> = {
        val carFigures = _trains.chain.flatMap(train -> train.cars.chain.map(car -> (train, car.figure))).toArray
        EGCollisions.collisionsFor(carFigures)
    }

    def destroy(train : TRTrain) {
        if(_trains.contains(train)) {
            _trains -= train
            score.destroyed(train)
        }
    }
}