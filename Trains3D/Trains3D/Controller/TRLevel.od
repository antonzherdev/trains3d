package com.antonzherdev.trains

import com.antonzherdev.eg._


class TRLevelRules(mapSize : EGVec2I, scoreRules : TRScoreRules, repairerSpeed : uint, events : [(float, (TRLevel) -> void)])

class TRLevel(rules : TRLevelRules) extends EGController {
    val map : EGMapSso = EGMapSso(rules.mapSize)
    val score : TRScore = TRScore(rules.scoreRules)
    val railroad : TRRailroad = TRRailroad(map, score)
    private var _cities = CNMutableArray<TRCity>()
    val schedule : EGSchedule = createSchedule
    def cities : [TRCity] = _cities
    private var _trains : [TRTrain] = []
    def trains = _trains
    private var _repairer : TRTrain? = nil
    def repairer = _repairer

    val collisionWorld = TRCollisionWorld()
    val dynamicWorld = TRDynamicWorld()

    private var _dyingTrains = CNMutableArray<TRTrain>()
    def dyingTrains : [TRTrain] = _dyingTrains


    private def createSchedule : EGSchedule = {
        val schedule = EGSchedule()
        createNewCity
        createNewCity
        rules.events.for(t -> {
            val f = t.b
            schedule.schedule(after = t.a, event = f(self))
        })
        schedule
    }

    def createNewCity {
        val tile = map.partialTiles.chain.exclude(cities.chain.map(_.tile)).randomItem.get
        val city = TRCity(TRColor[cities.count], tile, randomCityDirectionFor(tile))
        railroad.tryAdd(TRRail(tile, city.angle.form))
        _cities.add(city)
    }

    private def randomCityDirectionFor(tile : EGVec2I) = {
        val cut = map.cutRectFor(tile)
        TRCityAngle.values.chain.filter{a ->
            val angle = a.angle
            (angle == 0 && cut.x2 == 0 && cut.y2 == 0)
            || (angle == 90 && cut.x == 0 && cut.y2 == 0)
            || (angle == 180 && cut.x == 0 && cut.y == 0)
            || (angle == 270 && cut.x2 == 0 && cut.y == 0)
        }.randomItem.get
    }

    private def run(train : TRTrain, fromCity : TRCity) {
        fromCity.expectedTrainAnimation = EGAnimation(3, {
            fromCity.expectedTrainAnimation = nil
            train.startFrom(fromCity)
            add(train)
        })
    }

    private def add(train : TRTrain) {
        _trains += train
        score.run(train)
        collisionWorld.add(train)
        dynamicWorld.add(train)
    }

    def runTrainWith(generator : TRTrainGenerator) {
        val city = _cities.randomItem.get
        val train = TRTrain(self, generator.trainType, city.color, generator.generateCarsFor(_), generator.generateSpeed)
        run(train, fromCity = _cities.chain.filter(_ != city).randomItem.get)
    }

    def testRun(train : TRTrain, fromPoint : TRRailPoint) {
        train.set(head = fromPoint)
        add(train)
    }

    def updateWith(delta : float) {
        score.updateWith(delta)
        _trains.for(_.updateWith(delta))
        _cities.for(_.updateWith(delta))
        if(!trains.isEmpty) processCollisions
        if(!_dyingTrains.isEmpty) dynamicWorld.updateWith(delta)
        schedule.updateWith(delta)
    }

    def tryTurn(theSwitch : TRSwitch) {
        if(!isLocked(theSwitch)){
            theSwitch.turn
        }
    }

    private def isLocked(theSwitch : TRSwitch) : bool = _trains.find(_.isLocked(theSwitch)).isDefined

    def cityFor(tile : EGVec2I) : TRCity? = _cities.find(_.tile == tile)

    def arrived(train : TRTrain) {
        remove(train)
        score.arrived(train)
    }

    def processCollisions {
        detectCollisions.for(collision -> {
            collision.cars.for(destroy(_.train))
            railroad.addDamageAt(collision.railPoint)
        })
    }

    def detectCollisions = collisionWorld.detect

    def destroy(train : TRTrain) {
        if(_trains.contains(train)) {
            score.destroyed(train)
            train.isDying = true
            _trains -= train
            collisionWorld.remove(train)
            _dyingTrains.add(train)
            schedule.schedule(after = 5) {
                remove(train)
            }
        }
    }

    def remove(train : TRTrain) {
        _trains -= train
        collisionWorld.remove(train)
        dynamicWorld.remove(train)
        _dyingTrains.remove(train)
        _repairer = _repairer.filter(_ != train)
    }

    def runRepairerFrom(city : TRCity) {
        if(_repairer.isEmpty) {
            val train = TRTrain(self, TRTrainType.repairer, TRColor.grey, [TRCar(_, TRCarType.engine)], rules.repairerSpeed)
            run(train, city)
            _repairer = train
        }
    }
}