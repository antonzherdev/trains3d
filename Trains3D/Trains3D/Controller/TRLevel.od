import EGTypes
import EGMapIso

import TRCity
import TRTypes
import TRRailroad
import TRRailPoint
import TRTrain


class TRLevel(map : EGMapSso) {
    val railroad = TRRailroad(map)
    var cities : [TRCity] = appendNextCityTo(appendNextCityTo([])) | private set
    var trains : [TRTrain] = [] | private set

    private def appendNextCityTo(cities : [TRCity]) =  {
        val tile = map.partialTiles.exclude(cities.map(_.tile)).randomItem.get
        val city = TRCity(TRColor[cities.count], tile, randomCityDirectionFor(tile))
        railroad.tryAdd(TRRail(tile, city.angle.form))
        cities + city
    }

    private def randomCityDirectionFor(tile : EGIPoint) = {
        val cut = map.cutRectFor(tile)
        TRCityAngle.values.filter(a -> {
            val angle = a.angle
            {(angle == 0 && cut.right == 0 && cut.bottom == 0)
            || (angle == 90 && cut.left == 0 && cut.bottom == 0)
            || (angle == 180 && cut.left == 0 && cut.top == 0)
            || (angle == 270 && cut.right == 0 && cut.top == 0)}
        }).randomItem.get
    }

    def createNewCity {
        cities = appendNextCityTo(cities)
    }

    private def run(train : TRTrain, fromCity : TRCity) {
        train.startFrom(fromCity)
        trains += train
    }

    def runSample {
        val city0 = cities[0]
        val city1 = cities[1]
        run(TRTrain(self, city1.color, [TRCar, TRCar], 0.3), city0)
        run(TRTrain(self, city0.color, [TRCar], 0.6), city1)
    }

    def updateWith(delta : float) {
        trains.for(_.updateWith(delta))
    }

    def tryTurn(theSwitch : TRSwitch) {
        if(!isLocked(theSwitch)){
            theSwitch.turn
        }
    }

    private def isLocked(theSwitch : TRSwitch) : bool = trains.find(_.isLocked(theSwitch)).isDefined
}