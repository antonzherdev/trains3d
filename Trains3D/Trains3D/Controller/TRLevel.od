import CNChain
import CNSortBuilder
import CNSet

import EGTypes
import EGMapIso
import EGCollisions
import EGSchedule

import TRCity
import TRTypes
import TRRailroad
import TRRailPoint
import TRTrain
import TRScore

class TRLevelRules(mapSize : EGSizeI, scoreRules : TRScoreRules, repairerSpeed : uint, events : [(float, (TRLevel) -> void)])

class TRLevel(rules : TRLevelRules) extends EGController {
    val map : EGMapSso = EGMapSso(rules.mapSize)
    val score : TRScore = TRScore(rules.scoreRules)
    val railroad : TRRailroad = TRRailroad(map, score)
    private var _cities = CNMutableArray.new<TRCity>
    val schedule : EGSchedule = createSchedule
    def cities : [TRCity] = _cities
    private var _trains : [TRTrain] = []
    def trains = _trains
    private var _repairer : TRTrain? = nil
    def repairer = _repairer


    private def createSchedule : EGSchedule = {
        val schedule = EGSchedule.new
        createNewCity
        createNewCity
        rules.events.for(t -> {
            val f = t.b
            schedule.schedule(event = f(self), after = t.a )
        })
        schedule
    }

    def createNewCity {
        val tile = map.partialTiles.chain.exclude(cities.chain.map(_.tile)).randomItem.get
        val city = TRCity(TRColor[cities.count], tile, randomCityDirectionFor(tile))
        railroad.tryAdd(TRRail(tile, city.angle.form))
        _cities.add(city)
    }

    private def randomCityDirectionFor(tile : EGPointI) = {
        val cut = map.cutRectFor(tile)
        TRCityAngle.values.chain.filter(a -> {
            val angle = a.angle
            {(angle == 0 && cut.x2 == 0 && cut.y2 == 0)
            || (angle == 90 && cut.x == 0 && cut.y2 == 0)
            || (angle == 180 && cut.x == 0 && cut.y == 0)
            || (angle == 270 && cut.x2 == 0 && cut.y == 0)}
        }).randomItem.get
    }

    private def run(train : TRTrain, fromCity : TRCity) {
        fromCity.expectedTrainAnimation = EGAnimation(3, {
            fromCity.expectedTrainAnimation = nil
            train.startFrom(fromCity)
            _trains += train
            score.run(train)
        })
    }

    def runTrainWith(generator : TRTrainGenerator) {
        val city = _cities.randomItem.get
        run(
            train = TRTrain(self, generator.trainType, city.color, generator.generateCars, generator.generateSpeed),
            fromCity = _cities.chain.filter(_ != city).randomItem.get)
    }

    def testRun(train : TRTrain, fromPoint : TRRailPoint) {
        train.set(head = fromPoint)
        _trains += train
        score.run(train)
    }

    def updateWith(delta : float) {
        score.updateWith(delta)
        _trains.for(_.updateWith(delta))
        _cities.for(_.updateWith(delta))
        processCollisions
        schedule.updateWith(delta)
    }

    def tryTurn(theSwitch : TRSwitch) {
        if(!isLocked(theSwitch)){
            theSwitch.turn
        }
    }

    private def isLocked(theSwitch : TRSwitch) : bool = _trains.find(_.isLocked(theSwitch)).isDefined

    def cityFor(tile : EGPointI) : TRCity? = _cities.find(_.tile == tile)

    def arrived(train : TRTrain) {
        remove(train)
        score.arrived(train)
    }

    def processCollisions {
        detectCollisions.for(collision -> {
            collision.items.for(destroy(_.a))
            val car1 = collision.items.a.b
            val car2 = collision.items.b.b
            [car1.head, car1.tail].chain
                .mul([car2.head, car2.tail])
                .sortBy.asc(pair -> {
                    val x = pair.a
                    val y = pair.b
                    if(x.form == y.form && x.tile == y.tile) fabs(x.x - y.x)
                    else 1000
                }).endSort
                .map(_.a)
                .head
                .for(railroad.addDamageAt(_))
        })
    }



    def detectCollisions : CNSet<EGCollision<(TRTrain, TRCar)>> = {
        val carFigures = _trains.chain.flatMap(train -> train.cars.chain.map(car -> ((train, car), car.figure))).toArray
        EGCollisions.collisionsFor(carFigures)
    }

    def destroy(train : TRTrain) {
        if(_trains.contains(train)) {
            remove(train)
            score.destroyed(train)
        }
    }

    def remove(train : TRTrain) {
        _trains -= train
        _repairer = _repairer.filter(_ != train)
    }

    def runRepairerFrom(city : TRCity) {
        if(_repairer.isEmpty) {
            val train = TRTrain(self, TRTrainType.repairer, TRColor.grey, [TRCar.new], rules.repairerSpeed)
            run(train, city)
            _repairer = train
        }
    }
}