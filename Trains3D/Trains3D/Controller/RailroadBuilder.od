package com.antonzherdev.trains


class RailBuilding(tp : RailBuildingType, rail : Rail, progress : float4) {
    def isDestruction = tp == RailBuildingType.destruction
    def isConstruction = tp == RailBuildingType.construction
}

enum RailBuildingType {
    construction()
    destruction()
}

enum RailroadBuilderMode {
    simple()
    build()
    clear()
}

class RailroadBuilderState(notFixedRailBuilding : RailBuilding?, isLocked : bool, buildingRails : ImList<RailBuilding>, isBuilding : bool) {
    def isDestruction = notFixedRailBuilding.isDefined && notFixedRailBuilding.get.isDestruction
    def isConstruction = notFixedRailBuilding.isDefined && notFixedRailBuilding.get.isConstruction

    def lock = RailroadBuilderState(notFixedRailBuilding, isLocked = true, buildingRails, isBuilding)
    def railForUndo : Rail? = buildingRails.headOpt.map(_.rail)
    def set(isBuilding : bool) =  RailroadBuilderState(notFixedRailBuilding, isLocked, buildingRails, isBuilding)
}


class RailroadBuilder(weak level : Level) extends Actor {
    var _startedPoint : vec2? = nil

    weak val _railroad : Railroad = level.railroad
    var _state : RailroadBuilderState = RailroadBuilderState(
        notFixedRailBuilding = nil, isLocked = false, buildingRails = ImList<RailBuilding>(), isBuilding = false)
    def state = prompt{
        _state
    }
    private var _isLocked = false
    def isLocked = _isLocked

    private def tryBuild(rlState : RailroadState, rail : Rail) : bool = {
        if(_state.notFixedRailBuilding.map(_.rail).contains(rail)) {
            true
        } else if(_mode != RailroadBuilderMode.clear && canAdd(rlState, rail)) {
            _state = RailroadBuilderState(
                notFixedRailBuilding = RailBuilding(RailBuildingType.construction, rail, progress = 0.0),
                isLocked = false,
                buildingRails = _state.buildingRails,
                isBuilding = _state.isBuilding
            )
            changed
            true
        } else if(_mode == RailroadBuilderMode.clear && rlState.rails.contains(rail)) {
            _state = RailroadBuilderState(
                notFixedRailBuilding = RailBuilding(RailBuildingType.destruction, rail, progress = 0.0),
                isLocked = _state.isLocked,
                buildingRails = _state.buildingRails,
                isBuilding = _state.isBuilding
            )
            changed
            level.isLocked(rail).onSuccess{ locked ->
                if(locked != _isLocked ) {
                    _state.lock
                    changed
                }
            }

            true
        } else {
            clear
            false
        }
    }

    static val changedNotification = NotificationHandle<RailroadBuilder, void>("Railroad builder changed")
    private def changed {
        changedNotification.post(self)
    }

    private def checkCity(rlState : RailroadState, tile : vec2i, connector : RailConnector) : bool = {
        val nextTile = connector.next(tile)
        _railroad.map.isFull(nextTile) || !rlState.contentIn(nextTile, connector.otherSideConnector).isEmpty
    }

    private def clear {
        if(_state.notFixedRailBuilding.isDefined) {
            _state = RailroadBuilderState(
                notFixedRailBuilding = nil,
                isLocked = false,
                buildingRails = _state.buildingRails,
                isBuilding = _state.isBuilding
            )
            changed
        }
    }

    private def fix {
        if(_isLocked) {
            clear
        } else if(_state.notFixedRailBuilding.isDefined) {
            val rb = _state.notFixedRailBuilding.get
            if(rb.isConstruction) {
                _railroad.forest.cutDownFor(rb.rail)
            } else {
                _railroad.remove(rb.rail)
                doSet(RailroadBuilderMode.simple)
            }
            _state = RailroadBuilderState(
                notFixedRailBuilding = nil,
                isLocked = false,
                buildingRails = ImList(rb, _state.buildingRails),
                isBuilding = _state.isBuilding
            )
            changed
        }
    }

    private def canAdd(rlState : RailroadState, rail : Rail) : bool =
        checkCity(rlState, rail.tile, rail.form.start) &&
        checkCity(rlState, rail.tile, rail.form.end) &&
        _railroad.map.isFull(rail.tile) &&
        checkBuildings(rlState, rail)

    private def checkBuildings(rlState : RailroadState, rail : Rail) : bool =
        !_state.buildingRails.exists(_.rail == rail)
        && rlState.canAdd(rail)
        && checkBuildingsConnector(rlState, rail.tile, rail.form.start)
        && checkBuildingsConnector(rlState, rail.tile, rail.form.end)

    private def checkBuildingsConnector(rlState : RailroadState, tile : vec2i, connector : RailConnector) : bool =
        (rlState.contentIn(tile, connector).rails.count
        + _state.buildingRails.chain.filter(_.rail.tile == tile && _.rail.form.contains(connector)).count) < 2


    def updateWith(delta : float) = future {
        _state = RailroadBuilderState(
            notFixedRailBuilding = _state.notFixedRailBuilding,
            isLocked = _state.isLocked,
            buildingRails = _state.buildingRails.chain.map{ b ->
                var p = b.progress
                val less = p < 0.5
                p += delta/4
                if(less && p > 0.5) changed
                RailBuilding(b.tp, b.rail, p)
            }.filter{b ->
                if(b.progress >= 1.0) {
                    if(b.isConstruction) _railroad.tryAdd(b.rail)
                    else _railroad.score.railRemoved
                    false
                } else true
            }.toList,
            isBuilding = _state.isBuilding
        )
        if(_state.isDestruction) {
            level.isLocked(_state.notFixedRailBuilding.get.rail).onSuccess{lk ->
                if(lk != _state.isLocked) {
                    _state = _state.lock
                    changed
                }
            }
        }
    }

    def undo = future {
        val r = _state.buildingRails.headOpt
        if(!r.isEmpty) {
            val rb = r.get
            if(rb.isDestruction) _railroad.tryAdd(rb.rail)
            _state = RailroadBuilderState(
                notFixedRailBuilding = _state.notFixedRailBuilding,
                isLocked = _state.isLocked,
                buildingRails = _state.buildingRails.tail,
                isBuilding = _state.isBuilding)
            changed
        }
    }

    static val modeNotification = NotificationHandle<RailroadBuilder, RailroadBuilderMode>("RailroadBuilder.modeNotification")
    var _mode : RailroadBuilderMode = RailroadBuilderMode.simple
    def mode = prompt{
        _mode
    }
    def modeBuildFlip = prompt {
        if(_mode == RailroadBuilderMode.build) _mode = RailroadBuilderMode.simple
        else _mode = RailroadBuilderMode.build
        modeNotification.post(self, _mode)
    }
    def modeClearFlip = prompt {
        if(_mode == RailroadBuilderMode.clear) _mode = RailroadBuilderMode.simple
        else _mode = RailroadBuilderMode.clear
        modeNotification.post(self, _mode)
    }
    def set(mode : RailroadBuilderMode) = prompt {
        doSet(mode)
    }
    private def doSet(mode : RailroadBuilderMode) {
        if(_mode != mode) {
            _mode = mode
            modeNotification.post(self, mode)
        }
    }

    static val refuseBuildNotification = NotificationHandle<RailroadBuilder, void>("refuseBuildNotification")
    var _firstTry : bool = true
    var _fixedStart : (vec2i, RailConnector)? = nil

    def began(location : vec2) = prompt {
        _startedPoint = location
        _firstTry = true
    }


    def changed(location : vec2) = lockAndOnSuccess(_railroad.state) {rlState ->
        val line = Line2(p0 = _startedPoint.get, p1 = location)

        val len = line.u.length
        if(len > 0.5) {
            if(!_state.isDestruction) {
                _state = _state.set(isBuilding = true)
                val nu = line.u.set(length = 1.0)
                val nl =
                if(_fixedStart.isDefined) Line2(p0 = line.p0, u = nu)
                else Line2(p0 = line.p0 - nu*0.25, u = nu)
                val mid = nl.mid
                val tile = mid.round
                val railOpt =
                    possibleRailsAround(tile)
                    .map{rail -> (rail, distanceBetween(rlState, rail, nl))}
                    .filter(_fixedStart.isEmpty || _.b < 0.8)
                    .sortBy.asc(_.b).endSort
                    .top(4)
                    .filter(canAdd(rlState, _.a) || _mode == RailroadBuilderMode.clear)
                    .headOpt

                if(railOpt.isDefined) {
                    _firstTry = true
                    val rail = railOpt.get.a
                    if(tryBuild(rlState, rail)) {
                        if(len > (if(_fixedStart.isDefined) 1.6 else 1) && _state.isConstruction) {
                            fix
                            val rl = rail.line
                            val la0 = rl.p0.sub(line.p0).lengthSquare
                            val la1 = rl.p0.sub(line.p1).lengthSquare
                            val lb0 = rl.p1.sub(line.p0).lengthSquare
                            val lb1 = rl.p1.sub(line.p1).lengthSquare
                            val end0 = la0 < lb0
                            val end1 = la1 > lb1
                            val end = if(end0 == end1) end0 else la1 > la0
                            _startedPoint = if(end) rl.p1 else rl.p0
                            val con = if(end) rail.form.end else rail.form.start
                            _fixedStart = (con.next(rail.tile), con.otherSideConnector)
                        }
                    }
                } else {
                    if(_firstTry) {
                        _firstTry = false
                        refuseBuildNotification.post(self)
                    }
                }
            }
        } else {
            _firstTry = true
            clear
        }
    }

    def ended = future {
        fix
        _firstTry = true
        _startedPoint = nil
        _fixedStart = nil
        _state = _state.set(isBuilding = false)
    }


    private def distanceBetween(rlState : RailroadState, rail : Rail, paintLine : Line2) : float = {
        val railLine = rail.line
        if(_fixedStart.isDefined) {
            ((if(paintLine.p0 == railLine.p0) railLine.p1 else railLine.p0) - paintLine.p1).lengthSquare
        } else {
            val p0d = (railLine.p0 - paintLine.p0).length.min((railLine.p0 - paintLine.p1).length)
            val p1d = (railLine.p1 - paintLine.p0).length.min((railLine.p1 - paintLine.p1).length)
            val d = railLine.u.dot(paintLine.n).abs + p0d + p1d
            val c = rail.form.connectors.chain.filter{connector ->
                !rlState.contentIn(connector.next(rail.tile), connector.otherSideConnector).isEmpty
            }.count
            val k = if(c == 1) 0.7 else if(c == 2) 0.6 else 1.0
            k*d
        }
    }


    private def possibleRailsAround(tile : vec2i) : Chain<Rail> =
        if(_fixedStart.isDefined)
        RailForm.values.chain.filter(_.contains(_fixedStart.get.b)).map(Rail(_fixedStart.get.a, _))
        else
        tilesAround(tile).chain.mul(RailForm.values).map{p ->Rail(p.a, p.b)}

    private def tilesAround(tile : vec2i) : [vec2i] =
        [tile
        , tile + vec2i(1, 0),  tile + vec2i(-1, 0),  tile + vec2i(0, 1),  tile + vec2i(0, -1)
        , tile + vec2i(1, 1),  tile + vec2i(-1, 1),  tile + vec2i(1, -1),  tile + vec2i(-1, -1)
        ]

    private def connectorsByDistanceFrom(point : vec2) : [RailConnector] =
        RailConnector.values.chain.sortBy.asc{connector ->
            (connector.vec*0.5 - point).lengthSquare
        }.endSort.toArray
}

