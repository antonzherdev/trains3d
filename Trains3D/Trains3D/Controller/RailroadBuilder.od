package com.antonzherdev.trains


class RailBuilding(tp : RailBuildingType, rail : Rail) {
    var progress = 0.0

    def isDestruction = tp == RailBuildingType.destruction
    def isConstruction = tp == RailBuildingType.construction
}

enum RailBuildingType {
    construction()
    destruction()
}


class RailroadBuilder(weak level : Level) extends Updatable {
    weak val railroad : Railroad = level.railroad
    var building = false
    private var _notFixedRailBuilding : RailBuilding? = nil
    def notFixedRailBuilding = _notFixedRailBuilding
    private var _isLocked = false
    def isLocked = _isLocked

    private val _buildingRails = MutableList<RailBuilding>()
    def buildingRails : [RailBuilding] = _buildingRails
    def railForUndo : Rail? = _buildingRails.headOpt.map(_.rail)
    def isDestruction = _notFixedRailBuilding.isDefined && _notFixedRailBuilding.get.isDestruction
    def isConstruction = _notFixedRailBuilding.isDefined && _notFixedRailBuilding.get.isConstruction

    def tryBuild(rail : Rail) : bool = {
        if(_notFixedRailBuilding.map(_.rail).contains(rail)) {
            true
        } else if(!clearMode && canAdd(rail)) {
            _notFixedRailBuilding = RailBuilding(RailBuildingType.construction, rail)
            _isLocked = false
            changed
            true
        } else if(clearMode && railroad.rails.contains(rail)) {
            _notFixedRailBuilding = RailBuilding(RailBuildingType.destruction, rail)
            changed
            level.isLocked(rail).onSuccess{ locked ->
                if(locked != _isLocked ) {
                    _isLocked = locked
                    changed
                }
            }

            true
        } else {
            if(_notFixedRailBuilding.isDefined) {
                _notFixedRailBuilding = nil
                changed
            }
            false
        }
    }

    static val changedNotification = NotificationHandle<RailroadBuilder, void>("Railroad builder changed")
    private def changed {
        changedNotification.post(self)
    }

    def checkCity(tile : vec2i, connector : RailConnector) : bool = {
        val nextTile = connector.next(tile)
        railroad.map.isFull(nextTile) || !railroad.contentIn(nextTile, connector.otherSideConnector).isEmpty
    }

    def clear {
        if(_notFixedRailBuilding.isDefined) {
            _notFixedRailBuilding = nil
            _isLocked = false
            changed
        }
    }

    def fix {
        if(_isLocked) {
            clear
        } else if(_notFixedRailBuilding.isDefined) {
            val rb = _notFixedRailBuilding.get
            if(rb.isConstruction) {
                railroad.forest.cutDownFor(rb.rail)
            } else {
                railroad.remove(rb.rail)
                set(clearMode = false)
            }
            _buildingRails.prepend(rb)
            _notFixedRailBuilding = nil
            _isLocked = false
            changed
        }
    }

    def canAdd(rail : Rail) : bool =
        checkCity(rail.tile, rail.form.start) &&
        checkCity(rail.tile, rail.form.end) &&
        railroad.map.isFull(rail.tile) &&
        checkBuildings(rail)

    private def checkBuildings(rail : Rail) : bool =
        !_buildingRails.exists(_.rail == rail)
        && railroad.canAdd(rail)
        && checkBuildingsConnector(rail.tile, rail.form.start)
        && checkBuildingsConnector(rail.tile, rail.form.end)

    private def checkBuildingsConnector(tile : vec2i, connector : RailConnector) : bool =
        (railroad.contentIn(tile, connector).rails.count
        + _buildingRails.chain.filter(_.rail.tile == tile && _.rail.form.contains(connector)).count) < 2


    def updateWith(delta : float) {
        var hasEnd = false
        _buildingRails.for{b ->
            var p = b.progress
            val less = p < 0.5
            p += delta/4
            if(less && p > 0.5) changed
            hasEnd = (hasEnd || p >= 1.0)
            b.progress = p
        }
        if(hasEnd) {
            _buildingRails.mutableFilter{b ->
                if(b.progress >= 1.0) {
                    if(b.isConstruction) railroad.tryAdd(b.rail)
                    else railroad.score.railRemoved

                    false
                } else true
            }
            changed
        }
        if(isDestruction) {
            level.isLocked(_notFixedRailBuilding.get.rail).onSuccess{lk ->
                if(lk != _isLocked) {
                    _isLocked = lk
                    changed
                }
            }
        }
    }

    def undo {
        if(!_buildingRails.isEmpty) {
            val rb = _buildingRails.head
            if(rb.isDestruction) railroad.tryAdd(rb.rail)
            _buildingRails.removeHead
            changed
        }
    }

    static val buildModeNotification = NotificationHandle<RailroadBuilder, void>("buildModeNotification")
    private var _buildMode : bool = false
    def buildMode = _buildMode
    def set(buildMode : bool) {
        if(_buildMode != buildMode) {
            _buildMode = buildMode
            buildModeNotification.post(self)
        }
    }

    static val clearModeNotification = NotificationHandle<RailroadBuilder, void>("clearModeNotification")
    private var _clearMode : bool = false
    def clearMode = _clearMode
    def set(clearMode : bool) {
        if(_clearMode != clearMode) {
            _clearMode = clearMode
            clearModeNotification.post(self)
        }
    }
}

