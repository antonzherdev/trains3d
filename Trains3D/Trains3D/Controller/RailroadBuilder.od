package com.antonzherdev.trains


class RailBuilding(tp : RailBuildingType, rail : Rail) {
    var progress = 0.0

    def isDestruction = tp == RailBuildingType.destruction
    def isConstruction = tp == RailBuildingType.construction
}

enum RailBuildingType {
    construction()
    destruction()
}


class RailroadBuilder(weak level : Level) extends Updatable {
    private var startedPoint : vec2? = nil

    weak val railroad : Railroad = level.railroad
    var building = false
    private var _notFixedRailBuilding : RailBuilding? = nil
    def notFixedRailBuilding = _notFixedRailBuilding
    private var _isLocked = false
    def isLocked = _isLocked

    private val _buildingRails = MList<RailBuilding>()
    def buildingRails : Seq<RailBuilding> = _buildingRails
    def railForUndo : Rail? = _buildingRails.headOpt.map(_.rail)
    def isDestruction = _notFixedRailBuilding.isDefined && _notFixedRailBuilding.get.isDestruction
    def isConstruction = _notFixedRailBuilding.isDefined && _notFixedRailBuilding.get.isConstruction

    def tryBuild(rail : Rail) : bool = {
        if(_notFixedRailBuilding.map(_.rail).contains(rail)) {
            true
        } else if(!clearMode && canAdd(rail)) {
            _notFixedRailBuilding = RailBuilding(RailBuildingType.construction, rail)
            _isLocked = false
            changed
            true
        } else if(clearMode && railroad.rails.contains(rail)) {
            _notFixedRailBuilding = RailBuilding(RailBuildingType.destruction, rail)
            changed
            level.isLocked(rail).onSuccess{ locked ->
                if(locked != _isLocked ) {
                    _isLocked = locked
                    changed
                }
            }

            true
        } else {
            if(_notFixedRailBuilding.isDefined) {
                _notFixedRailBuilding = nil
                changed
            }
            false
        }
    }

    static val changedNotification = NotificationHandle<RailroadBuilder, void>("Railroad builder changed")
    private def changed {
        changedNotification.post(self)
    }

    def checkCity(tile : vec2i, connector : RailConnector) : bool = {
        val nextTile = connector.next(tile)
        railroad.map.isFull(nextTile) || !railroad.state.contentIn(nextTile, connector.otherSideConnector).isEmpty
    }

    def clear {
        if(_notFixedRailBuilding.isDefined) {
            _notFixedRailBuilding = nil
            _isLocked = false
            changed
        }
    }

    def fix {
        if(_isLocked) {
            clear
        } else if(_notFixedRailBuilding.isDefined) {
            val rb = _notFixedRailBuilding.get
            if(rb.isConstruction) {
                railroad.forest.cutDownFor(rb.rail)
            } else {
                railroad.remove(rb.rail)
                set(clearMode = false)
            }
            _buildingRails.prepend(rb)
            _notFixedRailBuilding = nil
            _isLocked = false
            changed
        }
    }

    def canAdd(rail : Rail) : bool =
        checkCity(rail.tile, rail.form.start) &&
        checkCity(rail.tile, rail.form.end) &&
        railroad.map.isFull(rail.tile) &&
        checkBuildings(rail)

    private def checkBuildings(rail : Rail) : bool =
        !_buildingRails.exists(_.rail == rail)
        && railroad.state.canAdd(rail)
        && checkBuildingsConnector(rail.tile, rail.form.start)
        && checkBuildingsConnector(rail.tile, rail.form.end)

    private def checkBuildingsConnector(tile : vec2i, connector : RailConnector) : bool =
        (railroad.state.contentIn(tile, connector).rails.count
        + _buildingRails.chain.filter(_.rail.tile == tile && _.rail.form.contains(connector)).count) < 2


    def updateWith(delta : float) {
        var hasEnd = false
        _buildingRails.for{b ->
            var p = b.progress
            val less = p < 0.5
            p += delta/4
            if(less && p > 0.5) changed
            hasEnd = (hasEnd || p >= 1.0)
            b.progress = p
        }
        if(hasEnd) {
            _buildingRails.mutableFilter{b ->
                if(b.progress >= 1.0) {
                    if(b.isConstruction) railroad.tryAdd(b.rail)
                    else railroad.score.railRemoved

                    false
                } else true
            }
            changed
        }
        if(isDestruction) {
            level.isLocked(_notFixedRailBuilding.get.rail).onSuccess{lk ->
                if(lk != _isLocked) {
                    _isLocked = lk
                    changed
                }
            }
        }
    }

    def undo {
        if(!_buildingRails.isEmpty) {
            val rb = _buildingRails.head
            if(rb.isDestruction) railroad.tryAdd(rb.rail)
            _buildingRails.removeHead
            changed
        }
    }

    static val buildModeNotification = NotificationHandle<RailroadBuilder, void>("buildModeNotification")
    private var _buildMode : bool = false
    def buildMode = _buildMode
    def set(buildMode : bool) {
        if(_buildMode != buildMode) {
            _buildMode = buildMode
            buildModeNotification.post(self)
        }
    }

    static val clearModeNotification = NotificationHandle<RailroadBuilder, void>("clearModeNotification")
    private var _clearMode : bool = false
    def clearMode = _clearMode
    def set(clearMode : bool) {
        if(_clearMode != clearMode) {
            _clearMode = clearMode
            clearModeNotification.post(self)
        }
    }

    static val refuseBuildNotification = NotificationHandle<RailroadBuilderProcessor, void>("refuseBuildNotification")
    private var firstTry : bool = true
    private var fixedStart : (vec2i, RailConnector)? = nil

    def began(location : vec2) {
        startedPoint = location
        firstTry = true
    }


    def changed(location : vec2) {
        val line = Line2(p0 = startedPoint.get, p1 = location)

        val len = line.u.length
        if(len > 0.5) {
            if(!isDestruction) {
                building = true
                val nu = line.u.set(length = 1.0)
                val nl =
                if(fixedStart.isDefined) Line2(p0 = line.p0, u = nu)
                else Line2(p0 = line.p0 - nu*0.25, u = nu)
                val mid = nl.mid
                val tile = mid.round
                val railOpt =
                    possibleRailsAround(tile)
                    .map{rail -> (rail, distanceBetween(rail, nl))}
                    .filter(fixedStart.isEmpty || _.b < 0.8)
                    .sortBy.asc(_.b).endSort
                    .top(4)
                    .filter(canAdd(_.a) || clearMode)
                    .headOpt

                if(railOpt.isDefined) {
                    firstTry = true
                    val rail = railOpt.get.a
                    if(tryBuild(rail)) {
                        if(len > (if(fixedStart.isDefined) 1.6 else 1) && isConstruction) {
                            fix
                            val rl = rail.line
                            val la0 = rl.p0.sub(line.p0).lengthSquare
                            val la1 = rl.p0.sub(line.p1).lengthSquare
                            val lb0 = rl.p1.sub(line.p0).lengthSquare
                            val lb1 = rl.p1.sub(line.p1).lengthSquare
                            val end0 = la0 < lb0
                            val end1 = la1 > lb1
                            val end = if(end0 == end1) end0 else la1 > la0
                            startedPoint = if(end) rl.p1 else rl.p0
                            val con = if(end) rail.form.end else rail.form.start
                            fixedStart = (con.next(rail.tile), con.otherSideConnector)
                        }
                    }
                } else {
                    if(firstTry) {
                        firstTry = false
                        refuseBuildNotification.post(self)
                    }
                }
            }
        } else {
            firstTry = true
            clear
        }
    }

    def ended {
        fix
        firstTry = true
        startedPoint = nil
        fixedStart = nil
        building = false
    }


    private def distanceBetween(rail : Rail, paintLine : Line2) : float = {
        val railLine = rail.line
        if(fixedStart.isDefined) {
            ((if(paintLine.p0 == railLine.p0) railLine.p1 else railLine.p0) - paintLine.p1).lengthSquare
        } else {
            val p0d = (railLine.p0 - paintLine.p0).length.min((railLine.p0 - paintLine.p1).length)
            val p1d = (railLine.p1 - paintLine.p0).length.min((railLine.p1 - paintLine.p1).length)
            val d = railLine.u.dot(paintLine.n).abs + p0d + p1d
            val c = rail.form.connectors.chain.filter{connector ->
                !railroad.state.contentIn(connector.next(rail.tile), connector.otherSideConnector).isEmpty
            }.count
            val k = if(c == 1) 0.7 else if(c == 2) 0.6 else 1.0
            k*d
        }
    }


    private def possibleRailsAround(tile : vec2i) : Chain<Rail> =
        if(fixedStart.isDefined)
        RailForm.values.chain.filter(_.contains(fixedStart.get.b)).map(Rail(fixedStart.get.a, _))
        else
        tilesAround(tile).chain.mul(RailForm.values).map{p ->Rail(p.a, p.b)}

    private def tilesAround(tile : vec2i) : [vec2i] =
        [tile
        , tile + vec2i(1, 0),  tile + vec2i(-1, 0),  tile + vec2i(0, 1),  tile + vec2i(0, -1)
        , tile + vec2i(1, 1),  tile + vec2i(-1, 1),  tile + vec2i(1, -1),  tile + vec2i(-1, -1)
        ]

    private def connectorsByDistanceFrom(point : vec2) : [RailConnector] =
        RailConnector.values.chain.sortBy.asc{connector ->
            (connector.vec*0.5 - point).lengthSquare
        }.endSort.toArray
}

