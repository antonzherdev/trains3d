package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class TrainsCollisionWorld(weak level : Level) extends TypedActor {
    val world = CollisionWorld<(TrainActor, int)>()
    val bodies = MutableHashMap<TrainActor, [CollisionBody<(TrainActor, int)>]>()

    def add(train : TrainActor) {
        train.carPositions.onSuccess(actor.add(train, _))
    }

    private def add(train : TrainActor, carPositions : [CarPosition]) = prompt {
        var i = 0
        bodies.set(key = train, value = carPositions.chain.map{pos ->
            val body = CollisionBody((train, i), pos.carType.collision2dShape, isKinematic = true)
            i++
            body.matrix = pos.matrix
            world.add(body)
            body
        }.toArray)
    }

    def remove(train : TrainActor) = prompt {
        bodies.take(key = train).for{bodies ->
            bodies.for(world.remove(_))
        }
    }

    def detect : Future<[CarsCollision]> =
        level.trainActors.chain.map{train ->
            train.carPositions.map((train, _))
        }.future(_.toMap).flatMap(actor._detect(_))

    def _detect(positionsMap : [TrainActor : [CarPosition]]) : Future<[CarsCollision]> = future {
        positionsMap.for{t ->
            bodies.get(t.a, orValue = []).chain.zipFor(t.b) {body, pos ->
                body.matrix = pos.matrix
            }
        }
        world.detect.chain.flatMap<CarsCollision>{collision ->
            if(collision.contacts.all(isOutOfMap(_))) return Option.none<CarsCollision>

            val t1 = collision.bodies.a.data
            val t2 = collision.bodies.b.data
            val car1 : CarPosition = positionsMap.apply(t1.a).apply(t1.b)
            val car2 : CarPosition = positionsMap.apply(t2.a).apply(t2.b)

            val point =
            [car1.head, car1.tail].chain
                .mul([car2.head, car2.tail])
                .sortBy.asc{pair ->
                    val x = pair.a
                    val y = pair.b
                    if(x.form == y.form && x.tile == y.tile) (x.x - y.x).abs
                    else 1000
                }.endSort
                .map(_.a)
                .head
            Option.some(CarsCollision([t1.a, t2.a].chain.toSet, point))
        }.toArray
    }

    private def isOutOfMap(contact : Contact) : bool =
        level.map.distanceToMap(contact.a.xy).length > 0.5 && level.map.distanceToMap(contact.b.xy).length > 0.5
}

class CarsCollision(trains : Set<TrainActor>, railPoint : RailPoint)

class TrainsDynamicWorld(weak level : Level) extends TypedActor {
    val world = {
        val w = DynamicWorld<Weak<Car>>(gravity = vec3(0, 0, -10))
        val plane = RigidBody<Weak<Car>>(nil, CollisionPlane(vec3(0, 0, 1), 0), false, 0)
        plane.friction = 0.4
        w.add(plane)
        level.forest.trees.for{ tree ->
            tree.body.for(w.add(_))
        }
        w
    }

    private val cutDownObs = Tree.cutDownNotification.observe{ tree, _ -> actor.cutDown(tree)}
    def cutDown(tree : Tree) = prompt {
        tree.body.for{b -> world.remove(b)}
    }

    def add(city : City) = prompt {
        city.bodies.for(world.add(_))
    }

    def add(train : TrainActor) = prompt {
        train.kinematicBodies.for{body ->
            world.add(body)
        }
    }

    var workCounter = 0
    def die(train : TrainActor) = prompt {
        workCounter++
        train.kinematicBodies.for{body ->
            world.remove(body)
        }
        train.dynamicBodies.onSuccess(actor.addDynamic(_))
    }

    def addDynamic(bodies : [RigidBody<Car>]) = prompt {
        bodies.for(world.add(_))
    }

    def remove(train : TrainActor) = prompt{
        train.isDying.onSuccess{isDying ->
            if(isDying) actor.removeDiedTrain(train)
            else actor.removeAliveTrain(train)
        }
    }

    def removeAliveTrain(train : TrainActor) = prompt{
        train.kinematicBodies.for{body ->
            world.remove(body)
        }
    }

    def removeDiedTrain(train : TrainActor) = prompt{
        workCounter--
        train.dynamicBodies.onSuccess(actor.removeDynamic(_))
    }

    def removeDynamic(bodies : [RigidBody<Car>]) = prompt{
        bodies.for(world.remove(_))
    }


    static val carsCollisionNotification = NotificationHandle<Level, float4>("carsCollisionNotification")
    static val carAndGroundCollisionNotification = NotificationHandle<Level, float4>("carAndGroundCollisionNotification")
    def updateWith(delta : float) : Future<void> =
        if(workCounter > 0) {
            level.trainActors.chain.map(_.writeKinematicMatrix).voidFuture.flatMap(actor._updateWith(delta))
        } else {
            Future.successful<void>(nil)
        }

    def _updateWith(delta : float) = future {
        if(workCounter > 0) {
            world.updateWith(delta)
            world.newCollisions.for {collision ->
                if(collision.bodies.a.isKinematic && collision.bodies.b.isKinematic) return nil
                if(collision.bodies.a.isKinematic) {
                    level.knockDown(collision.bodies.a.data.get.train)
                } else if(collision.bodies.b.isKinematic) {
                    level.knockDown(collision.bodies.b.data.get.train)
                }
                if(collision.impulse > 0) {
                    if(collision.bodies.a.data == nil || collision.bodies.b.data == nil) {
                        carAndGroundCollisionNotification.post(level, collision.impulse)
                    } else {
                        carsCollisionNotification.post(level, collision.impulse)
                    }
                }
            }
        }
    }
}
