package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class TrainsCollisionWorld(map : MapSso) {
    private val world = CollisionWorld<Weak<Car>>()

    def add(train : Train) {
        train.cars.for{car ->
            world.add(car.collisionBody)
        }
    }

    def remove(train : Train) {
        train.cars.for{car ->
            world.remove(car.collisionBody)
        }
    }

    def detect : [CarsCollision] = world.detect.chain.flatMap<CarsCollision>{collision ->
        if(collision.contacts.all(isOutOfMap(_))) return Option.none<CarsCollision>

        val car1 = collision.bodies.a.data.get
        val car2 = collision.bodies.b.data.get

        val point =
            [car1.position.head, car1.position.tail].chain
                .mul([car2.position.head, car2.position.tail])
                .sortBy.asc{pair ->
                    val x = pair.a
                    val y = pair.b
                    if(x.form == y.form && x.tile == y.tile) (x.x - y.x).abs
                    else 1000
                }.endSort
                .map(_.a)
                .head
        Option.some(CarsCollision(Pair(car1, car2), point))
    }.toArray

    private def isOutOfMap(contact : Contact) : bool =
        map.distanceToMap(contact.a.xy).length > 0.1 && map.distanceToMap(contact.b.xy).length > 0.1
}

class CarsCollision(cars : Pair<Car>, railPoint : RailPoint)

class TrainsDynamicWorld(weak level : Level) extends Updatable {
    val world = {
        val w = DynamicWorld<Weak<Car>>(gravity = vec3(0, 0, -10))
        val plane = RigidBody<Weak<Car>>(nil, CollisionPlane(vec3(0, 0, 1), 0), false, 0)
        plane.friction = 0.4
        w.add(plane)
        level.forest.trees.for{ tree ->
            tree.body.for(w.add(_))
        }
        w
    }

    val cutDownObs = Tree.cutDownNotification.observe{ tree ->
        tree.body.for(world.remove(_))
    }

    def add(city : City) {
        city.bodies.for(world.add(_))
    }

    def add(train : Train) {
        train.cars.for{car ->
            world.add(car.kinematicBody)
        }
    }

    private var workCounter = 0
    def die(train : Train) {
        workCounter++
        train.cars.for{car ->
            world.remove(car.kinematicBody)
            world.add(car.dynamicBody)
        }
    }

    def remove(train : Train) {
        if(train.isDying) workCounter--
        train.cars.for{car ->
            if(train.isDying) world.remove(car.dynamicBody)
            else world.remove(car.kinematicBody)
        }
    }

    static val carsCollisionNotification = NotificationHandle<float4>("carsCollisionNotification")
    static val carAndGroundCollisionNotification = NotificationHandle<float4>("carAndGroundCollisionNotification")
    def updateWith(delta : float) {
        if(workCounter > 0) {
            world.updateWith(delta)
            world.newCollisions.for {collision ->
                if(collision.bodies.a.isKinematic && collision.bodies.b.isKinematic) return nil
                if(collision.bodies.a.isKinematic) {
                    level.knockDown(collision.bodies.a.data.get.train)
                } else if(collision.bodies.b.isKinematic) {
                    level.knockDown(collision.bodies.b.data.get.train)
                }
                if(collision.impulse > 0) {
                    if(collision.bodies.a.data == nil || collision.bodies.b.data == nil) {
                        carAndGroundCollisionNotification.post(collision.impulse)
                    } else {
                        carsCollisionNotification.post(collision.impulse)
                    }
                }
            }
        }
    }
}
