package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class EngineType(
    tubePos : vec3 //tube position relative to start of the car
)

enum CarType(
    width: float,
    height: float,
    weight : float,

    startToFront : float,
    frontToWheel : float,
    betweenWheels : float,
    wheelToBack : float,
    backToEnd : float,

    engineType : EngineType?)
{
    car(0.16, 0.3, 1,
        0.05, 0.06, 0.44, 0.06, 0.05, nil)
    engine(0.18, 0.3, 2,
        0.05, 0.14, 0.32, 0.22, 0.05,
        EngineType(tubePos = vec3(-0.07, 0, 0.5)))
    expressCar(0.16, 0.3, 1,
        0.05, 0.06, 0.44, 0.06, 0.05, nil)
    expressEngine(0.18, 0.3, 3,
        0.05, 0.14, 0.32, 0.19, 0.05,
        EngineType(tubePos = vec3(-0.03, 0, 0.35)))

    val startToWheel = startToFront + frontToWheel
    val wheelToEnd = wheelToBack + backToEnd
    val fullLength : float = startToWheel + betweenWheels + wheelToEnd
    def isEngine : bool = engineType.isDefined
    val collision2dShape : CollisionShape = CollisionBox2d(frontToWheel + betweenWheels + wheelToBack, width)
    val rigidShape : CollisionShape = CollisionBox(frontToWheel + betweenWheels + wheelToBack, width, height)
}

class Car(weak train : Train, carType : CarType) {
    val collisionBody = CollisionBody(Weak(self), carType.collision2dShape, isKinematic = true)
    val kinematicBody = RigidBody.kinematic(Weak(self), carType.collision2dShape)
    lazy val dynamicBody : RigidBody<Car> = {
        val line = position.line
        val len = line.u.length
        val vec = line.u
        val mid = midPoint
        val b = RigidBody.dynamic(Weak(self), carType.rigidShape, carType.weight)
        b.matrix = mat4.identity.translate(mid.x, mid.y, carType.height/2).rotate(line.degreeAngle, 0, 0, 1)
        val rnd = vec3(Float.rnd(-0.1, 0.1), Float.rnd(-0.1, 0.1), Float.rnd(0, 5))
        val vel = vec3(vec.mul(train.speedFloat/len*2), 0) + rnd
//        val vel = Vec3(vec.mul(train.speedFloat/len*2), 0)
        b.velocity = if(train.isBack) vel.negate else vel
        b.angularVelocity = vec3(Float.rnd(-5, 5), Float.rnd(-5, 5), Float.rnd(-5, 5))
        b
    }

    private var _position : CarPosition
    def position : CarPosition = _position
    def set(position : CarPosition) {
        _position = position
        val line = position.line
        val mid = midPoint
        val m = mat4.identity.translate(mid.x, mid.y, 0).rotate(line.degreeAngle, 0, 0, 1)
        collisionBody.matrix = m
        kinematicBody.matrix = m
    }

    def midPoint : vec2 = {
        val line = position.line
        if(carType.wheelToBack == carType.frontToWheel) line.p0 + line.u/2
        else {
            val u = line.u.set(length = line.u.length - (carType.wheelToBack - carType.frontToWheel))
            line.p0 + u/2
        }
    }

//    def dealloc {
//        log("Dealloc car")
//    }
}

struct CarPosition(frontConnector : RailPoint, head : RailPoint, tail : RailPoint, backConnector : RailPoint, line : Line2) {
    static def apply(frontConnector : RailPoint, head : RailPoint, tail : RailPoint, backConnector : RailPoint) : CarPosition =
        CarPosition(frontConnector, head, tail, backConnector, Line2(p0 = tail.point, p1 = head.point))

    def isIn(tile : vec2i) : bool = head.tile == tile || tail.tile == tile
}

