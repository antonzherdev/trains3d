package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class EngineType(
    tubePos : vec3 //tube position relative to start of the car
)

enum CarType(
    width: float,
    height: float,
    weight : float,

    startToFront : float,
    frontToWheel : float,
    betweenWheels : float,
    wheelToBack : float,
    backToEnd : float,

    engineType : EngineType?)
{
    car(0.18, 0.3, 1,
        0.05, 0.08, 0.44, 0.08, 0.05, nil)
    expressCar(0.18, 0.3, 1,
        0.05, 0.08, 0.44, 0.08, 0.05, nil)
    engine(0.2, 0.3, 2,
        0.05, 0.14, 0.32, 0.22, 0.05,
        EngineType(tubePos = vec3(-0.10, 0, 0.5)))
    expressEngine(0.2, 0.3, 2,
        0.05, 0.14, 0.32, 0.22, 0.05,
        EngineType(tubePos = vec3(-0.10, 0, 0.5)))

    val startToWheel = startToFront + frontToWheel
    val wheelToEnd = wheelToBack + backToEnd
    val fullLength : float = startToWheel + betweenWheels + wheelToEnd
    def isEngine : bool = engineType.isDefined
    val collision2dShape : CollisionShape = CollisionBox2d(frontToWheel + betweenWheels + wheelToBack, width)
    val rigidShape : CollisionShape = CollisionBox(frontToWheel + betweenWheels + wheelToBack, width, height)
}

class Car(weak train : Train, carType : CarType) {
    val collisionBody = CollisionBody(self, carType.collision2dShape, isKinematic = true)
    lazy val dynamicBody = {
        val line = position.line
        val len = line.length
        val vec = line.vec
        val mid = midPoint
        val b = RigidBody.dynamic(self, carType.rigidShape, carType.weight)
        b.matrix = mat4.identity.translate(mid.x, mid.y, carType.height/2).rotate(line.degreeAngle, 0, 0, 1)
        val rnd = vec3(Float.rnd(-0.1, 0.1), Float.rnd(-0.1, 0.1), Float.rnd(0, 5))
        val vel = vec3(vec.mul(train.speedFloat/len*2), 0) + rnd
//        val vel = Vec3(vec.mul(train.speedFloat/len*2), 0)
        b.velocity = if(train.isBack) vel.negate else vel
        b.angularVelocity = vec3(Float.rnd(-5, 5), Float.rnd(-5, 5), Float.rnd(-5, 5))
        b
    }

    private var _position : CarPosition
    def position : CarPosition = _position
    def set(position : CarPosition) {
        _position = position
        val line = position.line
        val mid = midPoint
        collisionBody.set(matrix = mat4.identity.translate(mid.x, mid.y, 0).rotate(line.degreeAngle, 0, 0, 1))
    }

    def midPoint =
        if(carType.wheelToBack == carType.frontToWheel) position.line.mid
        else {
            val line = position.line
            val len = line.length
            val vec = line.vec
            val dh = vec.mul(carType.frontToWheel/len)
            val dt = vec.mul(carType.wheelToBack/len)
            line.moveWith(dh.sub(dt).mul(0.5)).mid
        }
}

class CarPosition(frontConnector : RailPoint, head : RailPoint, tail : RailPoint, backConnector : RailPoint) {
    val line = LineSegment(tail.point, head.point)

    def isIn(tile : vec2i) : bool = head.tile == tile || tail.tile == tile
}

