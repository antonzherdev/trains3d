package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class EngineType(
    tubePos : vec3, //tube position relative to start of the car
    tubeSize : float
)

enum CarType(
    width: float,
    height: float,
    weight : float,

    startToFront : float,
    frontToWheel : float,
    betweenWheels : float,
    wheelToBack : float,
    backToEnd : float,

    engineType : EngineType?)
{
    car(0.16, 0.3, 1,
        0.05, 0.06, 0.44, 0.06, 0.05, nil)
    engine(0.18, 0.3, 2,
        0.05, 0.14, 0.32, 0.22, 0.05,
        EngineType(tubePos = vec3(-0.06, 0, 0.4), tubeSize = 3))
    expressCar(0.16, 0.3, 1,
        0.05, 0.06, 0.44, 0.06, 0.05, nil)
    expressEngine(0.18, 0.3, 3,
        0.05, 0.14, 0.32, 0.19, 0.05,
        EngineType(tubePos = vec3(-0.03, 0, 0.35), tubeSize = 1))

    val startToWheel = startToFront + frontToWheel
    val wheelToEnd = wheelToBack + backToEnd
    val fullLength : float = startToWheel + betweenWheels + wheelToEnd
    def isEngine : bool = engineType != nil
    val collision2dShape : CollisionShape = CollisionBox2d(frontToWheel + betweenWheels + wheelToBack, width)
    val rigidShape : CollisionShape = CollisionBox(frontToWheel + betweenWheels + wheelToBack, width, height)
}

class Car(weak train : Train, carType : CarType, number : uint) {
    def isEqual(car : Car) : bool = self === car
    override def hash : uint = self.cast<uint>
}


abstract class CarState(car : Car) {
    val carType = car.carType
    def matrix : mat4
}

case class DieCarState(car : Car, override matrix : mat4, velocity : vec3, angularVelocity : vec3) extends CarState(car)

case class LiveCarState(car : Car, frontConnector : RailPoint,
    head : RailPoint, tail : RailPoint, backConnector : RailPoint,
    line : Line2)
    extends CarState(car)
{
    static def apply(car : Car, frontConnector : RailPoint, head : RailPoint, tail : RailPoint, backConnector : RailPoint) : LiveCarState =
        LiveCarState(car, frontConnector, head, tail, backConnector, Line2(p0 = tail.point, p1 = head.point))

    def isOn(rail : Rail) : bool =
        (head.tile == rail.tile && head.form == rail.form) ||
        (tail.tile == rail.tile && tail.form == rail.form)

    val midPoint : vec2 = {
        val line = line
        if(carType.wheelToBack == carType.frontToWheel) line.p0 + line.u/2
        else {
            val u = line.u.set(length = line.u.length - (carType.wheelToBack - carType.frontToWheel))
            line.p0 + u/2
        }
    }

    override val matrix : mat4 = mat4.identity.translate(midPoint.x, midPoint.y, 0).rotate(line.degreeAngle, 0, 0, 1)
}

