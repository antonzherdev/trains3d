package com.antonzherdev.trains

import com.antonzherdev.eg._

class ScoreRules(initialScore : int, railCost : int, railRemoveCost : int,
    arrivedPrize : Train -> int, destructionFine : Train -> int,
    delayPeriod : float, // seconds for speed 30.
    delayFine : (Train, int) -> int,
    repairCost : int)

class Score(rules : ScoreRules, notifications : Notifications) extends Actor {
    def money : Var<int> = Var<int>(rules.initialScore)

    def railBuilt = prompt {
        money.update(_ - rules.railCost)
        notifications.notify(Loc.railBuilt(rules.railCost))
    }

    def railRemoved = prompt {
        money.update( _ - rules.railCost)
        notifications.notify(Loc.railRemoved(rules.railRemoveCost))
    }

    var _trains : [TrainScore] = []
    def run(train : Train) = prompt {
        _trains += TrainScore(train)
    }
    def arrived(train : Train) = prompt {
        val prize = rules.arrivedPrize(train)
        money.update(_ + prize)
        notifications.notify(Loc.trainArrived(train, prize))
        remove(train)
    }
    def destroyed(train : Train) = prompt {
        val fine = rules.destructionFine(train)
        money.update(_ - fine)
        notifications.notify(Loc.trainDestroyed(fine))
        remove(train)
    }
    def remove(train : Train) = prompt{
        _trains = _trains.chain.filter(_.train != train).toArray
    }
    def updateWith(delta : float) = future {
        _trains.for{ts ->
            ts.updateWith(delta)
            if(ts.needFineWith(rules.delayPeriod)) {
                val fine = ts.fineWith(rule = rules.delayFine)
                money.update(_ - fine)
                notifications.notify(Loc.trainDelayedFine(ts.train, fine))
            }
        }
    }
    def repairerCalled {

    }

    def damageFixed = prompt {
        if(rules.repairCost > 0) {
            money.update(_ - rules.repairCost)
            notifications.notify(Loc.damageFixedPayment(rules.repairCost))
        }
    }
}

class TrainScore(train : Train) extends Updatable {
    private var delayTime = 0.0
    private var fineCount = 0
    private val delayK = train.speed / 30.0

    def updateWith(delta : float) {
        delayTime += delta * delayK
    }

    def needFineWith(delayPeriod : float) : bool = delayTime >= delayPeriod

    def fineWith(rule : (Train, int) -> int) : int = {
        fineCount++
        delayTime = 0
        rule(train, fineCount)
    }
}