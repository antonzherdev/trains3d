package com.antonzherdev.trains

import com.antonzherdev.eg._

class ScoreRules(initialScore : int, railCost : int, railRemoveCost : int,
    arrivedPrize : Train -> int, destructionFine : Train -> int,
    delayPeriod : float, // seconds for speed 30.
    delayFine : (Train, int) -> int,
    repairCost : int)

class Score(rules : ScoreRules, notifications : Notifications) extends Updatable {
    private var _score : int = rules.initialScore
    def score : int = _score
    static val changedNotification = NotificationHandle<Score, int>("ScoreChangedNotification")

    def railBuilt {
        _score -= rules.railCost
        changedNotification.post(self, _score)
        notifications.notify(Loc.railBuilt(rules.railCost))
    }

    def railRemoved {
        _score -= rules.railCost
        changedNotification.post(self, _score)
        notifications.notify(Loc.railRemoved(rules.railRemoveCost))
    }

    private var trains : [TrainScore] = []
    def run(train : Train) {
        trains += TrainScore(train)
    }
    def arrived(train : Train) {
        val prize = rules.arrivedPrize(train)
        _score += prize
        changedNotification.post(self, _score)
        notifications.notify(Loc.trainArrived(train, prize))
        remove(train)
    }
    def destroyed(train : Train) {
        val fine = rules.destructionFine(train)
        _score -= fine
        changedNotification.post(self, _score)
        notifications.notify(Loc.trainDestroyed(fine))
        remove(train)
    }
    def remove(train : Train) {
        trains = trains.chain.filter(_.train != train).toArray
    }
    def updateWith(delta : float) {
        trains.for{ts ->
            ts.updateWith(delta)
            if(ts.needFineWith(rules.delayPeriod)) {
                val fine = ts.fineWith(rule = rules.delayFine)
                _score -= fine
                changedNotification.post(self, _score)
                notifications.notify(Loc.trainDelayedFine(ts.train, fine))
            }
        }
    }
    def repairerCalled {

    }

    def damageFixed {
        if(rules.repairCost > 0) {
            _score -= rules.repairCost
            changedNotification.post(self, _score)
            notifications.notify(Loc.damageFixedPayment(rules.repairCost))
        }
    }
}

class TrainScore(train : Train) extends Updatable {
    private var delayTime = 0.0
    private var fineCount = 0
    private val delayK = train.speed / 30.0

    def updateWith(delta : float) {
        delayTime += delta * delayK
    }

    def needFineWith(delayPeriod : float) : bool = delayTime >= delayPeriod

    def fineWith(rule : (Train, int) -> int) : int = {
        fineCount++
        delayTime = 0
        rule(train, fineCount)
    }
}