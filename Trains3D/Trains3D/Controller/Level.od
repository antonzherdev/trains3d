package com.antonzherdev.trains

import com.antonzherdev.eg._

class LevelRules(mapSize : vec2i, theme : LevelTheme, scoreRules : ScoreRules, weatherRules : WeatherRules,
    repairerSpeed : uint, sporadicDamagePeriod : uint, events : [(float, (Level) -> void)])

class Level(number : uint, rules : LevelRules) extends Actor with Controller {
    static val trainComingPeriod = 10
    val scale = Var<float>(1.0)

    val map : MapSso = MapSso(rules.mapSize)
    val notifications = Notifications()
    val score : Score = Score(rules.scoreRules, notifications)
    val weather = Weather(rules.weatherRules)
    val forest = Forest(map, rules.theme.forestRules, weather)
    val railroad : Railroad = Railroad(map, score, forest)
    val builder : RailroadBuilder = RailroadBuilder(self)
    private var _cities : [City] = []
    private val _schedule : Schedule = Schedule()
    def cities : Seq<City> = _cities
    private var _trains : [Train] = []
    def trains : Future<[Train]> = prompt{
        _trains
    }
    private var _repairer : Train? = nil
    def repairer = _repairer

    def init {
        var time = 0.0
        weak val ws = self
        rules.events.for{t ->
            val f = t.b
            time += t.a
            if(time == 0) {
                f(ws)
            } else {
                _schedule.schedule(after = time, event = f(ws))
            }
        }
    }

    val collisionWorld = TrainsCollisionWorld(self)
    val dynamicWorld = TrainsDynamicWorld(self)

    private var _dyingTrains = MArray<Train>()
    def dyingTrains : Future<Seq<Train>> = prompt{
        _dyingTrains
    }

    def schedule(after : float, event : () -> void) = prompt {
        _schedule.schedule(after, event)
    }

    private var _timeToNextDamage : float = Float.rnd(rules.sporadicDamagePeriod*0.75, rules.sporadicDamagePeriod*1.25)

    def create2Cities : Future<void> = onSuccess(railroad.state){rlState ->
        val city1 = doCreateNewCity(rlState, check = true)
        val cityTile1 = city1.tile
        doCreateNewCity(rlState, check = (tile, _) -> (tile - cityTile1).length > 2)
    }.cast<Future<void>>
    def createNewCity : Future<City> = onSuccess(railroad.state){rlState ->
        doCreateNewCity(rlState, check = true)
    }

    private def doCreateNewCity(rlState : RailroadState, check : (vec2i, CityAngle) -> bool) : City = {
        val c = rndCityTime(rlState, check)
        createCityWith(tile = c.a, direction = c.b)
    }

    private def hasCityIn(tile : vec2i) : bool = cities.exists(_.tile == tile)

    private def rndCityTime(rlState : RailroadState, check : (vec2i, CityAngle) -> bool ) : (vec2i, CityAngle) = {
        val chain = map.partialTiles.chain.exclude(cities.chain.map(_.tile)).mul(CityAngle.values).filter{t ->
            val cut = map.cutStateFor(t.a)
            val angle = t.b.angle
            (angle == 0 && cut.x2 == 0 && cut.y2 == 0)
            || (angle == 90 && cut.x == 0 && cut.y2 == 0)
            || (angle == 180 && cut.x == 0 && cut.y == 0)
            || (angle == 270 && cut.x2 == 0 && cut.y == 0)
        }.shuffle

        chain.filter{t ->
            val tile = t.a
            val dir = t.b
            val nextTile = dir.out.next(tile)

            !RailConnector.values.chain.filter(_ != dir.out.otherSideConnector).all{connector ->
                rlState.contentIn(nextTile, connector).is<Switch>
            }
            && !dir.in.otherSideConnector.neighbours.exists{ n ->
                hasCityIn(n.next(dir.in.next(tile)))
            }
            && !(map.isRight(tile) && (map.isTop(tile) || map.isBottom(tile)))
            && !(map.isLeft(tile) && map.isBottom(tile))
            && check(tile, dir)
        }.headOpt.getOrElse{chain.head}
    }

    static val buildCityNotification = NotificationHandle<Level, City>("buildCityNotification")
    private def createCityWith(tile : vec2i, direction : CityAngle) : City = {
        val city = City(CityColor[cities.count], tile, direction)
        forest.cutDown(tile)
        railroad.tryAdd(Rail(tile, city.angle.form), free = true)
        _cities += city
        dynamicWorld.add(city)
        buildCityNotification.post(self, city)
        if(_cities.count > 2) {
            notifications.notify(Loc.cityBuilt)
        }
        city
    }


    static val prepareToRunTrainNotification = NotificationHandle<Level, (Train, City)>("prepateToRunTrainNotification")
    static val expectedTrainNotification = NotificationHandle<Level, (Train, City)>("expectedTrainNotification")
    private def run(train : Train, fromCity : City) {
        fromCity.expectedTrain = train
        weak val ws = self
        weak val fs = fromCity
        weak val wt = train
        fromCity.expectedTrainCounter = Counter(trainComingPeriod, finish = {
            train.startFrom(fs)
            ws.add(wt)
            fs.expectedTrain = nil
        }).on(0.9, prepareToRunTrainNotification.post(ws, (wt, fs)))
        expectedTrainNotification.post(ws, (wt, fs))
    }

    private def lockedTiles : Future<Set<vec2i>> = _trains.chain.map(_.lockedTiles).future(_.flat.toSet)

    static val runTrainNotification = NotificationHandle<Level, Train>("runTrainNotification")
    private def add(train : Train) {
        _trains += train
        score.run(train)
        collisionWorld.add(train)
        dynamicWorld.add(train)
        runTrainNotification.post(self, train)
    }

    def runTrainWith(generator : TrainGenerator) = onSuccess(lockedTiles) {lts ->
        val fromCityOpt = _cities.chain.filter{c ->
            c.canRunNewTrain && !lts.contains(c.tile)
        }.randomItem
        if(fromCityOpt.isEmpty) {
            weak val ws = self
            _schedule.schedule(after = 1, ws.runTrainWith(generator))
            return nil
        }
        val fromCity = fromCityOpt.get
        val color =
            if(generator.trainType == TrainType.crazy) CityColor.grey
            else _cities.chain.filter(_ != fromCity).randomItem.get.color
        val train = Train(self, generator.trainType, color, generator.generateCarTypes, generator.generateSpeed)
        run(train, fromCity)
    }

    def testRun(train : Train, fromPoint : RailPoint) = future {
        train.set(head = fromPoint)
        add(train)
    }

    private var looseCounter = 0.0
    private var _resultSent = false
    def updateWith(delta : float) {
        doUpdateWith(delta)
    }

    private def doUpdateWith(delta : float) = future {
        railroad.state.onSuccess{rrState ->
            _trains.for(_.updateWith(rrState, delta))
            _dyingTrains.for(_.updateWith(rrState, delta))
        }

        score.updateWith(delta)
        _cities.for(_.updateWith(delta))

//        if(!_dyingTrains.isEmpty) dynamicWorld.updateWith(delta)
        builder.updateWith(delta)

        _schedule.updateWith(delta)
        weather.updateWith(delta)
        forest.updateWith(delta)
        slowMotionCounter.updateWith(delta)

        if(rules.sporadicDamagePeriod > 0) {
            _timeToNextDamage -= delta
            if(_timeToNextDamage <= 0) {
                addSporadicDamage
                _timeToNextDamage = Float.rnd(rules.sporadicDamagePeriod * 0.75, rules.sporadicDamagePeriod*1.25)
            }
        }
        if(score.money.value < 0) {
            looseCounter += delta
            if(looseCounter > 5 && !_resultSent) {
                _resultSent = true
                lose
            }
        } else {
            looseCounter = 0
            if(_schedule.isEmpty && _trains.isEmpty && _dyingTrains.isEmpty && _cities.all(_.canRunNewTrain) && !_resultSent) {
                _resultSent = true
                win
            }
        }

        if(!_trains.isEmpty) processCollisions
        dynamicWorld.updateWith(delta)
        lockedTiles.onSuccess{lts ->
            _cities.for{city ->
                if(city.expectedTrainCounter.isRunning.value) {
                    if(lts.contains(city.tile)) city.waitToRunTrain
                } else if(city.isWaitingToRunTrain.value) {
                    if(!lts.contains(city.tile)) city.resumeTrainRunning
                }
            }
        }
    }

    def tryTurn(switch : Switch) {
        isLocked(switch).onSuccess{locked ->
            if(!locked) railroad.turn(switch)
        }
    }

    def isLocked(theSwitch : Switch) : Future<bool> = trains.flatMap{trs -> trs.chain.map(_.isLocked(theSwitch)).future(_.or)}
    def isLocked(rail : Rail) : Future<bool> = trains.flatMap{trs -> trs.chain.map(_.isLocked(rail)).future(_.or)}

    def cityFor(tile : vec2i) : City? = _cities.find(_.tile == tile)

    def arrived(train : Train) = future {
        if(repairer.contains(train)) {
            score.remove(train)
        } else {
            score.arrived(train)
        }
        remove(train)
    }

    static val crashNotification = NotificationHandle<Level, Iterable<Train>>("Trains crashed")
    private var _crashCounter : uint = 0
    def processCollisions = future {
        detectCollisions.onSuccess{collisions -> collisions.for{collision ->
            collision.trains.for(doDestroy(_))
            _crashCounter = 2
            crashNotification.post(self, collision.trains)
            weak val ws = self
            _schedule.schedule(5) {
                ws.railroad.addDamageAt(collision.railPoint).onSuccess{pp ->
                    damageNotification.post(ws, pp)
                }
            }
        }}
    }

    static val knockDownNotification = NotificationHandle<Level, (Train, uint)>("Knock down crashed")
    def knockDown(train : Train) = future {
        if(_trains.contains(train)) {
            doDestroy(train)
            _crashCounter += 1
            knockDownNotification.post(self, (train, _crashCounter))
        }
    }

    static val damageNotification = NotificationHandle<Level, RailPoint>("damageNotification")
    static val sporadicDamageNotification = NotificationHandle<Level, RailPoint>("sporadicDamageNotification")
    def addSporadicDamage = onSuccess(railroad.state){rlState ->
        rlState.rails.randomItem.for {rail ->
            val p = RailPoint(rail.tile, rail.form, Float.rnd(0, rail.form.length), false)
            railroad.addDamageAt(p).onSuccess{pp ->
                sporadicDamageNotification.post(self, pp)
                damageNotification.post(self, pp)
            }
       }
    }

    def detectCollisions = collisionWorld.detect

    def destroy(train : Train) = future {
        if(_trains.contains(train)) {
            _crashCounter = 1
            crashNotification.post(self, [train])
            doDestroy(train)
        }
    }

    private def doDestroy(train : Train) {
        if(_trains.contains(train)) {
            score.destroyed(train)
            train.die
            _trains -= train
            collisionWorld.remove(train)
            _dyingTrains.append(train)
            dynamicWorld.die(train)
            weak val ws = self
            _schedule.schedule(after = 5) {
                ws.remove(train)
            }
        }
    }

    static val removeTrainNotification = NotificationHandle<Level, Train>("removeTrainNotification")
    private def remove(train : Train) {
        _trains -= train
        collisionWorld.remove(train)
        dynamicWorld.remove(train)
        _dyingTrains.remove(train)
        _repairer = _repairer.filter(_ != train)
        removeTrainNotification.post(self, train)
    }


    static val runRepairerNotification = NotificationHandle<Level, void>("runRepairerNotification")
    def runRepairerFrom(city : City) = future {
        if(_repairer.isEmpty) {
            score.repairerCalled
            val train = Train(self, TrainType.repairer, CityColor.grey, [CarType.engine], rules.repairerSpeed)
            run(train, city)
            _repairer = train
            runRepairerNotification.post(self)
        }
    }

    static val fixDamageNotification = NotificationHandle<Level, RailPoint>("fixDamageNotification")
    def fixDamageAt(point : RailPoint) = future {
        railroad.fixDamageAt(point)
        score.damageFixed
        fixDamageNotification.post(self, point)
    }

    val help = Var<Help?>(Option.none<Help>)
    def showHelp(text : string) {
        help.set(Help(text))
    }
    def clearHelp {
        help.set(Option.none<Help>)
    }

    val result = Var<LevelResult?>(Option.none<LevelResult>)
    static val winNotification = NotificationHandle<Level, void>("Level was passed")
    private def win {
        result.set(LevelResult(true))
        winNotification.post(self)
    }

    private def lose {
        result.set(LevelResult(false))
    }

//    def dealloc {
//        log("Dealloc level $number")
//    }

    var rate = false
    var slowMotionShop = 0
    var slowMotionCounter : Counter = EmptyCounter()
}

class Help(text : string)
class LevelResult(win : bool)

enum LevelTheme(background : string, forestRules : ForestRules, dark : bool) {
    forest("Grass", ForestRules(ForestType.Pine, thickness = 2), true)
    winter("Snow", ForestRules(ForestType.SnowPine, thickness = 2), false)
    leafForest("Grass2", ForestRules(ForestType.Leaf, thickness = 2), true)
    palm("PalmGrass", ForestRules(ForestType.Palm, thickness = 1.5), true)
}

class Notifications {
    private val queue = ConcurrentQueue<string>()

    def notify(notification : string) {
        queue.enqueue(notification)
    }

    def isEmpty = queue.isEmpty

    def take : string? = queue.dequeue
}

