package com.antonzherdev.trains

import com.antonzherdev.eg._

class LevelRules(mapSize : vec2i, theme : LevelTheme, scoreRules : ScoreRules, weatherRules : WeatherRules,
    repairerSpeed : uint, sporadicDamagePeriod : uint, events : [(float, (Level) -> void)])

class Level(number : uint, rules : LevelRules) extends Controller {
    static val trainComingPeriod = 10

    val map : MapSso = MapSso(rules.mapSize)
    val notifications = Notifications()
    val score : Score = Score(rules.scoreRules, notifications)
    val weather = Weather(rules.weatherRules)
    val forest = Forest(map, rules.theme.forestRules, weather)
    val railroad : Railroad = Railroad(map, score, forest)
    private var _cities = MutableArray<City>()
    val schedule : Schedule = createSchedule
    def cities : [City] = _cities
    private var _trains : [Train] = []
    def trains = _trains
    private var _repairer : Train? = nil
    def repairer = _repairer



    val collisionWorld = TrainsCollisionWorld(map)
    val dynamicWorld = TrainsDynamicWorld(self)

    private var _dyingTrains = MutableArray<Train>()
    def dyingTrains : [Train] = _dyingTrains

    private var _timeToNextDamage : float = Float.rnd(rules.sporadicDamagePeriod*0.75, rules.sporadicDamagePeriod*1.25)
    private def createSchedule : Schedule = {
        val schedule = Schedule()
        var time = 0.0
        rules.events.for(t -> {
            val f = t.b
            time += t.a
            schedule.schedule(after = time, event = f(self))
        })
        log("Schedule for level $number is $time seconds")
        schedule
    }

    def createNewCity {
        val tile = map.partialTiles.chain.exclude(cities.chain.map(_.tile)).randomItem.get
        createCityWith(tile = tile,
            direction = randomCityDirectionFor(tile))
    }

    static val buildCityNotification = NotificationHandle<(City)>("buildCityNotification")
    def createCityWith(tile : vec2i, direction : CityAngle) {
        val city = City(CityColor[cities.count], tile, direction)
        forest.cutDown(tile)
        railroad.add(Rail(tile, city.angle.form))
        _cities.append(city)
        buildCityNotification.post(city)
        if(_cities.count > 2) {
            notifications.notify(Loc.cityBuilt)
        }
    }

    private def randomCityDirectionFor(tile : vec2i) = {
        val cut = map.cutStateFor(tile)
        CityAngle.values.chain.filter{a ->
            val angle = a.angle
            (angle == 0 && cut.x2 == 0 && cut.y2 == 0)
            || (angle == 90 && cut.x == 0 && cut.y2 == 0)
            || (angle == 180 && cut.x == 0 && cut.y == 0)
            || (angle == 270 && cut.x2 == 0 && cut.y == 0)
        }.randomItem.get
    }

    static val prepareToRunTrainNotification = NotificationHandle<(Train, City)>("prepateToRunTrainNotification")
    static val expectedTrainNotification = NotificationHandle<(Train, City)>("expectedTrainNotification")
    private def run(train : Train, fromCity : City) {
        fromCity.expectedTrainColor = train.color
        fromCity.expectedTrainCounter = Counter(trainComingPeriod, finish = {
            train.startFrom(fromCity)
            add(train)
        }).on(0.9, prepareToRunTrainNotification.post((train, fromCity)))
        expectedTrainNotification.post((train, fromCity))
    }

    static val runTrainNotification = NotificationHandle<Train>("runTrainNotification")
    private def add(train : Train) {
        _trains += train
        score.run(train)
        collisionWorld.add(train)
        dynamicWorld.add(train)
        runTrainNotification.post(train)
    }

    def runTrainWith(generator : TrainGenerator) {
        val fromCityOpt = _cities.chain.filter{c ->
            c.canRunNewTrain && !trains.exists(_.isIn(c.tile))
        }.randomItem
        if(fromCityOpt.isEmpty) {
            schedule.schedule(after = 1, runTrainWith(generator))
            return nil
        }
        val fromCity = fromCityOpt.get
        val city = _cities.chain.filter(_ != fromCity).randomItem.get
        val train = Train(self, generator.trainType, city.color, generator.generateCarsFor(_), generator.generateSpeed)
        run(train, fromCity)
    }

    def testRun(train : Train, fromPoint : RailPoint) {
        train.set(head = fromPoint)
        add(train)
    }

    private var looseCounter = 0.0
    private var _resultSent = false
    def updateWith(delta : float) {
        score.updateWith(delta)
        _trains.for(_.updateWith(delta))
        _cities.for(_.updateWith(delta))
        if(!trains.isEmpty) processCollisions
//        if(!_dyingTrains.isEmpty) dynamicWorld.updateWith(delta)
        railroad.updateWith(delta)
        dynamicWorld.updateWith(delta)
        schedule.updateWith(delta)
        weather.updateWith(delta)
        forest.updateWith(delta)
        _cities.for{city ->
            if(city.expectedTrainCounter.isRunning) {
                if(_trains.exists(_.isIn(city.tile))) city.waitToRunTrain
            } else if(city.isWaitingToRunTrain) {
                if(!_trains.exists(_.isIn(city.tile))) city.resumeTrainRunning
            }
        }
        if(rules.sporadicDamagePeriod > 0) {
            _timeToNextDamage -= delta
            if(_timeToNextDamage <= 0) {
                addSporadicDamage
                _timeToNextDamage = Float.rnd(rules.sporadicDamagePeriod * 0.75, rules.sporadicDamagePeriod*1.25)
            }
        }
        if(score.score < 0) {
            looseCounter += delta
            if(looseCounter > 5 && !_resultSent) {
                _resultSent = true
                lose
            }
        } else {
            looseCounter = 0
            if(schedule.isEmpty && _trains.isEmpty && _dyingTrains.isEmpty && _cities.all(_.canRunNewTrain) && !_resultSent) {
                _resultSent = true
                win
            }
        }
    }

    def tryTurn(theSwitch : Switch) {
        if(!isLocked(theSwitch)){
            theSwitch.turn
        }
    }

    private def isLocked(theSwitch : Switch) : bool = _trains.find(_.isLocked(theSwitch)).isDefined

    def cityFor(tile : vec2i) : City? = _cities.find(_.tile == tile)

    def arrived(train : Train) {
        if(repairer.contains(train)) {
            score.remove(train)
        } else {
            score.arrived(train)
        }
        remove(train)
    }

    static val crashNotification = NotificationHandle<[Train]>("Trains crashed")
    private var _crashCounter : uint = 0
    def processCollisions {
        detectCollisions.for(collision -> {
            collision.cars.for(doDestroy(_.train))
            _crashCounter = 2
            crashNotification.post(collision.cars.chain.map(_.train).toArray)
            schedule.schedule(5) {
                railroad.addDamageAt(collision.railPoint)
                damageNotification.post(self)
            }
        })
    }

    static val knockDownNotification = NotificationHandle<(Train, uint)>("Knock down crashed")
    def knockDown(train : Train) {
        if(_trains.contains(train)) {
            doDestroy(train)
            _crashCounter += 1
            knockDownNotification.post((train, _crashCounter))
        }
    }

    static val damageNotification = NotificationHandle<Level>("damageNotification")

    static val sporadicDamageNotification = NotificationHandle<Level>("sporadicDamageNotification")
    def addSporadicDamage {
        railroad.rails.randomItem.for {rail ->
            railroad.addDamageAt(RailPoint(rail.tile, rail.form, Float.rnd(0, rail.form.length), false))
            sporadicDamageNotification.post(self)
            damageNotification.post(self)
        }
    }

    def detectCollisions = collisionWorld.detect

    def destroy(train : Train) {
        if(_trains.contains(train)) {
            _crashCounter = 1
            crashNotification.post([train])
            doDestroy(train)
        }
    }

    private def doDestroy(train : Train) {
        if(_trains.contains(train)) {
            score.destroyed(train)
            train.isDying = true
            _trains -= train
            collisionWorld.remove(train)
            _dyingTrains.append(train)
            dynamicWorld.die(train)
            schedule.schedule(after = 5) {
                remove(train)
            }
        }
    }

    def remove(train : Train) {
        _trains -= train
        collisionWorld.remove(train)
        dynamicWorld.remove(train)
        _dyingTrains.remove(train)
        _repairer = _repairer.filter(_ != train)
    }


    static val runRepairerNotification = NotificationHandle<Level>("runRepairerNotification")
    def runRepairerFrom(city : City) {
        if(_repairer.isEmpty) {
            score.repairerCalled
            val train = Train(self, TrainType.repairer, CityColor.grey, [Car(_, CarType.engine)], rules.repairerSpeed)
            run(train, city)
            _repairer = train
            runRepairerNotification.post(self)
        }
    }

    def fixDamageAt(point : RailPoint) {
        railroad.fixDamageAt(point)
        score.damageFixed
    }

    private var _help : Help? = nil
    def help = _help
    def showHelp(text : string) {
        _help = Help(text)
    }
    def clearHelp {
        _help = nil
    }

    private var _result : LevelResult? = nil
    def result = _result
    static val winNotification = NotificationHandle<Level>("Level was passed")
    def win {
        _result = LevelResult(true)
        winNotification.post(self)
    }

    def lose {
        _result = LevelResult(false)
    }
}

class Help(text : string)
class LevelResult(win : bool)

enum LevelTheme(background : string, forestRules : ForestRules) {
    forest("Grass.png", ForestRules(ForestType.Pine, thickness = 2))
    winter("Snow.png", ForestRules(ForestType.SnowPine, thickness = 2))
    leafForest("Grass2.png", ForestRules(ForestType.Leaf, thickness = 2))
    palm("PalmGrass.png", ForestRules(ForestType.Palm, thickness = 2))
}