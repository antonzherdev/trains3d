import EGTypes
import EGMapIso

import TRTypes
import TRCity
import TRLevel
import TRRailPoint
import TRRailroad

class TRTrain(weak level : TRLevel, color : TRColor, cars : [TRCar], speed : float) {
    private var head : TRRailPoint
    private var back = false
    private val carsDelta : float = 0.1
    private val length : float = cars.fold(((r, car) -> car.length + r + carsDelta), -1.0 * carsDelta)

    def startFrom(city : TRCity) {
        head = city.startPoint
        calculateCarPositions
    }

    private def calculateCarPositions {
        directedCars.fold((hl, car) -> {
            car.head = hl
            val next = level.railroad.move(consideringLights = false, forLength = car.length, point = hl).addErrorToPoint
            car.tail = next
            car.nextHead = level.railroad.move(consideringLights = false, forLength = carsDelta, point = next).addErrorToPoint
            car.nextHead
        }, head.invert)
    }

    private def move(point : EGPoint, length : float) = EGPoint(point.x, point.y + length)

    def updateWith(delta : float) {
        correct(level.railroad.move(consideringLights = true, forLength = delta*speed, point = head))
    }

    private def directedCars = if(back) cars.reverse.toArray else cars

    private def correct(correction : TRRailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length) {
                if(isMoveToCity && level.cityFor(correction.point.tile).get.color == color) {
                    level.arrived(self)
                } else {
                    back = !back
                    val lastCar = directedCars.head.get
                    head = lastCar.tail
                }
            } else {
                head = correction.addErrorToPoint
            }
        } else {
            head = correction.point
        }
        calculateCarPositions
    }

    private def isMoveToCityFor(point : TRRailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

    def isLocked(theSwitch : TRSwitch) : bool = {
        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        cars.find(
            _.head.tile == tile && _.nextHead.tile == nextTile
            || _.head.tile == nextTile && _.nextHead.tile == tile
        ).isDefined
    }
}


class TRCar {
    var head : TRRailPoint
    var tail : TRRailPoint
    var nextHead : TRRailPoint

    def length : float = 0.6
}