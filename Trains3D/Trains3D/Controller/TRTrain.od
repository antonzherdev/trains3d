package com.antonzherdev.trains

import com.antonzherdev.eg._

enum TRTrainType(obstacleProcessor : (TRLevel, TRTrain, TRObstacle) -> bool) {
    simple((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) level.destroy(train)
        false
    })
    crazy((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) level.destroy(train)
        o.obstacleType ==  TRObstacleType.light
    })
    fast((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage || o.obstacleType == TRObstacleType.switch) level.destroy(train)
        false
    })
    repairer((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) {
            level.railroad.fixDamageAt(o.point)
            true
        } else false
    })
}

class TRTrain(weak level : TRLevel, trainType : TRTrainType, color : TRColor, _cars : (TRTrain) ->[TRCar], speed : uint) extends EGController {
    var viewData : any = nil
    private var head : TRRailPoint
    private var back = false
    def isBack = back
    lazy val cars = _cars(self)
    private val length : float = cars.chain.fold(((r, car) -> car.carType.fullLength + r), 0.0)
    val speedFloat : float = 0.01 * speed

    def startFrom(city : TRCity) {
        head = city.startPoint
        calculateCarPositions
    }

    def set(head : TRRailPoint) {
        self.head = head
        calculateCarPositions
    }
    private val carsObstacleProcessor : TRObstacle -> bool = (o : TRObstacle) ->
        o.obstacleType ==  TRObstacleType.light

    private def calculateCarPositions {
        directedCars.chain.fold((frontConnector, car) -> {
            val tp = car.carType
            val fl = tp.frontConnectorLength
            val bl = tp.backConnectorLength
            val head = level.railroad.moveWith(carsObstacleProcessor, if(back) bl else fl, frontConnector).addErrorToPoint
            val tail = level.railroad.moveWith(carsObstacleProcessor, tp.length, head).addErrorToPoint
            val backConnector =  level.railroad.moveWith(carsObstacleProcessor, if(back) fl else bl, tail).addErrorToPoint
            car.position =
                if(back) TRCarPosition(backConnector, tail, head, frontConnector)
                else TRCarPosition(frontConnector, head, tail, backConnector)
            backConnector
        }, head.invert)
    }

    private def move(point : EGVec2, length : float) = EGVec2(point.x, point.y + length)

    def updateWith(delta : float) {
        correct(level.railroad.moveWith(obstacleProcessor = trainType.obstacleProcessor(level, self, _),
            forLength = delta*speedFloat, point = head))
    }

    private def directedCars : [TRCar] = if(back) cars.chain.reverse.toArray else cars

    private def correct(correction : TRRailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length) {
                if(isMoveToCity && (color == TRColor.grey || level.cityFor(correction.point.tile).get.color == color)) {
                    level.arrived(self)
                } else {
                    back = !back
                    val lastCar = directedCars.head.get
                    head = lastCar.position.backConnector
                }
            } else {
                head = correction.addErrorToPoint
            }
        } else {
            head = correction.point
        }
        calculateCarPositions
    }

    private def isMoveToCityFor(point : TRRailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

    def isLocked(theSwitch : TRSwitch) : bool = {
        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        cars.find{car ->
            val p = car.position
            p.frontConnector.tile == tile && p.backConnector.tile == nextTile
            || p.frontConnector.tile == nextTile && p.backConnector.tile == tile
        }.isDefined
    }
}

class TREngineType(
    tubePos : EGVec3 //tube position relative to start of the car
)

enum TRCarType(
    length : float, //Length between wheels
    width : float, //width of the car for collision detection
    frontConnectorLength : float, backConnectorLength: float, // distances between start or end of the car and the nearest wheels
    engineType : TREngineType?) {
    car(0.44, 0.18, 0.13, 0.13, nil)
    engine(0.43, 0.18, 0.12, 0.2, TREngineType(tubePos = EGVec3(-0.06, 0, 0.5)))

    def fullLength : float = length + frontConnectorLength + backConnectorLength
    def isEngine : bool = engineType.isDefined
    val shape : EGCollisionShape = EGCollisionBox2d(length/2, width/2)
}

class TRCar(weak train : TRTrain, carType : TRCarType) {
    var position : TRCarPosition

    private val _collisionBody = EGCollisionBody(self, carType.shape, isKinematic = true)
    def collisionBody = {
        _collisionBody.set(matrix = position.matrix)
        _collisionBody
    }

    def figure : EGThickLineSegment = EGThickLineSegment(position.line, carType.width)
}

class TRCarPosition(frontConnector : TRRailPoint, head : TRRailPoint, tail : TRRailPoint, backConnector : TRRailPoint) {
    val line = EGLineSegment(head.point, tail.point)
    lazy val matrix = {
        val mid = line.mid
        EGMatrix.identity.translate(mid.x, mid.y, 0).rotate(line.degreeAngle, 0, 0, 1)
    }
}

class TRTrainGenerator(trainType : TRTrainType, carsCount : [int], speed : [int], carTypes : [TRCarType]) {
    def generateCarsFor(train : TRTrain) : [TRCar] = {
        val count = carsCount.randomItem.get
        val engine = TRCar(train, carTypes.chain.filter(_.isEngine).randomItem.get)
        if(count <= 1) [engine]
        else count.range.chain.map(i -> TRCar(train, carTypes.chain.filter(!_.isEngine).randomItem.get)).prepend([engine]).toArray
    }
    def generateSpeed : uint = speed.randomItem.get
}