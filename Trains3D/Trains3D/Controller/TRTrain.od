import CNList

import EGTypes
import EGMapIso
import EGFigure

import TRTypes
import TRCity
import TRLevel
import TRRailPoint
import TRRailroad

enum TRTrainType(obstacleProcessor : (TRLevel, TRTrain, TRObstacle) -> bool) {
    simple((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) level.destroy(train)
        false
    })
    crazy((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) level.destroy(train)
        o.obstacleType ==  TRObstacleType.light
    })
    fast((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage || o.obstacleType == TRObstacleType.switch) level.destroy(train)
        false
    })
    repairer((level : TRLevel, train : TRTrain, o : TRObstacle) -> {
        if(o.obstacleType ==  TRObstacleType.damage) {
            level.railroad.fixDamageAt(o.point)
            true
        } else false
    })
}

class TRTrain(weak level : TRLevel, trainType : TRTrainType, color : TRColor, cars : [TRCar], speed : uint) {
    private var head : TRRailPoint
    private var back = false
    private val length : float = cars.chain.fold(((r, car) -> car.fullLength + r), 0.0)
    private val _speedF : float = 0.01 * speed

    def startFrom(city : TRCity) {
        head = city.startPoint
        calculateCarPositions
    }

    def set(head : TRRailPoint) {
        self.head = head
        calculateCarPositions
    }
    private val carsObstacleProcessor : TRObstacle -> bool = (o : TRObstacle) ->
        o.obstacleType ==  TRObstacleType.light

    private def calculateCarPositions {
        directedCars.chain.fold((hl, car) -> {
            car.frontConnector = hl
            var p =  level.railroad.moveWith(carsObstacleProcessor, car.frontConnectorLength, hl).addErrorToPoint
            car.head = p
            p =  level.railroad.moveWith(carsObstacleProcessor, car.length, p).addErrorToPoint
            car.tail = p
            p =  level.railroad.moveWith(carsObstacleProcessor, car.backConnectorLength, p).addErrorToPoint
            car.backConnector = p
            p
        }, head.invert)
    }

    private def move(point : EGPoint, length : float) = EGPoint(point.x, point.y + length)

    def updateWith(delta : float) {
        correct(level.railroad.moveWith(obstacleProcessor = trainType.obstacleProcessor(level, self, _),
            forLength = delta*_speedF, point = head))
    }

    private def directedCars : [TRCar] = if(back) cars.chain.reverse.toArray else cars

    private def correct(correction : TRRailPointCorrection) {
        if(correction.error != 0.0) {
            val isMoveToCity = isMoveToCityFor(correction.point)
            if(!isMoveToCity || correction.error >= length) {
                if(isMoveToCity && (color == TRColor.grey || level.cityFor(correction.point.tile).get.color == color)) {
                    level.arrived(self)
                } else {
                    back = !back
                    val lastCar = directedCars.head.get
                    head = lastCar.backConnector
                }
            } else {
                head = correction.addErrorToPoint
            }
        } else {
            head = correction.point
        }
        calculateCarPositions
    }

    private def isMoveToCityFor(point : TRRailPoint) : bool =
        !(level.map.isFull(point.tile)) && !(level.map.isFull(point.nextTile))

    def isLocked(theSwitch : TRSwitch) : bool = {
        val tile = theSwitch.tile
        val nextTile = theSwitch.connector.next(tile)
        cars.find(
            _.frontConnector.tile == tile && _.backConnector.tile == nextTile
            || _.frontConnector.tile == nextTile && _.backConnector.tile == tile
        ).isDefined
    }
}


class TRCar {
    var frontConnector : TRRailPoint
    var backConnector : TRRailPoint
    var head : TRRailPoint
    var tail : TRRailPoint

    def frontConnectorLength = 0.13
    def backConnectorLength = 0.13
    def length : float = 0.44
    def width : float = 0.18
    def fullLength : float = length + frontConnectorLength + backConnectorLength

    def figure : EGThickLineSegment = EGThickLineSegment(EGLineSegment.newWith(head.point, tail.point), width)
}

class TRTrainGenerator(trainType : TRTrainType, carsCount : CNList<int>, speed : CNList<int>) {
    def generateCars : [TRCar] = carsCount.randomItem.get.range.chain.map(TRCar.new).toArray
    def generateSpeed : uint = speed.randomItem.get
}