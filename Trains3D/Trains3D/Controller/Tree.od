package com.antonzherdev.trains


class ForestRules(
    types : [TreeType],
    thickness : float //count on tile
)

class Forest(map : MapSso, rules : ForestRules, weather : Weather) extends Controller {
    private var _trees = (rules.thickness * map.allTiles.count).cast<int>.range.chain.map{ _ ->
        val tile = map.allTiles.randomItem.get
        val pos = vec2(Float.rnd(-0.5, 0.5), Float.rnd(-0.5, 0.5))
        val tree = Tree(rules.types.randomItem.get, pos + tile, vec2(Float.rnd(0.8, 1.2), Float.rnd(0.8, 1.2)))
        tree.rustle = Float.rnd(-1, 1)
        tree
    }.sort.toArray
    def trees = _trees

    def cutDown(tile : vec2i) {
        cutDown(rect = Rect(tile, vec2(1.4, 1.4)) - vec2(0.7, 0.7))
    }

    def cutDownFor(rail : Rail) {
        val s = rail.form.start.vec/2.0
        val e = rail.form.end.vec/2.0
        val ds = if(s.x == 0) vec2(0.3, 0) else vec2(0, 0.3)
        val de = if(e.x == 0) vec2(0.3, 0) else vec2(0, 0.3)
        cutDown(rect = Quad(s - ds, s + ds, e - de, e + de).boundingRect + rail.tile)
    }

    def cutDown(rect : Rect) {
        _trees = _trees.chain.filter(!rect.contains(_.position)).toArray
    }

    def updateWith(delta : float) {
        _trees.for(_.updateWith(delta))
    }
}


class Tree(treeType : TreeType, position : vec2, size : vec2) extends Comparable<Tree> with Controller {
    def compare(to : Tree) : int = -(position.y - position.x).compare(to.position.y - to.position.x)


    private var _rustleUp : bool = true
    var rustle : float = 0.0

    def updateWith(delta : float) {
        if(_rustleUp) {
            rustle += delta*7
            if(rustle > 1) _rustleUp = false
        } else {
            rustle -= delta*7
            if(rustle < -1) _rustleUp = true
        }
    }
}

enum TreeType {
    pine()
    tree1()
    tree2()
    tree3()
    yellow()
}