package com.antonzherdev.trains

import com.antonzherdev.eg._

enum CityColor(color : vec4, localName : string) {
orange(vec4(247, 156, 37, 255)/255, Loc.colorOrange)
    green(vec4(0.66, 0.9, 0.44, 1.0), Loc.colorGreen)
    pink(vec4(255, 153, 206, 255)/255, Loc.colorPink)
    beige(vec4(230, 212, 184, 255)/255, Loc.colorPink)
    purple(vec4(0.66, 0.44, 0.9, 1.0), Loc.colorPurple)
    blue(vec4(133, 158, 242, 255)/255, Loc.colorBlue)
    red(vec4(230, 80, 85, 255)/255, Loc.colorRed)
    mint(vec4(119, 217, 155, 255)/255, Loc.colorMint)
    yellow(vec4(248, 230, 28, 255)/255, Loc.colorYellow)


    grey(vec4(0.7, 0.7, 0.7 , 1.0), Loc.colorGrey)

    val trainColor = color //vec4(color.xyz*0.9, 1)
}


enum CityAngle(angle : int, form : RailForm, back : bool) {
    angle0(0, RailForm.leftRight, false)
    angle90(90, RailForm.bottomTop, true)
    angle180(180, RailForm.leftRight, true)
    angle270(270, RailForm.bottomTop, false)

    def out : RailConnector = if(back) form.start else form.end
}

/*
 * angle - поворот по часовой стрелке. При 0 город направлен по оси x в положительном направлении
 */
class City(color : CityColor, tile : vec2i, angle : CityAngle) extends Updatable {
    def startPoint = RailPoint(tile, angle.form, -0.5, angle.back)

    var expectedTrainCounter = Counter()
    var expectedTrainColor : CityColor

    def updateWith(delta : float) {
        expectedTrainCounter.updateWith(delta)
    }

    private var waitingCounter = Counter()
    def waitToRunTrain {
        waitingCounter = expectedTrainCounter
        expectedTrainCounter = Counter()
    }

    def isWaitingToRunTrain = waitingCounter.isRunning

    def resumeTrainRunning {
        expectedTrainCounter = waitingCounter
        waitingCounter = Counter()
    }

    def canRunNewTrain = expectedTrainCounter.isStopped && waitingCounter.isStopped

    static val box = CollisionBox(0.9, 0.2, 0.15)
    val bodies : [RigidBody<Car>] = {
        val a = RigidBody.statical(nil, box)
        val b = RigidBody.statical(nil, box)
        val moveYa = mat4.identity.translate(0, 0.3, 0)
        val moveYb = mat4.identity.translate(0, -0.3, 0)
        val rotate = mat4.identity.rotate(angle.angle , 0, 0, -1)
        val moveTile = mat4.identity.translate(tile.x, tile.y, 0)
        a.matrix = moveTile * rotate * moveYa
        b.matrix = moveTile * rotate * moveYb
        [a, b]
    }
}