package com.antonzherdev.trains

import com.antonzherdev.eg._

enum CityColor(color : vec4, localNameFunc : () -> string) {
    orange(vec4(247, 156, 37, 255)/255, Loc.colorOrange)
    green(vec4(0.66, 0.9, 0.44, 1.0), Loc.colorGreen)
    pink(vec4(255, 153, 206, 255)/255, Loc.colorPink)
    beige(vec4(230, 212, 184, 255)/255, Loc.colorBeige)
    purple(vec4(0.66, 0.44, 0.9, 1.0), Loc.colorPurple)
    blue(vec4(133, 158, 242, 255)/255, Loc.colorBlue)
    red(vec4(230, 80, 85, 255)/255, Loc.colorRed)
    mint(vec4(119, 217, 155, 255)/255, Loc.colorMint)
    yellow(vec4(248, 230, 28, 255)/255, Loc.colorYellow)


    grey(vec4(0.7, 0.7, 0.7 , 1.0), Loc.colorGrey)

    val trainColor = color //vec4(color.xyz*0.9, 1)
    def localName : string = localNameFunc()
}


enum CityAngle(angle : int, form : RailForm, back : bool) {
    angle0(0, RailForm.leftRight, false)
    angle90(90, RailForm.bottomTop, true)
    angle180(180, RailForm.leftRight, true)
    angle270(270, RailForm.bottomTop, false)

    def in : RailConnector = if(back) form.end else form.start
    def out : RailConnector = if(back) form.start else form.end
}

case class CityState(city : City, expectedTrainCounterTime : float, expectedTrain : Train, isWaiting : bool)

/*
 * angle - поворот по часовой стрелке. При 0 город направлен по оси x в положительном направлении
 */
class City(weak level : Level, color : CityColor, tile : vec2i, angle : CityAngle) extends Updatable {
    val left = level.map.isLeft(tile)
    val right = level.map.isRight(tile)
    val bottom = level.map.isBottom(tile)
    val top = level.map.isTop(tile)
    def startPoint = RailPoint(tile, angle.form, startPointX, angle.back)
    def startPointX : float =
        if(left || right) 0.45
        else if(top) if(level.cameraReserves.value.top > 0.4) -0.35 else if(level.cameraReserves.value.top > 0.2) 0.1 else 0.4
        else if(bottom) if(level.cameraReserves.value.bottom > 0.01) (if(level.viewRatio.value < 1.34) -0.2 else -0.45) else -0.1
        else 0.5
    def state = CityState(self, expectedTrainCounter.time.value, expectedTrain, _isWaiting)

    private var _expectedTrainCounter = Counter()
    def expectedTrainCounter = if(_isWaiting) EmptyCounter.instance else _expectedTrainCounter
    def set(expectedTrainCounter : Counter) {
        _expectedTrainCounter = expectedTrainCounter
    }
    var expectedTrain : Train

    def updateWith(delta : float) {
        expectedTrainCounter.updateWith(delta)
    }

    private var _isWaiting = false
    def waitToRunTrain {
        _isWaiting = true
    }

    def isWaitingToRunTrain : bool = _isWaiting && _expectedTrainCounter.isRunning.value
    def resumeTrainRunning {
        _isWaiting = false
    }

    def canRunNewTrain : bool = !expectedTrainCounter.isRunning.value

    static val box = CollisionBox(0.9, 0.2, 0.15)
    val bodies : [RigidBody<Car>] = {
        val a = RigidBody.statical(nil, box)
        val b = RigidBody.statical(nil, box)
        val moveYa = mat4.identity.translate(0, 0.3, 0)
        val moveYb = mat4.identity.translate(0, -0.3, 0)
        val rotate = mat4.identity.rotate(angle.angle , 0, 0, -1)
        val moveTile = mat4.identity.translate(tile.x, tile.y, 0)
        a.matrix = moveTile * rotate * moveYa
        b.matrix = moveTile * rotate * moveYb
        [a, b]
    }

//    def dealloc {
//        log("Dealloc city")
//    }
}