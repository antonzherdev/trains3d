import EGMap
import EGMapIso
import EGTypes
import EGMapIsoTileIndex

import TRRailPoint
import TRScore

class TRRailroadConnectorContent {
    def canAddRail : bool = true
    def connect(rail : TRRail, to : TRRailConnector) : TRRailroadConnectorContent
    def buildLightIn(connector : TRRailConnector) : TRRailroadConnectorContent = self
    def rails : [TRRail]
    def isGreen : bool = true
}

class TREmptyConnector extends TRRailroadConnectorContent {
    static val instance : TRRailroadConnectorContent = TREmptyConnector.new
    def rails : [TRRail] = []
    def connect(rail : TRRail, to : TRRailConnector) : TRRailroadConnectorContent = rail
}

class TRRail(tile : EGPointI, form : TRRailForm) extends TRRailroadConnectorContent {
    def has(connector : TRRailConnector) : bool = form.start == connector || form.end == connector
    def connect(rail : TRRail, to : TRRailConnector) : TRRailroadConnectorContent = TRSwitch(rail.tile, to, self, rail)
    def rails : [TRRail] = [self]
    def buildLightIn(connector : TRRailConnector) : TRRailroadConnectorContent = TRLight(tile, connector, self)
}

class TRSwitch(tile : EGPointI, connector : TRRailConnector, rail1 : TRRail, rail2 : TRRail) extends TRRailroadConnectorContent {
    var firstActive = true
    def activeRail : TRRail = if(firstActive) rail1 else rail2
    def turn { firstActive = !firstActive }
    def canAddRail = false
    def connect(rail : TRRail, to : TRRailConnector) : TRRailroadConnectorContent = throw "Couldn't add rail to switch"
    def rails : [TRRail] = if(firstActive) [rail1, rail2] else [rail2, rail1]
    def buildLightIn(connector : TRRailConnector) : TRRailroadConnectorContent = self
}

class TRLight(tile : EGPointI, connector : TRRailConnector, rail : TRRail) extends TRRailroadConnectorContent {
    var isGreen = true
    def turn { isGreen = !isGreen }
    def canAddRail = true
    def connect(rail : TRRail, to : TRRailConnector) : TRRailroadConnectorContent = TRSwitch(tile, to, self.rail, rail)
    def rails : [TRRail] = [rail]
    def buildLightIn(connector : TRRailConnector) : TRRailroadConnectorContent = self
}

class TRRailroad(map : EGMapSso, score : TRScore) {
    private var _rails : [TRRail] = []
    def rails = _rails
    private var _switches : [TRSwitch] = []
    def switches = _switches
    private var _lights : [TRLight] = []
    def lights = _lights
    val builder = TRRailroadBuilder(self)
    private val connectorIndex = EGMapSsoTileIndex(map,
        TRRailConnector.values.chain.map( (_, TREmptyConnector.instance) ).toMutableMap)

    def canAdd(rail : TRRail) : bool = {
        val tileIndex = connectorIndex[rail.tile]
        tileIndex[rail.form.start].get.canAddRail && tileIndex[rail.form.end].get.canAddRail
    }

    def tryAdd(rail : TRRail) : bool = {
        if(canAdd(rail)) {
            connect(rail, rail.form.start)
            connect(rail, rail.form.end)
            buildLightsFor(rail.tile, rail.form.start)
            buildLightsFor(rail.tile, rail.form.end)
            rebuildArrays
            score.railBuilt
            true
        } else false
    }

    def contentIn(tile : EGPointI, connector : TRRailConnector) : TRRailroadConnectorContent? =
        connectorIndex[tile][connector].get

    private def connect(rail : TRRail, to : TRRailConnector) {
        connectorIndex[rail.tile].modify(with = _.get.connect(rail, to), to)
    }

    private def buildLightsFor(tile : EGPointI, connector : TRRailConnector) {
        val nextTile = connector.next(tile)
        val otherSideConnector = connector.otherSideConnector

        if(map.isFull(tile) && map.isPartial(nextTile)) {
            buildLightIn(nextTile, otherSideConnector)
        } else if (isTurnRailIn(nextTile, otherSideConnector)) {
            buildLightIn(nextTile, otherSideConnector)
        }

        if(isTurnRailIn(tile, connector) && connectorIndex[nextTile][otherSideConnector].get.rails.count == 1) {
            buildLightIn(tile, connector)
        }
    }

    private def isTurnRailIn(tile : EGPointI, connector : TRRailConnector) : bool = {
        val rails = connectorIndex[tile][connector].get.rails
        rails.count == 1 && rails[0].form.isTurn
    }

    private def buildLightIn(tile : EGPointI, connector : TRRailConnector) {
        connectorIndex[tile].modify(with = _.get.buildLightIn(connector), connector)
    }


    private def rebuildArrays {
        val allObjects = connectorIndex.values.chain.flatMap(_.values).toArray
        _rails = allObjects.chain.flatMap(_.rails).distinct.toArray
        _switches = allObjects.chain.filter(_.is<TRSwitch>).toArray
        _lights = allObjects.chain.filter(_.is<TRLight>).toArray
    }

    def move(consideringLights : bool, forLength : float, point : TRRailPoint) : TRRailPointCorrection =
        correct(consideringLights, point.add(forLength))

    private def activeRailFor(tile : EGPointI, connector : TRRailConnector) : TRRail? =
        connectorIndex[tile][connector].get.rails.head

    private def correct(consideringLights : bool, point : TRRailPoint) : TRRailPointCorrection = {
        val correction = point.correct

        if(correction.error == 0) correction
        else {
            val connector = point.endConnector
            val connectorDesc = connectorIndex[point.tile][connector].get
            val activeRailOpt = connectorDesc.rails.head
            if(activeRailOpt.isEmpty || (consideringLights && !(connectorDesc.isGreen))) correction
            else {
                if(activeRailOpt.get.form != point.form) correction
                else {
                    val nextTile = connector.next(point.tile)
                    val otherSideConnector = connector.otherSideConnector
                    val nextRail = activeRailFor(nextTile, otherSideConnector)

                    if(nextRail.isEmpty) correction
                    else {
                        val nextActiveRail = nextRail.get
                        val form = nextActiveRail.form
                        correct(consideringLights, TRRailPoint(nextTile, form, correction.error, form.end == otherSideConnector))
                    }
                }
            }
        }
    }
}

class TRRailroadBuilder(weak railroad : TRRailroad) {
    private var _rail : TRRail? = nil
    def rail = _rail

    def tryBuild(rail : TRRail) : bool = {
        if(railroad.canAdd(rail)) {
            _rail = rail
            true
        } else false
    }

    def clear {
        _rail = nil
    }

    def fix {
        _rail.for(r -> railroad.tryAdd(r))
        _rail = nil
    }
}

