import EGMap
import EGTypes
import EGMapIsoTileIndex

import TRRailPoint

class TRRail(tile : EGIPoint, form : TRRailForm) {
    def has(connector : TRRailConnector) : bool = form.start == connector || form.end == connector
}

class TRSwitch(tile : EGIPoint, connector : TRRailConnector, rail1 : TRRail, rail2 : TRRail) {
    var firstActive = true

    def activeRail : TRRail = if(firstActive) rail1 else rail2

    def turn {
        firstActive = !firstActive
    }
}

class TRRailroad(mapSize : EGISize) {
    var rails : [TRRail] = [] | private set
    var switches : [TRSwitch] = [] | private set
    val builder = TRRailroadBuilder(self)

    def canAdd(rail : TRRail) : bool = {
        val railsInTile = railsIn(rail.tile).array
        val countsAtStart = railsInTile.filter(_.has(rail.form.start)).count
        val countsAtEnd = railsInTile.filter(_.has(rail.form.end)).count

        countsAtStart < 2 &&  countsAtEnd < 2
    }

    private def railsIn(tile : EGIPoint) = rails.filter(_.tile == tile)
    def switchIn(tile : EGIPoint, connector : TRRailConnector) =
        switches.filter(_.tile == tile).find(_.connector == connector)

    def tryAdd(rail : TRRail) : bool = {
        if(canAdd(rail)) {
            maybeBuildSwitchFor(rail, rail.form.start)
            maybeBuildSwitchFor(rail, rail.form.end)
            rails += rail
            true
        } else false
    }

    private def maybeBuildSwitchFor(rail : TRRail, connector : TRRailConnector) {
        railsIn(rail.tile).filter(_.has(connector)).for(otherRail ->
            switches += TRSwitch(rail.tile, connector, otherRail, rail)
        )
    }

    def moveFor(length : float, point : TRRailPoint) : TRRailPointCorrection = correct(point.add(length))

    private def activeRailFor(tile : EGIPoint, connector : TRRailConnector) : TRRail? =
        switchIn(tile, connector)
            .map(_.activeRail)
            .getOrElse(
                railsIn(tile).filter(_.has(connector)).head
            )

    private def correct(point : TRRailPoint) : TRRailPointCorrection = {
        val correction = point.correct

        if(correction.error == 0) correction
        else {
            val connector = point.endConnector
            val activeRail = activeRailFor(point.tile, connector).get
            if(activeRail.form.ordinal != point.form) correction
            else {
                val nextTile = connector.next(point.tile)
                val otherSideConnector = connector.otherSideConnector
                val nextRail = activeRailFor(nextTile, otherSideConnector)

                if(nextRail.isEmpty) correction
                else {
                    val nextActiveRail = nextRail.get
                    val form = nextActiveRail.form
                    correct(TRRailPoint(nextTile, form.ordinal, correction.error, form.end == otherSideConnector))
                }
            }
        }
    }
}

class TRRailroadBuilder(weak railroad : TRRailroad) {
    var rail : TRRail? = nil | private set

    def tryBuild(rail : TRRail) : bool = {
        if(railroad.canAdd(rail)) {
            self.rail = rail
            true
        } else false
    }

    def clear {
        rail = nil
    }

    def fix {
        rail.for(r -> railroad.tryAdd(r))
        rail = nil
    }
}

