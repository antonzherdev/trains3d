import EGMap
import EGMapIso
import EGTypes

import TRRailPoint

class TRRail(tile : EGPointI, form : TRRailForm) {
    def has(connector : TRRailConnector) : bool = form.start == connector || form.end == connector
}

class TRSwitch(tile : EGPointI, connector : TRRailConnector, rail1 : TRRail, rail2 : TRRail) {
    var firstActive = true

    def activeRail : TRRail = if(firstActive) rail1 else rail2

    def turn {
        firstActive = !firstActive
    }
}

class TRLight(tile : EGPointI, connector : TRRailConnector) {
    var isGreen = true

    def turn {
        isGreen = !isGreen
    }
}

class TRRailroad(map : EGMapSso) {
    private var _rails : [TRRail] = []
    def rails = _rails
    private var _switches : [TRSwitch] = []
    def switches = _switches
    private var _lights : [TRLight] = []
    def lights = _lights
    val builder = TRRailroadBuilder(self)

    def canAdd(rail : TRRail) : bool = {
        val railsInTile = railsIn(rail.tile).array
        val countsAtStart = railsInTile.filter(_.has(rail.form.start)).count
        val countsAtEnd = railsInTile.filter(_.has(rail.form.end)).count

        countsAtStart < 2 &&  countsAtEnd < 2
    }

    private def railsIn(tile : EGPointI) = _rails.filter(_.tile == tile)
    def switchIn(tile : EGPointI, connector : TRRailConnector) =
        _switches.filter(_.tile == tile).find(_.connector == connector)

    def tryAdd(rail : TRRail) : bool = {
        if(canAdd(rail)) {
            maybeBuildSwitchFor(rail, rail.form.start)
            maybeBuildSwitchFor(rail, rail.form.end)
            maybeBuildLightFor(rail, rail.form.start)
            maybeBuildLightFor(rail, rail.form.end)
            _rails += rail
            true
        } else false
    }

    private def maybeBuildSwitchFor(rail : TRRail, connector : TRRailConnector) {
        railsIn(rail.tile).filter(_.has(connector)).for(otherRail ->
            _switches += TRSwitch(rail.tile, connector, otherRail, rail)
        )
    }

    private def maybeBuildLightFor(rail : TRRail, connector : TRRailConnector) {
        if(map.isPartial(rail.tile) && map.isFull(connector.next(rail.tile))) {
            _lights += TRLight(rail.tile, connector)
        }
    }

    def moveFor(length : float, point : TRRailPoint) : TRRailPointCorrection = correct(point.add(length))

    private def activeRailFor(tile : EGPointI, connector : TRRailConnector) : TRRail? =
        switchIn(tile, connector)
            .map(_.activeRail)
            .getOrElse(
                railsIn(tile).filter(_.has(connector)).head
            )

    private def correct(point : TRRailPoint) : TRRailPointCorrection = {
        val correction = point.correct

        if(correction.error == 0) correction
        else {
            val connector = point.endConnector
            val activeRail = activeRailFor(point.tile, connector).get
            if(activeRail.form.ordinal != point.form) correction
            else {
                val nextTile = connector.next(point.tile)
                val otherSideConnector = connector.otherSideConnector
                val nextRail = activeRailFor(nextTile, otherSideConnector)

                if(nextRail.isEmpty) correction
                else {
                    val nextActiveRail = nextRail.get
                    val form = nextActiveRail.form
                    correct(TRRailPoint(nextTile, form.ordinal, correction.error, form.end == otherSideConnector))
                }
            }
        }
    }
}

class TRRailroadBuilder(weak railroad : TRRailroad) {
    private var _rail : TRRail? = nil
    def rail = _rail

    def tryBuild(rail : TRRail) : bool = {
        if(railroad.canAdd(rail)) {
            _rail = rail
            true
        } else false
    }

    def clear {
        _rail = nil
    }

    def fix {
        _rail.for(r -> railroad.tryAdd(r))
        _rail = nil
    }
}

