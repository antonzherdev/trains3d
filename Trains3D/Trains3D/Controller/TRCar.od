package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class TREngineType(
    tubePos : vec3 //tube position relative to start of the car
)

enum TRCarType(
    width: float,
    height: float,
    weight : float,

    startToFront : float,
    frontToWheel : float,
    betweenWheels : float,
    wheelToBack : float,
    backToEnd : float,

    engineType : TREngineType?)
{
    car(0.18, 0.3, 1,
        0.05, 0.08, 0.44, 0.08, 0.05, nil)
    engine(0.2, 0.3, 2,
        0.05, 0.14, 0.32, 0.22, 0.05,
        TREngineType(tubePos = vec3(-0.06, 0, 0.5)))

    val startToWheel = startToFront + frontToWheel
    val wheelToEnd = wheelToBack + backToEnd
    val fullLength : float = startToWheel + betweenWheels + wheelToEnd
    def isEngine : bool = engineType.isDefined
    val collision2dShape : EGCollisionShape = EGCollisionBox2d((frontToWheel + betweenWheels + wheelToBack)/2, width/2)
    val rigidShape : EGCollisionShape = EGCollisionBox((frontToWheel + betweenWheels + wheelToBack)/2, width/2, height/2)
}

class TRCar(weak train : TRTrain, carType : TRCarType) {
    val collisionBody = EGCollisionBody(self, carType.collision2dShape, isKinematic = true)
    lazy val dynamicBody = {
        val line = position.line
        val len = line.length
        val vec = line.vec
        val mid = midPoint
        val b = EGRigidBody.dynamic(self, carType.rigidShape, carType.weight)
        b.matrix = mat4.identity.translate(mid.x, mid.y, carType.height/2).rotate(line.degreeAngle, 0, 0, 1)
        val rnd = vec3(randomFloatGap(-0.1, 0.1), randomFloatGap(-0.1, 0.1), randomFloatGap(0, 5))
        val vel = vec3(vec.mul(train.speedFloat/len*2), 0).add(rnd)
//        val vel = Vec3(vec.mul(train.speedFloat/len*2), 0)
        b.velocity = if(train.isBack) vel.negate else vel
        b.angularVelocity = vec3(randomFloatGap(-5, 5), randomFloatGap(-5, 5), randomFloatGap(-5, 5))
        b
    }

    private var _position : TRCarPosition
    def position : TRCarPosition = _position
    def set(position : TRCarPosition) {
        _position = position
        val line = position.line
        val mid = midPoint
        collisionBody.set(matrix = mat4.identity.translate(mid.x, mid.y, 0).rotate(line.degreeAngle, 0, 0, 1))
    }

    def midPoint =
        if(carType.wheelToBack == carType.frontToWheel) position.line.mid
        else {
            val line = position.line
            val len = line.length
            val vec = line.vec
            val dh = vec.mul(carType.frontToWheel/len)
            val dt = vec.mul(carType.wheelToBack/len)
            line.moveWith(dh.sub(dt).mul(0.5)).mid
        }
}

class TRCarPosition(frontConnector : TRRailPoint, head : TRRailPoint, tail : TRRailPoint, backConnector : TRRailPoint) {
    val line = LineSegment(tail.point, head.point)
}

