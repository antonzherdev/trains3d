package com.antonzherdev.trains

import com.antonzherdev.eg._

class RailroadConnectorContent {
    def canAdd(rail : Rail) : bool = true
    def connect(rail : Rail, to : RailConnector) : RailroadConnectorContent
    def buildLightIn(connector : RailConnector) : RailroadConnectorContent = self
    def rails : [Rail]
    def isGreen : bool = true
    def isEmpty = false
    def cutDownTreesIn(forest : Forest) {}
}

class EmptyConnector extends RailroadConnectorContent {
    static val instance : RailroadConnectorContent = EmptyConnector()
    def rails : [Rail] = []
    def connect(rail : Rail, to : RailConnector) : RailroadConnectorContent = rail
    def isEmpty = true
}

class Rail(tile : vec2i, form : RailForm) extends RailroadConnectorContent {
    def has(connector : RailConnector) : bool = form.start == connector || form.end == connector
    def connect(rail : Rail, to : RailConnector) : RailroadConnectorContent = Switch(rail.tile, to, self, rail)
    def rails : [Rail] = [self]
    def buildLightIn(connector : RailConnector) : RailroadConnectorContent = RailLight(tile, connector, self)
    def canAdd(rail : Rail) : bool = rail.form != form
    def line : Line2 = form.line + tile
}

class Switch(tile : vec2i, connector : RailConnector, rail1 : Rail, rail2 : Rail) extends RailroadConnectorContent {
    static val turnNotification = NotificationHandle<Switch, void>("switchTurnNotification")
    var firstActive = true
    def activeRail : Rail = if(firstActive) rail1 else rail2
    def turn {
        firstActive = !firstActive
        turnNotification.post(self)
    }
    def canAdd(rail : Rail) = false
    def connect(rail : Rail, to : RailConnector) : RailroadConnectorContent = throw "Couldn't add rail to switch"
    def rails : [Rail] = if(firstActive) [rail1, rail2] else [rail2, rail1]
    def buildLightIn(connector : RailConnector) : RailroadConnectorContent = self
    def cutDownTreesIn(forest : Forest) {
        forest.cutDownFor(switch = self)
    }
    def railPoint1 = railPoint(rail1)
    def railPoint2 = railPoint(rail2)

    private def railPoint(rail : Rail) =  RailPoint(tile, rail.form, 0, rail.form.end == connector)
}

class RailLight(tile : vec2i, connector : RailConnector, rail : Rail) extends RailroadConnectorContent {
    static val turnNotification = NotificationHandle<RailLight, void>("Light turned")
    var isGreen = true
    def turn {
        isGreen = !isGreen
        turnNotification.post(self)
    }
    def cutDownTreesIn(forest : Forest) {
        forest.cutDownFor(light = self)
    }
    def canAdd(rail : Rail) : bool = self.rail.canAdd(rail)
    def connect(rail : Rail, to : RailConnector) : RailroadConnectorContent = Switch(tile, to, self.rail, rail)
    def rails : [Rail] = [rail]
    def buildLightIn(connector : RailConnector) : RailroadConnectorContent = self
    def shift = vec3(if(connector == RailConnector.top) -0.2 else 0.2, 0, -0.45)
}

enum ObstacleType {
    damage()
    switch()
    light()
    end()
}
class Obstacle(obstacleType : ObstacleType, point : RailPoint) {}

class Railroad(map : MapSso, score : Score, forest : Forest) extends Updatable {
    private var _rails : [Rail] = []
    def rails = _rails
    private var _switches : [Switch] = []
    def switches = _switches
    private var _lights : [RailLight] = []
    def lights = _lights
    val builder = RailroadBuilder(self)
    private val connectorIndex = MapDefault(EmptyConnector.instance, MutableHashMap<(vec2i, RailConnector), RailroadConnectorContent>())
    private val damagesIndex = MutableHashMap<(vec2i, RailForm), [float]>()
    private var _damagesPoints = MutableArray<RailPoint>()
    def damagesPoints : [RailPoint] = _damagesPoints

    def canAdd(rail : Rail) : bool =
        connectorIndex[(rail.tile, rail.form.start)].canAdd(rail)
        && connectorIndex[(rail.tile, rail.form.end)].canAdd(rail)

    def tryAdd(rail : Rail) : bool = {
        if(canAdd(rail)) {
            add(rail)
            score.railBuilt
            true
        } else false
    }

    def add(rail : Rail) {
        connect(rail, rail.form.start).cutDownTreesIn(forest)
        connect(rail, rail.form.end).cutDownTreesIn(forest)
        buildLightsFor(rail.tile, rail.form.start)
        buildLightsFor(rail.tile, rail.form.end)
        forest.cutDownFor(rail)
        rebuildArrays
    }

    def contentIn(tile : vec2i, connector : RailConnector) : RailroadConnectorContent =
        connectorIndex[(tile, connector)]

    private def connect(rail : Rail, to : RailConnector) =
        connectorIndex.modify(by = _.connect(rail, to), forKey = (rail.tile, to))


    private def buildLightsFor(tile : vec2i, connector : RailConnector) {
        val nextTile = connector.next(tile)
        val otherSideConnector = connector.otherSideConnector

        if(map.isFull(tile) && map.isPartial(nextTile)) {
            buildLightIn(nextTile, otherSideConnector)
        } else if (isTurnRailIn(nextTile, otherSideConnector)) {
            buildLightIn(nextTile, otherSideConnector)
        }

        if(isTurnRailIn(tile, connector) && connectorIndex[(nextTile, otherSideConnector)].rails.count == 1) {
            buildLightIn(tile, connector)
        }
    }

    private def isTurnRailIn(tile : vec2i, connector : RailConnector) : bool = {
        val rails = connectorIndex[(tile, connector)].rails
        rails.count == 1 && rails[0].form.isTurn
    }

    private def buildLightIn(tile : vec2i, connector : RailConnector) {
        connectorIndex.modify(by = _ -> {
            val r = _.buildLightIn(connector)
            r.cutDownTreesIn(forest)
            r
        }, forKey = (tile, connector))
    }


    static val changedNotification = NotificationHandle<Railroad, void>("Railroad changed")
    private def rebuildArrays {
        _rails = connectorIndex.values.chain.flatMap(_.rails).distinct.toArray
        _switches = connectorIndex.values.chain.filter(_.is<Switch>).toArray
        _lights = connectorIndex.values.chain.filter(_.is<RailLight>).toArray
        changedNotification.post(self)
    }

    private def activeRailFor(tile : vec2i, connector : RailConnector) : Rail? =
        connectorIndex[(tile, connector)].rails.headOpt


    def moveWith(obstacleProcessor : Obstacle -> bool, forLength : float, point : RailPoint) : RailPointCorrection = {
        val p = point + forLength

        val correction = p.correct
        val damage = checkDamagesWith(obstacleProcessor, point, correction.point.x)
        if(damage.isDefined) {
            val x = damage.get
            return RailPointCorrection(p.set(x = x), correction.error + correction.point.x - x)
        }

        if(correction.error == 0) {
            val switchCheckCorrection = (correction.point + 0.5).correct
            if(switchCheckCorrection.error == 0) return correction

            val scActiveRailOpt = connectorIndex[(p.tile, p.endConnector)].rails.headOpt
            if(scActiveRailOpt.isEmpty) return correction
            if(scActiveRailOpt.get.form != p.form) {
                if(!obstacleProcessor(Obstacle(ObstacleType.switch, correction.point))) {
                    return RailPointCorrection(switchCheckCorrection.point.add(-0.5), switchCheckCorrection.error)
                }
            }
            return correction
        }

        val connector = p.endConnector
        val connectorDesc = connectorIndex[(p.tile, connector)]
        val activeRailOpt = connectorDesc.rails.headOpt
        if(activeRailOpt.isEmpty) return correction

        if(activeRailOpt.get.form != p.form) {
            obstacleProcessor(Obstacle(ObstacleType.switch, correction.point))
            return correction
        }

        if(!connectorDesc.isGreen) {
            if(!obstacleProcessor(Obstacle(ObstacleType.light, correction.point))) {
                return correction
            }
        }

        val nextTile = connector.next(p.tile)
        val otherSideConnector = connector.otherSideConnector
        val nextRail = activeRailFor(nextTile, otherSideConnector)

        if(nextRail.isEmpty) {
            obstacleProcessor(Obstacle(ObstacleType.end, correction.point))
            return correction
        }

        val nextActiveRail = nextRail.get
        val form = nextActiveRail.form
        moveWith(obstacleProcessor, correction.error, RailPoint(nextTile, form, 0, form.end == otherSideConnector))
    }

    def checkDamagesWith(obstacleProcessor : Obstacle -> bool, from : RailPoint, to : float) : float? = {
        if(_damagesPoints.isEmpty) return nil
        if(from.x == to) return nil
        val opt = damagesIndex.opt((from.tile, from.form))
        if(opt.isEmpty) return nil

        val on : Float -> bool = x : Float -> {
            !obstacleProcessor(Obstacle(ObstacleType.damage, from.set(x = x)))
        }
        val len = from.form.length
        if(from.back) opt.get.chain.filter(_.between(len - to, len - from.x)).sortDesc.map(len - _).find(on)
        else opt.get.chain.filter(_.between(from.x, to)).sort.find(on)
    }

    def addDamageAt(point : RailPoint) : RailPoint =  {
        var p = point
        if(p.back) p = p.invert

        val fl = p.form.length
        if(p.form.isStraight && p.x.between(0.35, 0.65)) p = p.set(x = 0.35)
        else if(p.x.between(0, 0.3)) p = p.set(x = 0.3)
        else if(p.x.between(fl - 0.3, fl)) p = p.set(x = fl - 0.3)

        if(!map.isVisible(p.point)) {
           p = p.set(x = 0)
           if(!map.isVisible(p.point)) {
               p = p.set(x = fl)
           }
        }

        damagesIndex.modify(by = arr -> arr.map(_ + p.x).getOrElse([p.x]), forKey = (p.tile, p.form))
        _damagesPoints.append(p)
        p
    }

    def fixDamageAt(point : RailPoint) {
        var p = point
        if(p.back) p = point.invert

        damagesIndex.modify(by = arrOpt -> arrOpt.map(arr -> arr.chain.filter(_ != p.x).toArray), forKey = (p.tile, p.form))
        _damagesPoints.remove(p)
    }

    def updateWith(delta : float) {
        builder.updateWith(delta)
    }
}


class RailBuilding(rail : Rail) {
    var progress = 0.0
}


class RailroadBuilder(weak railroad : Railroad) extends Updatable {
    var building = false
    private var _rail : Rail? = nil
    def rail = _rail
    private var _buildingRails = List<RailBuilding>()
    def buildingRails : [RailBuilding] = _buildingRails
    def railForUndo : Rail? = _buildingRails.headOpt.map(_.rail)


    def tryBuild(rail : Rail) : bool = {
        if(canAdd(rail)) {
            _rail = rail
            changed
            true
        } else {
            if(_rail.isDefined) {
                _rail = nil
                changed
            }
            false
        }
    }

    static val changedNotification = NotificationHandle<RailroadBuilder, void>("Railroad builder changed")
    private def changed {
        changedNotification.post(self)
    }

    def checkCity(tile : vec2i, connector : RailConnector) : bool = {
        val nextTile = connector.next(tile)
        railroad.map.isFull(nextTile) || !railroad.contentIn(nextTile, connector.otherSideConnector).isEmpty
    }

    def clear {
        if(_rail.isDefined) {
            _rail = nil
            changed
        }
    }

    def fix {
        if(_rail.isDefined) {
            railroad.forest.cutDownFor(_rail.get)
            _buildingRails = List(RailBuilding(_rail.get), _buildingRails)
            _rail = nil
            changed
        }
    }

    def canAdd(rail : Rail) : bool =
        checkCity(rail.tile, rail.form.start) &&
        checkCity(rail.tile, rail.form.end) &&
        railroad.map.isFull(rail.tile) &&
        checkBuildings(rail)

    private def checkBuildings(rail : Rail) : bool =
        !_buildingRails.chain.exists(_.rail == rail)
        && railroad.canAdd(rail)
        && checkBuildingsConnector(rail.tile, rail.form.start)
        && checkBuildingsConnector(rail.tile, rail.form.end)

    private def checkBuildingsConnector(tile : vec2i, connector : RailConnector) : bool =
        (railroad.contentIn(tile, connector).rails.count
        + _buildingRails.chain.filter(_.rail.tile == tile && _.rail.form.contains(connector)).count) < 2


    def updateWith(delta : float) {
        var hasEnd = false
        _buildingRails.for{b ->
            var p = b.progress
            val less = p < 0.5
            p += delta/4
            if(less && p > 0.5) changed
            hasEnd = (hasEnd || p >= 1.0)
            b.progress = p
        }
        if(hasEnd) {
            _buildingRails = _buildingRails.filter{b ->
                if(b.progress >= 1.0) {
                    railroad.tryAdd(b.rail)
                    false
                } else true
            }
            changed
        }
    }

    def undo {
        _buildingRails = _buildingRails.tail
        changed
    }

    static val buildModeNotification = NotificationHandle<RailroadBuilder, void>("buildModeNotification")
    private var _buildMode : bool = false
    def buildMode = _buildMode
    def set(buildMode : bool) {
        _buildMode = buildMode
        buildModeNotification.post(self)
    }
}

