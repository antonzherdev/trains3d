import EGTypes
import EGProcessor
import EGTwoFingerTouchToMouse

import TRRailroad
import TRRailPoint

class TRRailroadBuilderProcessor(builder : TRRailroadBuilder) {
    private val mouseProcessor = TRRailroadBuilderMouseProcessor(builder)
    private val touchProcessor = EGTwoFingerTouchToMouse(mouseProcessor)

    def process(event : EGEvent) = event.leftMouse(mouseProcessor) || event.touch(touchProcessor)
}

struct TRRailCorrection (tile : EGIPoint, start : EGIPoint, end : EGIPoint)

class TRRailroadBuilderMouseProcessor(builder : TRRailroadBuilder) {
    private var startedPoint : CGPoint? = nil

    def mouseDown(event : EGEvent) = {
        startedPoint = event.location
        true
    }

    def mouseDrag(event : EGEvent) = startedPoint.map(sp -> {
        val deltaVector = egpSub(event.location, sp)
        if(egpLengthSQ(deltaVector) > 0.25) {
            val spTile = egpRound(sp)
            val start = norm(egpSub(sp, egipFloat(spTile)))
            val end = egipAdd(start, norm(egpSetLength(deltaVector, 0.7)))
            builder.tryBuild(convert(correct(TRRailCorrection(spTile, start, end))))
        }
        true
    }).getOr(false)

    def mouseUp(event : EGEvent) = startedPoint.map(point -> {
        builder.fix
        startedPoint = nil
        true
    }).getOr(false)

    private def norm(point : CGPoint) = EGIPoint(n(point.x), n(point.y))
    private def n(x : float) : int = round(x*2)

    private def correct(rail : TRRailCorrection) : TRRailCorrection =
        if(rail.end.x > 1) move(rail, 1, 0)
        else if(rail.end.x < -1) move(rail,-1, 0)
        else if(rail.end.y > 1) move(rail, 0, 1)
        else if(rail.end.y < -1) move(rail, 0, -1)
        else if(rail.start.x == 0 && rail.start.y == 0) correct(TRRailCorrection(rail.tile, egipNeg(rail.end), rail.end))
        else if(rail.end.x == 0 && rail.end.y == 0) correct(TRRailCorrection(rail.tile, rail.start, egipNeg(rail.start)))
        else if(rail.start.x > rail.end.x) correct(TRRailCorrection(rail.tile, rail.end, rail.start))
        else if(rail.start.x == rail.end.x && rail.start.y > rail.end.y) correct(TRRailCorrection(rail.tile, rail.end, rail.start))
        else if(fabs(rail.start.x) == 1 && fabs(rail.start.y) == 1 && rail.start.x != rail.end.x) correct(TRRailCorrection(rail.tile, egip(rail.start.x, 0), rail.end))
        else if(fabs(rail.start.x) == 1 && fabs(rail.start.y) == 1) correct(TRRailCorrection(rail.tile, egip(0, rail.start.y), rail.end))
        else if(fabs(rail.end.x) == 1 && fabs(rail.end.y) == 1 && rail.start.x != rail.end.x) correct(TRRailCorrection(rail.tile, rail.start, egip(rail.end.x, 0)))
        else if(fabs(rail.end.x) == 1 && fabs(rail.end.y) == 1) correct(TRRailCorrection(rail.tile, rail.start, egip(0, rail.end.y)))
        else rail

    private def move(rail : TRRailCorrection, x : int, y : int) = correct(TRRailCorrection(
        egip(rail.tile.x + x, rail.tile.y + y),
        egip(rail.start.x - 2*x, rail.start.y - 2*y),
        egip(rail.end.x - 2*x, rail.end.y - 2*y)))

    private def convert(rail : TRRailCorrection) = TRRail(rail.tile, TRRailForm.formFor(
        TRRailConnector.connectorFor(rail.start.x, rail.start.y),
        TRRailConnector.connectorFor(rail.end.x, rail.end.y)) )
}