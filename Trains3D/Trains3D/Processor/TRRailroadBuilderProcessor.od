package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.ODMath._

class TRRailroadBuilderProcessor(builder : TRRailroadBuilder) extends EGProcessor {
    private val mouseProcessor = TRRailroadBuilderMouseProcessor(builder)
    private val touchProcessor = EGTwoFingerTouchToMouse(mouseProcessor)

    def process(event : EGEvent) : bool = event.leftMouse(mouseProcessor) || event.touch(touchProcessor)
}

struct TRRailCorrection (tile : EGVec2I, start : EGVec2I, end : EGVec2I)

class TRRailroadBuilderMouseProcessor(builder : TRRailroadBuilder) extends EGMouseProcessor {
    private var startedPoint : EGVec2? = nil

    def mouseDown(event : EGEvent) = {
        startedPoint = event.location
        true
    }

    def mouseDrag(event : EGEvent) = startedPoint.map(sp -> {
        val deltaVector = event.location.sub(sp)
        if(deltaVector.lengthSquare > 0.25) {
            val spTile : EGVec2I = sp
            val start = norm(sp.sub(spTile))
            val end = start.add(norm(deltaVector.set(length = 0.7)))
            builder.tryBuild(convert(correct(TRRailCorrection(spTile, start, end))))
        }
        true
    }).getOr(false)

    def mouseUp(event : EGEvent) = startedPoint.map(point -> {
        builder.fix
        startedPoint = nil
        true
    }).getOr(false)

    private def norm(point : EGVec2) = EGVec2I(n(point.x), n(point.y))
    private def n(x : float) : int = lround(x*2)

    private def correct(rail : TRRailCorrection) : TRRailCorrection =
        if(rail.end.x > 1) move(rail, 1, 0)
        else if(rail.end.x < -1) move(rail,-1, 0)
        else if(rail.end.y > 1) move(rail, 0, 1)
        else if(rail.end.y < -1) move(rail, 0, -1)
        else if(rail.start.x == 0 && rail.start.y == 0) correct(TRRailCorrection(rail.tile, rail.end.negate, rail.end))
        else if(rail.end.x == 0 && rail.end.y == 0) correct(TRRailCorrection(rail.tile, rail.start, rail.start.negate))
        else if(rail.start.x > rail.end.x) correct(TRRailCorrection(rail.tile, rail.end, rail.start))
        else if(rail.start.x == rail.end.x && rail.start.y > rail.end.y) correct(TRRailCorrection(rail.tile, rail.end, rail.start))
        else if(fabs(rail.start.x) == 1 && fabs(rail.start.y) == 1 && rail.start.x != rail.end.x) correct(TRRailCorrection(rail.tile, EGVec2I(rail.start.x, 0), rail.end))
        else if(fabs(rail.start.x) == 1 && fabs(rail.start.y) == 1) correct(TRRailCorrection(rail.tile, EGVec2I(0, rail.start.y), rail.end))
        else if(fabs(rail.end.x) == 1 && fabs(rail.end.y) == 1 && rail.start.x != rail.end.x) correct(TRRailCorrection(rail.tile, rail.start, EGVec2I(rail.end.x, 0)))
        else if(fabs(rail.end.x) == 1 && fabs(rail.end.y) == 1) correct(TRRailCorrection(rail.tile, rail.start, EGVec2I(0, rail.end.y)))
        else rail

    private def move(rail : TRRailCorrection, x : int, y : int) = correct(TRRailCorrection(
        EGVec2I(rail.tile.x + x, rail.tile.y + y),
        EGVec2I(rail.start.x - 2*x, rail.start.y - 2*y),
        EGVec2I(rail.end.x - 2*x, rail.end.y - 2*y)))

    private def convert(rail : TRRailCorrection) = TRRail(rail.tile, TRRailForm.formFor(
        TRRailConnector.connectorFor(rail.start.x, rail.start.y),
        TRRailConnector.connectorFor(rail.end.x, rail.end.y)) )
}