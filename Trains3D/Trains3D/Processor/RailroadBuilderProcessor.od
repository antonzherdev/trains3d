package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class RailroadBuilderProcessor(builder : RailroadBuilder) extends InputProcessor {
    private val mouseProcessor = RailroadBuilderMouseProcessor(builder)
    private val touchProcessor = TouchToMouse(mouseProcessor)

    def process(event : Event) : bool = event.leftMouse(mouseProcessor) || event.touch(touchProcessor)
}

class RailroadBuilderMouseProcessor(builder : RailroadBuilder) extends MouseProcessor {
    private var startedPoint : vec2? = nil

    def mouseDown(event : Event) = {
        startedPoint = event.location
        true
    }

    def mouseDrag(event : Event) =
        if(startedPoint.isEmpty) false
        else {
            val line = Line2(p0 = startedPoint.get, p1 = event.location)

            if(line.u.lengthSquare > 0.25) {
                val nl = line.normalize
                val mid = nl.mid
                val tile = mid.round

                val start = connectorsByDistanceFrom(line.r0 - tile).head
                val ends = connectorsByDistanceFrom(line.r1 - tile)
                var end = ends.head
                if(end == start) end = ends[1]

                if(builder.tryBuild(Rail(tile, RailForm.formFor(start, end)))) {
                    if(line.u.length > 1.0) {
                        builder.fix
                        startedPoint = tile + end.vec*0.5
                    }
                }
            } else {
                builder.clear
            }
            true
        }

    private def connectorsByDistanceFrom(point : vec2) : [RailConnector] =
        RailConnector.values.chain.sortBy.asc{connector ->
            (connector.vec*0.5 - point).lengthSquare
        }.endSort.toArray

    def mouseUp(event : Event) =
        if(startedPoint.isEmpty) false
        else {
            builder.fix
            startedPoint = nil
            true
        }
}