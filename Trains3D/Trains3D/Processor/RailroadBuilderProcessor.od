package com.antonzherdev.trains

import com.antonzherdev.eg._
import core.math._

class RailroadBuilderProcessor(builder : RailroadBuilder) extends InputProcessor {

    private var startedPoint : vec2? = nil

    static val refuseBuildNotification = NotificationHandle<void>("refuseBuildNotification")
    private var firstTry : bool = true
    private var fixedStart : (vec2i, RailConnector)? = nil
    def recognizers : Recognizers = Recognizer(Pan(),
        began = event -> {
            startedPoint = event.location
            firstTry = true
            true
        },
        changed = event -> {
            val line = Line2(p0 = startedPoint.get, p1 = event.location)

            val len = line.u.length
            if(len > 0.5) {
                val nu = line.u.set(length = 1.0)
                val nl =
                    if(fixedStart.isDefined) Line2(p0 = line.p0, u = nu)
                    else Line2(p0 = line.p0 - nu*0.25, u = nu)
                val mid = nl.mid
                val tile = mid.round
                val railOpt =
                    possibleRailsAround(tile)
                    .map{rail -> (rail, distanceBetween(rail, nl))}
                    .filter(_.b < if(fixedStart.isDefined) 0.8 else 0.6)
                    .sortBy.asc(_.b).endSort
                    .top(4)
                    .filter(builder.canAdd(_.a))
                    .headOpt
                if(railOpt.isDefined) {
//                    log("Distance $(fixedStart.isDefined) $(railOpt.get.b)")
                    firstTry = true
                    val rail = railOpt.get.a
                    if(builder.tryBuild(rail)) {
                        if(len > if(fixedStart.isDefined) 1.6 else 1) {
                            builder.fix
                            val rl = rail.line

                            val end = rl.p0.sub(line.p0).lengthSquare < rl.p1.sub(line.p0).lengthSquare
                            startedPoint = if(end) rl.p1 else rl.p0
                            val con = if(end) rail.form.end else rail.form.start
                            fixedStart = (con.next(rail.tile), con.otherSideConnector)
                        }
                    }
                } else {
                    if(firstTry) {
                        firstTry = false
                        refuseBuildNotification.post
                    }
                }
            } else {
                firstTry = true
                builder.clear
            }
       },
       ended = event -> {
           builder.fix
           firstTry = true
           startedPoint = nil
           fixedStart = nil
       }
    )

    private def distanceBetween(rail : Rail, paintLine : Line2) : float = {
        val railLine = rail.line
        if(fixedStart.isDefined) {
            ((if(paintLine.p0 == railLine.p0) railLine.p1 else railLine.p0) - paintLine.p1).lengthSquare
        } else {
            val p0d = (railLine.p0 - paintLine.p0).length.min((railLine.p0 - paintLine.p1).length)
            val p1d = (railLine.p1 - paintLine.p0).length.min((railLine.p1 - paintLine.p1).length)
            val d = railLine.u.dot(paintLine.n).abs*0.5 + p0d + p1d
            val c = rail.form.connectors.chain.filter{connector ->
                !builder.railroad.contentIn(connector.next(rail.tile), connector.otherSideConnector).isEmpty
            }.count
            val k = if(c == 1) 0.5 else if(c == 2) 0.4 else 1.0
            k*d
        }
    }


    private def possibleRailsAround(tile : vec2i) : Chain<Rail> =
        if(fixedStart.isDefined)
            RailForm.values.chain.filter(_.contains(fixedStart.get.b)).map(Rail(fixedStart.get.a, _))
        else
            tilesAround(tile).chain.mul(RailForm.values).map{p ->Rail(p.a, p.b)}

    private def tilesAround(tile : vec2i) : [vec2i] =
        [tile
        , tile + vec2i(1, 0),  tile + vec2i(-1, 0),  tile + vec2i(0, 1),  tile + vec2i(0, -1)
        , tile + vec2i(1, 1),  tile + vec2i(-1, 1),  tile + vec2i(1, -1),  tile + vec2i(-1, -1)
        ]

    private def connectorsByDistanceFrom(point : vec2) : [RailConnector] =
        RailConnector.values.chain.sortBy.asc{connector ->
            (connector.vec*0.5 - point).lengthSquare
        }.endSort.toArray
}