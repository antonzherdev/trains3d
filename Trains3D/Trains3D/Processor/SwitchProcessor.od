package com.antonzherdev.trains

import com.antonzherdev.eg._

class SwitchProcessor(level : Level) extends InputProcessor {

    val switchShape = CollisionBox2d(0.4, 0.4)
    val lightShape = CollisionBox2d(0.5, 0.6)
    val narrowLightShape = CollisionBox2d(0.5, 0.5)
    val world = CollisionWorld<RailroadConnectorContent>()
    private val obs = Railroad.changedNotification.observe { _ ->
            self.world.clear
            self.level.railroad.switches.for{switch ->
            val body = CollisionBody(switch, switchShape, isKinematic = false)
            body.translate(switch.tile.x, switch.tile.y, 0)
            body.rotate(switch.connector.angle, 0, 0, 1)
            body.translate(-0.2, 0, 0)
            self.world.add(body)
        }
        self.level.railroad.lights.for{light ->
            val dy = dyFor(light)
            val body = CollisionBody(light, dy.a, isKinematic = false)
            body.translate(light.tile.x, light.tile.y, 0)
            body.rotate(light.connector.angle, 0, 0, 1)
            val shift = light.shift
            body.translate(shift.z, shift.x + dy.b, 0.1 + dzFor(light))
            body.rotate(90, 0, 1, 0)
            self.world.add(body)
        }
    }

    private def dyFor(light : RailLight) : (CollisionBox2d, float4) = {
        if(light.connector == RailConnector.top || light.connector == RailConnector.bottom) {
            if(nextConnect(light).is<RailLight>) (narrowLightShape, -0.15)
            else (lightShape, 0)
        } else if(light.connector == RailConnector.left && nextConnect(light).is<Switch>) (narrowLightShape, 0.15)
        else (lightShape, 0)
    }

    private def dzFor(light : RailLight) : float4 = {
        if(light.connector == RailConnector.bottom
            && level.railroad.contentIn(light.tile + vec2i(-1, 0), RailConnector.right).is<RailLight>) -0.15
        else if(light.connector == RailConnector.top
            && level.railroad.contentIn(light.tile + vec2i(-1, 1), RailConnector.right).is<RailLight>) -0.15
        else 0
    }

    private def nextConnect(light : RailLight) : RailroadConnectorContent = {
        val c = light.connector
        level.railroad.contentIn(c.next(light.tile), c.otherSideConnector)
    }


    def recognizers: Recognizers = Recognizer(Tap()) {event : Event ->
        val downed = world.closestCrossPointWith(event.segment).map(_.body.data)
        if(downed.isDefined) {
            downed.get.as<Switch>.for(level.tryTurn(theSwitch = _ ))
            downed.get.as<RailLight>.for(_.turn)

            true
        } else false
    }
}