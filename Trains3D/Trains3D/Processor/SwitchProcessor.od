package com.antonzherdev.trains

import com.antonzherdev.eg._

class SwitchProcessor(level : Level) extends MouseProcessor {
    def process(event : Event) : bool = event.leftMouse(self)

    private val index : RectIndex<(RailConnector, bool)> = RectIndex(
        [
            (rect(-0.1, 0.2, 0.2, 0.3), (RailConnector.top, false)),
            (rect(-0.1, -0.5, 0.2, 0.3), (RailConnector.bottom, false)),
            (rect(-0.5, -0.1, 0.3, 0.2), (RailConnector.left, false)),
            (rect(0.2, -0.1, 0.3, 0.2), (RailConnector.right, false)),

            (rect(0.15, 0.4, 0.1, 0.1), (RailConnector.top, true)),
            (rect(-0.25, -0.5, 0.1, 0.1), (RailConnector.bottom, true)),
            (rect(-0.5, 0.15, 0.1, 0.1), (RailConnector.left, true)),
            (rect(0.4, -0.25, 0.1, 0.1), (RailConnector.right, true))
        ]
    )
    private var downed : RailroadConnectorContent? = nil
    private val switchShape = CollisionBox2d(0.3, 0.2)
    private val lightShape = CollisionBox2d(0.2, 0.06)
    private val world = CollisionWorld<RailroadConnectorContent>()
    def init {
        level.railroad.add(changeListener = {
            world.clear
            level.railroad.switches.for{switch ->
                val body = CollisionBody(switch, switchShape, isKinematic = false)
                body.translate(switch.tile.x, switch.tile.y, 0)
                body.rotate(switch.connector.angle, 0, 0, 1)
                body.translate(-0.35, 0, 0)
                world.add(body)
            }
            level.railroad.lights.for{light ->
                val body = CollisionBody(light, lightShape, isKinematic = false)
                body.translate(light.tile.x, light.tile.y, 0)
                body.rotate(light.connector.angle, 0, 0, 1)
                body.translate(-0.45, 0.2, 0.1)
                body.rotate(90, 0, 1, 0)
                world.add(body)
            }
        })
    }

    def mouseDown(event : Event) = {
        val location = event.location
        val tile : vec2i = location
        val relPoint = location.sub(tile)
        val s = event.segment
        val pp = s.r(plane = plane(vec3(0,0,0), vec3(0, 0, 1)))
        downed = world.closestCrossPointWith(event.segment).map(_.body.data)
        downed.isDefined
    }

    def mouseDrag(event : Event) = downed.isDefined

    def mouseUp(event : Event) =
        if(downed.isDefined) {
            downed.get.as<Switch>.for(level.tryTurn(theSwitch = _ ))
            downed.get.as<RailLight>.for(_.turn)

            true
        } else false
}