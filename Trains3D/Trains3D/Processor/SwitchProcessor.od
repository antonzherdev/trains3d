package com.antonzherdev.trains

import com.antonzherdev.eg._

class SwitchProcessor(level : Level) extends InputProcessor {
    static val strangeClickNotification = NotificationHandle<SwitchProcessor, Event>("strangeClickNotification")
    def process(event : Event) : bool = {
        val vps = vec2(80, 80)/event.viewport.size*context.scale
        val loc = event.locationInViewport
        val rrState = level.railroad.state
        val closest =
            self.level.railroad.switches.chain.map{switch ->
                val rotate = mat4.identity.rotate(switch.connector.angle, 0, 0, 1)
                val moveToTile = mat4.identity.translate(switch.tile.x, switch.tile.y, 0)
                val m = moveToTile * rotate
                var p = vec2(-0.6, -0.2)

                val nextTile = switch.connector.next(switch.tile)
                val osc = switch.connector.otherSideConnector
                val city = level.cityFor(nextTile)
                if(city.isDefined && level.map.isBottom(nextTile)) {
                    if(city.get.angle.form == RailForm.bottomTop) p += vec2(0.1, -0.1)
                    else p += vec2(0.1, 0.1)
                } else if(rrState.contentIn(nextTile, osc).is<Switch>) {
                    p += vec2(0.2, 0)
                }
                SwitchProcessorItem(switch, Rect(p, vec2(0.4, 0.4))) * m
            }.append(self.level.railroad.lights.chain.map{light ->
                    var sz = 0.2
                    var sy = 0.2

                    val stand = mat4.identity.rotate(90, 0, 1, 0)
                    val sh = light.shift
                    val moveToPlace = mat4.identity.translate(sh.z, sh.x, sh.y + sz/2)
                    val rotateToConnector = mat4.identity.rotate(light.connector.angle, 0, 0, 1)
                    val moveToTile = mat4.identity.translate(light.tile.x, light.tile.y, 0)

                    val m = moveToTile * rotateToConnector * moveToPlace * stand
                    SwitchProcessorItem(light, Rect(-sz/2, -sy/2, sz, sy)) * m
            })
            .map{item -> item * event.matrixModel.wcp}
            .map{item -> item.expand(vps) }
            .filter{item -> item.contains(loc)}
            .sortBy.asc{item -> item.distance(loc)}.endSort
            .top(2)
            .toArray

        val downed : SwitchProcessorItem? =
            if(closest.count == 2) {
                val a = closest(0)
                val b = closest(1)
                val delta = (a.distance(loc) - b.distance(loc)).abs
                if(delta < 0.008) {
//                    log("!! Click: $delta = $(a.distance(loc)) - $(b.distance(loc))")
                    strangeClickNotification.post(self, event)
                    Option.none<SwitchProcessorItem>
                } else {
//                    log("Click: $delta = $(a.distance(loc)) - $(b.distance(loc))")
                    Option.some(a)
                }
            } else closest.headOpt
        if(downed.isDefined) {
//            log("downed: $(downed.get.boundingRect.center - loc)")
            downed.get.content.as<SwitchState>.for(level.tryTurn(switch = _.switch ))
            downed.get.content.as<RailLightState>.for(level.railroad.turn(light = _.light))

            true
        } else false
    }

    def recognizers: Recognizers = Recognizer(Tap(), process(_))

}

class SwitchProcessorItem(content : RailroadConnectorContent, p0 : vec3, p1 : vec3, p2 : vec3, p3 : vec3) {
    static def apply(content : RailroadConnectorContent, rect : Rect) : SwitchProcessorItem =
        SwitchProcessorItem(content, rect.p, rect.pw, rect.phw, rect.ph)

    def quad = Quad(p0.xy, p1.xy, p2.xy, p3.xy)
    def mul(mat4 : mat4) : SwitchProcessorItem = SwitchProcessorItem(content, mat4*p0, mat4*p1, mat4*p2, mat4*p3)
    def boundingRect : Rect = quad.boundingRect

    def expand(vec2 : vec2) : SwitchProcessorItem = {
        val r = boundingRect
        val len = r.size
        val mid = r.center
        SwitchProcessorItem(content,
            vec3(p0.xy + (p0.xy - mid)/len*vec2, p0.z),
            vec3(p1.xy + (p1.xy - mid)/len*vec2, p1.z),
            vec3(p2.xy + (p2.xy - mid)/len*vec2, p2.z),
            vec3(p3.xy + (p3.xy - mid)/len*vec2, p3.z)
        )
    }

    def contains(vec2 : vec2) : bool = quad.contains(vec2)
    def distance(vec2 : vec2) : float4 = (quad.center - vec2).length
}