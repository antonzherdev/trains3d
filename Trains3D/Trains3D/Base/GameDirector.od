package com.antonzherdev.trains

import com.antonzherdev.data._
import com.testflightapp._

class GameDirector {
    val gameCenterPrefix = "grp.com.antonzherdev.Trains3D"
    val gameCenterAchievementPrefix = "grp.com.antonzherdev.Train3D"
    val inAppPrefix = if(egPlatform.isComputer) "com.antonzherdev.Trains3D" else "com.antonzherdev.Trains3Di"
    val cloudPrefix = ""
    val rewindsInApp : [(string, uint)] = [("$inAppPrefix.Rewind1", 20), ("$inAppPrefix.Rewind2", 50), ("$inAppPrefix.Rewind3", 200)]


    val maxDayRewinds = 2
    val rewindRestorePeriod = 60*60*12
//    val rewindRestorePeriod = 60
    static val instance : GameDirector = GameDirector()

    val local = LocalKeyValueStorage([("currentLevel", 1), ("soundEnabled", 1),
        ("lastRewinds", []),
        ("dayRewinds", maxDayRewinds),
        ("boughtRewinds", 3),
        ("boughtSlowMotions", 0),
        ("show_fps", false),
        ("shadow", "Default"),
        ("railroad_aa", "Default")])
    val resolveMaxLevel : (any, any) -> any = weak (a : any, b : any) -> {
        val v = Conflict.resolveMax(a, b)
        log("Max level from cloud $v = max($a, $b)")
        if(currentLevel == a.cast<int>) {
            log("Update current level with $v from cloud")
            local.set("currentLevel", value = v)
        }
        v
    }

//    val showShadows = !egPlatform.version.less("7") && local.boolFor("shadows")
    def showShadows : bool = {
        val s = local.stringFor("shadow")
        (s == "Default" || s == "On") && !egPlatform.isIOSLess("7")
    }

    def railroadAA : bool = {
        val s = local.stringFor("railroad_aa")
        (s == "Default" && !egPlatform.isIOSLess("7")) || s == "On"
    }

    val cloud = CloudKeyValueStorage([("maxLevel", 1), ("pocket.maxLevel", 1)], name ->
        weak if(name == "$(cloudPrefix)maxLevel") resolveMaxLevel
        else Conflict.resolveMax)

    static val playerScoreRetrieveNotification = NotificationHandle<GameDirector, LocalPlayerScore>("playerScoreRetrieveNotification")
    private val obs = Level.winNotification.observe{ level, _ ->
        val n = level.number
        TestFlight.pass("Win level $n")
        cloud.keepMax("$(cloudPrefix)maxLevel", n + 1)
        local.set("currentLevel", i = n + 1)
        val leaderboard = "$gameCenterPrefix.Level$n"
        val s = level.score.money.value
        cloud.keepMax("$(cloudPrefix)level$n.score", s)
        local.synchronize
        cloud.synchronize
        GameCenter.instance.reportScore(leaderboard, s) { score ->
            playerScoreRetrieveNotification.post(self, score)
        }
    }
    private val sporadicDamageHelpObs = Level.sporadicDamageNotification.observe{ level, _ ->
        if(cloud.intFor("help.sporadicDamage") == 0) {
            level.schedule(1) {
                level.showHelp(Loc.helpSporadicDamage)
                cloud.set("help.sporadicDamage", 1)
            }
        }
    }

    private val damageHelpObs = Level.damageNotification.observe{ level, _ ->
        if(cloud.intFor("help.damage") == 0) {
            level.schedule(1) {
                level.showHelp(Loc.helpDamage)
                cloud.set("help.damage", 1)
            }
        }
    }

    private val repairerHelpObs = Level.runRepairerNotification.observe{ level, _ ->
        if(cloud.intFor("help.repairer") == 0) {
            level.schedule(Level.trainComingPeriod + 7) {
                level.showHelp(Loc.helpRepairer)
                cloud.set("help.repairer", 1)
            }
        }
    }

    def showHelp(key : string, text : string, after : float = 0) {
        if(cloud.intFor(key) == 0) {
            forLevel{level ->
                if(after == 0) {
                    level.showHelp(text)
                    cloud.set(key, 1)
                } else {
                    level.schedule(after) {
                        level.showHelp(text)
                        cloud.set(key, 1)
                    }
                }
            }
        }
    }

    var _purchasing = MArray<uint>()
    def purchasing : Seq<uint> = _purchasing

    private val inAppObs = InAppTransaction.changeNotification.observe { transaction, __ ->
        if(transaction.state == InAppTransactionState.purchasing) {
            rewindsInApp.find(_.a == transaction.productId).for{ item ->
                _purchasing.append(item.b)
                if(Director.current.isPaused.value) Director.current.redraw
            }
        } else if(transaction.state == InAppTransactionState.purchased) {
            rewindsInApp.find(_.a == transaction.productId).for{ item ->
                boughtRewinds(item.b)
                _purchasing.remove(item = item.b)
                transaction.finish
                closeRewindShop
            }
        } else if(transaction.state == InAppTransactionState.failed) {
            val paused = Director.current.isPaused.value
            if(!paused) Director.current.pause
            rewindsInApp.find(_.a == transaction.productId).for{ item ->
                _purchasing.remove(item = item.b)
                Director.current.redraw
            }
            Alert.showError(title = Loc.error, message = transaction.error.get) {
                transaction.finish
                if(!paused) Director.current.resume
            }
        }
    }

    def closeRewindShop {
        if(Director.current.isPaused.value) {
            forLevel { level ->
                if(level.rewindShop == 1) {
                    level.rewindShop = 0
                    Director.current.resume
                    runRewind(level)
                } else if(level.rewindShop == 2) {
                    level.rewindShop = 0
                    Director.current.redraw
                }
            }
        }
    }
    def clearTutorial {
        cloud.set("help.sporadicDamage", 0)
        cloud.set("help.damage", 0)
        cloud.set("help.express", 0)
        cloud.set("help.repairer", 0)
        cloud.set("help.crazy", 0)
        cloud.set("help.linesAdvice", 0)
        cloud.set("help.rewind", 0)
        cloud.set("help.zoom", 0)
        cloud.set("help.tozoom", 0)
        cloud.set("help.remove", 0)
    }

    def bestScore(levelNumber : uint) : int = cloud.intFor("$(cloudPrefix)level$levelNumber.score")

    private val crashObs = Level.crashNotification.observe{level, trains ->
        GameDirector.instance.destroyTrains(trains)
    }
    private val knockDownObs = Level.knockDownNotification.observe{level, p ->
        GameDirector.instance.destroyTrains([p.a])
        if(p.b == 2) {
            GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.KnockDown")
        } else if(p.b > 2) {
            GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.Crash$(p.b)")
        }
    }

    def destroyTrains(trains : Iterable<Train>) {
        GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.Crash")
        if(trains.exists(_.trainType == TrainType.fast)) {
            GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.ExpressCrash")
        }
        if(trains.exists(_.trainType == TrainType.repairer)) {
            GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.RepairCrash")
        }
        if(trains.exists(_.trainType == TrainType.crazy)) {
            GameCenter.instance.completeAchievement("$gameCenterAchievementPrefix.CrazyCrash")
        }
    }

    def init {
//        cloud.set("share.twitter", i = 0)
        soundEnabled.value = (local.intFor("soundEnabled") == 1)
        Rate.instance.setIds(ios = 736579117, osx = 736545415)
//        Rate.instance.setIds(ios = 343200656, osx = 403961173)
        GameCenter.instance.authenticate
//        cloud.keepMax("$(cloudPrefix)maxLevel", 16)
//        clearTutorial

        if(_dayRewinds.value > maxDayRewinds) _dayRewinds.value = maxDayRewinds
        val fullDayCount = lastRewinds.count + _dayRewinds.value
        if(fullDayCount > maxDayRewinds) {
            local.set("lastRewinds", array = lastRewinds.chain.top(maxDayRewinds - _dayRewinds.value).toArray)
        } else if(fullDayCount < maxDayRewinds) {
            _dayRewinds.value = maxDayRewinds - lastRewinds.count
        }
        checkLastRewinds
    }

    def needFPS = local.boolFor("show_fps")


    def localPlayerScore(level : uint, callback : LocalPlayerScore? -> void) {
        val leaderboard = "$gameCenterPrefix.Level$level"
        GameCenter.instance.localPlayerScore(leaderboard) { score ->
            val bs = bestScore(level)
            if( (score != nil && score.value <  bs) || (bs > 0 && score == nil) ) {
                log("No result in game center for level $level. We are trying to report.")
                GameCenter.instance.reportScore(leaderboard, bs) { ls ->
                    callback(ls)
                }
            } else {
                callback(score)
            }
        }
    }

    def currentLevel = local.intFor("currentLevel")
    def maxAvailableLevel = cloud.intFor("$(cloudPrefix)maxLevel")
    def restoreLastScene {
        TestFlight.pass("Restore $currentLevel")
        if(egPlatform.jailbreak) TestFlight.pass("Jailbreak")
        set(level = currentLevel)
    }

    def restartLevel {
        forLevel{level ->
            if(level.number == 16 && isNeedRate) {
                level.rate = true
                Director.current.redraw
            } else {
                set(level = level.number)
                Director.current.resume
            }
        }
    }

    def chooseLevel {
        TestFlight.pass("Choose level menu")
        Director.current.scene = LevelChooseMenu.scene
        Director.current.pause
    }

    def nextLevel {
        forLevel{level ->
            if(isNeedRate) {
                TestFlight.pass("Show rate dialog")
                level.rate = true
                Director.current.redraw
            } else {
                set(level = level.number + 1)
                Director.current.resume
            }
        }
    }

    def rateLater {
        Rate.instance.later
        nextLevel
    }

    def rateClose {
        Rate.instance.never
        nextLevel
    }

    def set(level : int) {
        val l = if(level > maxAvailableLevel) maxAvailableLevel else level
        val sh = if(showShadows) "sh" else "no_sh"
        val raa = if(railroadAA) "raa" else "no_raa"
        TestFlight.pass("Start level $l $sh $raa")
        local.set("currentLevel", i = l)
        Director.current.timeSpeed = 1.0
        val lvl = Levels.levelWith(number = l)
        if(l > 2 && cloud.intFor("help.remove") == 0) {
            lvl.schedule(5) {
                showHelp("help.remove", Loc.helpToRemove)
            }
        }
        Director.current.scene = SceneFactory.sceneFor(lvl)
    }


    def showLeaderboard(level : Level) {
        TestFlight.pass("Show leaderboard for level $(level.number)")
        GameCenter.instance.showLeaderboard("$gameCenterPrefix.Level$(level.number)")
    }

    def synchronize {
        local.synchronize
        cloud.synchronize
    }

    def showSupport(changeLevel : bool) {
        TestFlight.pass("Show support")
        val txt =
            "$(Loc.supportEmailText)

            $(egPlatform.text)"
        val text = "\n\n> " + txt.replace("\n", "\n> ")
        val htmlText = text.replace(">", "&gt;").replace("\n", "<br/>\n")
        forLevel{level ->
            EMail.instance.showInterface(to = "support@raildale.com",
                subject = "Raildale - $(UInt.rnd)",
                text = text,
                htmlText = "<small><i>$(htmlText)</i></small>")
            if(changeLevel) set(level = level.number + 1)
        }

    }

    def isNeedRate : bool = maxAvailableLevel > 4 && Rate.instance.shouldShow(everyVersion = true)
    def showRate {
        TestFlight.pass("Rate")
        forLevel{level ->
            Rate.instance.showRate
            set(level = level.number + 1)
        }
    }

    val soundEnabled : Var<bool> = Var(SoundDirector.instance.enabled)
    private val soundEnabledObserves = soundEnabled.observe{ e ->
        TestFlight.pass("SoundEnabled = $e")
        local.set("soundEnabled", i = if(e) 1 else 0)
        SoundDirector.instance.enabled = e
    }

    private val _slowMotionsCount = local.intVar("boughtSlowMotions")
    def slowMotionsCount : React<int> = _slowMotionsCount

    def lastRewinds = local.arrayFor<DateTime>("lastRewinds")
    private val _dayRewinds = local.intVar("dayRewinds")
    private val _boughtRewinds = local.intVar("boughtRewinds")
    val rewindsCount : React<int> = React(_dayRewinds, _boughtRewinds) {day, bought ->
        day + bought
    }

    def runRewind(level : Level) {
        if(!level.history.rewindCounter.isRunning.value) {
            if(rewindsCount.value <= 0) {
                TestFlight.pass("Shop")
                loadProducts
                level.rewindShop = 1
                Director.current.pause
                return nil
            }
            level.rewind
            if(_dayRewinds.value > 0) {
                _dayRewinds.update(_ - 1)
                if(local.appendToArray("lastRewinds", value = DateTime()).count == 1) {
                    checkLastRewinds
                }
            } else if(_boughtRewinds.value > 0) {
                _boughtRewinds.update(_ - 1)
            }
            local.synchronize

        }
    }
    def runSlowMotion(level : Level) {
        if(!level.slowMotionCounter.isRunning.value) {
            if(_slowMotionsCount.value <= 0) return nil

            Director.current.timeSpeed = 0.1
            level.slowMotionCounter = LengthCounter(1).onEnd {
                Director.current.timeSpeed = 1.0
            }
            _slowMotionsCount.update(_ - 1)
            local.synchronize
        }
    }

    def checkLastRewinds {
        val lsm = lastRewinds
        if(!lsm.isEmpty) {
            val first = lsm.head
            if(first.beforeNow > rewindRestorePeriod) {
                local.set("lastRewinds", array = lastRewinds.tail)
                _dayRewinds.update(_ + 1)
                checkLastRewinds
            } else {
                weak val ws = self
                Action.delay(first.beforeNow + 1) {
                    ws.checkLastRewinds
                }
            }
        }
    }

    static val facebookShareRate = 10
    static val twitterShareRate = 10

    static val shareNotification = NotificationHandle<GameDirector, ShareChannel>("GameDirector.shareNotification")

    def shareDialog : ShareDialog = {
        val url = "http:\/\/get.raildale.com/?x=a"
        ShareContent(Loc.shareText(url), "Share.jpg")
            .twitter(Loc.twitterText(url))
            .email(Loc.shareText(url), Loc.shareSubject)
            .dialog(shareHandler = shareChannel -> {
                TestFlight.pass("share.$(shareChannel.name)")
                if(shareChannel == ShareChannel.facebook && cloud.intFor("share.facebook") == 0) {
                    cloud.set("share.facebook", i = 1)
                    boughtRewinds(facebookShareRate)
                } else if(shareChannel == ShareChannel.twitter && cloud.intFor("share.twitter") == 0) {
                    cloud.set("share.twitter", i = 1)
                    boughtRewinds(twitterShareRate)
                }
                shareNotification.post(self, shareChannel)
                closeRewindShop
            }, cancelHandler = {})
    }

    def buyRewinds(product : InAppProduct) {
        product.buy
    }

    def boughtRewinds(count : uint) {
        _boughtRewinds.update(_ + count)
        local.synchronize
    }

    def share {
        if(!ShareDialog.isSupported) return nil

        TestFlight.pass("Share")
        shareDialog.display
    }

    def isShareToFacebookAvailable : bool = ShareDialog.isSupported && cloud.intFor("share.facebook") == 0
    def shareToFacebook {
        shareDialog.displayFacebook
    }

    def isShareToTwitterAvailable : bool = ShareDialog.isSupported && cloud.intFor("share.twitter") == 0
    def shareToTwitter {
        shareDialog.displayTwitter
    }

    private var _rewindPrices :  [(uint, InAppProduct?)] = rewindsInApp.chain.map((_.b, nil)).toArray
    def rewindPrices : [(uint, InAppProduct?)] = _rewindPrices

    def forLevel(f : Level -> void) {
        Director.current.scene.get.controller.as<Level>.for(f(_))
    }

    def closeShop {
        forLevel{level ->
            if(level.rewindShop == 1) {
                level.rewindShop = 0
                Director.current.resume
            } else if(level.rewindShop == 2) {
                level.rewindShop = 0
                Director.current.redraw
            }
        }
    }

    def loadProducts {
        InApp.loadProducts(rewindsInApp.chain.map(_.a).toArray, callback = {products ->
            _rewindPrices = products.chain
                .sortBy.asc(_.id).endSort
                .map{product ->
                    (rewindsInApp.find(_.a == product.id).get.b, product)
                }.toArray
            Director.current.redraw
        }, onError = Alert.showError(Loc.error, _))
    }

    def openShop {
        forLevel{level ->
            TestFlight.pass("Shop from pause")
            loadProducts
            level.rewindShop = 2
            Director.current.redraw
        }
    }
}