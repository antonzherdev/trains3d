package com.antonzherdev.trains

import com.antonzherdev.data._

class GameDirector {
    static val instance : GameDirector = GameDirector()
    val local = LocalKeyValueStorage([("currentLevel", 1)])
    val resolveMaxLevel : (any, any) -> any = (a : any, b : any) -> {
        val v = Conflict.resolveMax(a, b)
        log("Max level from cloud $v = max($a, $b)")
        if(currentLevel == a.cast<int>) {
            log("Update current level with $v from cloud")
            local.set("currentLevel", value = v)
        }
        v
    }

    val cloud = CloudKeyValueStorage([("maxLevel", 1)], name ->
        if(name == "maxLevel") resolveMaxLevel
        else Conflict.resolveMax)

    static val playerScoreRetrieveNotification = NotificationHandle<LocalPlayerScore>("playerScoreRetrieveNotification")
    private val obs = Level.winNotification.observe{ level ->
        val n = level.number
        cloud.keepMax("maxLevel", n + 1)
        local.set("currentLevel", i = n + 1)
        val leaderboard = "grp.com.antonzherdev.Trains3D.Level$n"
        val s = level.score.score
        cloud.keepMax("level$n.score", level.score.score)
        GameCenter.instance.reportScore(leaderboard, s) { score ->
            playerScoreRetrieveNotification.post(score)
        }
    }
    private val sporadicDamageHelpObs = Level.sporadicDamageNotification.observe{ level ->
        if(cloud.intFor("help.sporadicDamage") == 0) {
            level.schedule.schedule(1) {
                level.showHelp(Loc.helpSporadicDamage)
                cloud.set("help.sporadicDamage", 1)
            }
        }
    }

    private val damageHelpObs = Level.damageNotification.observe{ level ->
        if(cloud.intFor("help.damage") == 0) {
            level.schedule.schedule(1) {
                level.showHelp(Loc.helpDamage)
                cloud.set("help.damage", 1)
            }
        }
    }

    private val repairerHelpObs = Level.damageNotification.observe{ level ->
        if(cloud.intFor("help.repairer") == 0) {
            level.schedule.schedule(Level.trainComingPeriod + 7) {
                level.showHelp(Loc.helpRepairer)
                cloud.set("help.repairer", 1)
            }
        }
    }

    def clearTutorial {
        cloud.set("help.sporadicDamage", 0)
        cloud.set("help.damage", 0)
        cloud.set("help.repairer", 0)
    }

    def bestScore(levelNumber : uint) : int = cloud.intFor("level$levelNumber.score")

    private val crashObs = Level.crashNotification.observe(GameDirector.instance.destroyTrains(_))
    private val knockDownObs = Level.knockDownNotification.observe{p ->
        GameDirector.instance.destroyTrains([p.a])
        if(p.b == 2) {
            GameCenter.instance.completeAchievement("grp.KnockDown")
        } else if(p.b == 3) {
            GameCenter.instance.completeAchievement("grp.TripleCrash")
        } else if(p.b == 4) {
            GameCenter.instance.completeAchievement("grp.QuadrupleCrash")
        } else if(p.b == 5) {
            GameCenter.instance.completeAchievement("grp.QuinaryCrash")
        } else if(p.b == 6) {
            GameCenter.instance.completeAchievement("grp.SenaryCrash")
        }
    }

    def destroyTrains(trains : [Train]) {
        GameCenter.instance.completeAchievement("grp.Crash")
        if(trains.exists(_.trainType == TrainType.fast)) {
            GameCenter.instance.completeAchievement("grp.ExpressCrash")
        }
        if(trains.exists(_.trainType == TrainType.repairer)) {
            GameCenter.instance.completeAchievement("grp.RepairCrash")
        }
        if(trains.exists(_.trainType == TrainType.crazy)) {
            GameCenter.instance.completeAchievement("grp.CrazyCrash")
        }
    }

    def init {
        GameCenter.instance.authenticate
//        clearTutorial
    }


    def localPlayerScore(level : uint, callback : LocalPlayerScore? -> void) {
        val leaderboard = "grp.com.antonzherdev.Trains3D.Level$level"
        GameCenter.instance.localPlayerScore(leaderboard) { score ->
            val bs = bestScore(level)
            if( (score.isDefined && score.get.value <  bs) || (bs > 0 && score.isEmpty) ) {
                log("No result in game center for level $level. We are trying to report.")
                GameCenter.instance.reportScore(leaderboard, bs) { ls ->
                    callback(ls)
                }
            } else {
                callback(score)
            }
        }
    }

    def currentLevel = local.intFor("currentLevel")
    def maxAvailableLevel = cloud.intFor("maxLevel")
    def restoreLastScene {
        Director.current.set(scene = SceneFactory.sceneForLevelWith(number = currentLevel))
    }

    def restartLevel {
        Director.current.scene.get.controller.as<Level>.for{level ->
            set(level = level.number)
        }
    }

    def chooseLevel {
        Director.current.scene = LevelChooseMenu.scene
        Director.current.pause
    }

    def nextLevel {
        Director.current.scene.get.controller.as<Level>.for{level ->
            set(level = level.number + 1)
        }
    }

    def set(level : int) {
        if(level <= maxAvailableLevel) {
            local.set("currentLevel", i = level)
            Director.current.scene = SceneFactory.sceneFor(LevelFactory.levelWith(number = level))
            Director.current.resume
        }
    }

    def showLeaderboard(level : Level) {
        GameCenter.instance.showLeaderboard("grp.com.antonzherdev.Trains3D.Level$(level.number)")
    }

    def synchronize {
        local.synchronize
        cloud.synchronize
    }

    def showSupport {
        EMail.instance.showInterface(to = "support@raildale.com")
    }

    def isNeedRate : bool = maxAvailableLevel > 4 && !Rate.instance.isRatedThisVersion
    def showRate {
        Rate.instance.showRate
        Director.current.redraw
    }
}