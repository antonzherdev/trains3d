package com.antonzherdev.trains


import com.antonzherdev.eg._

class RailroadView(railroad : Railroad) {
    private val railView = RailView()
    private val switchView = SwitchView()
    private val lightView = LightView()
    private val damageView = DamageView()
    private val railroadSurface = ViewportSurface(depth = true, multisampling = true)
    private val backgroundView = BackgroundView(railroad.map)

    private var changed = true
    def init {
        railroad.add(changeListener = changed = true)
    }

    def drawBackground {
        railroadSurface.maybe(changed) {
            glClearColor(0, 0, 0, 0)
            glClear(GL_COLOR_BUFFER_BIT + GL_DEPTH_BUFFER_BIT)
            context.considerShadows = false
            backgroundView.draw
            railroad.rails.for(railView.draw(_))
            context.considerShadows = true
            changed = false
        }
        railroadSurface.draw
        backgroundView.drawShadow
        railroad.switches.for(switchView.draw(_))
        railroad.builder.rail.for(railView.draw(_))
        railroad.damagesPoints.for(damageView.draw(_))
    }

    def drawForeground {
        lightView.draw(railroad.lights)
    }
}

class RailView {
    val railMaterial = StandardMaterial(vec4(0.5, 0.5, 0.6, 1), vec4(0.5, 0.5, 0.5, 1), 0.3)
    val railModel = MeshModel([
        (Models.railGravel, textureFor("Gravel.png")),
        (Models.railTies, vec4(0.55, 0.45, 0.25, 1)),
        (Models.rails, railMaterial)
    ])
    val railTurnModel = MeshModel([
        (Models.railTurnGravel, textureFor("Gravel.png")),
        (Models.railTurnTies, vec4(0.55, 0.45, 0.25, 1)),
        (Models.railsTurn, railMaterial)
    ])
    def draw(rail : Rail) {
        matrix(
            _.modify(w = w -> w.translate(rail.tile.x, rail.tile.y, 0.001))
             .modify(m = m ->
                if(rail.form == RailForm.bottomTop || rail.form == RailForm.leftRight) {
                    if(rail.form == RailForm.leftRight) m.rotate(90, 0, 1, 0)
                    else m
                } else {
                    if(rail.form == RailForm.topRight) m.rotate(270, 0, 1, 0)
                    else if(rail.form == RailForm.bottomRight) m.rotate(180, 0, 1, 0)
                    else if(rail.form == RailForm.leftBottom) m.rotate(90, 0, 1, 0)
                    else m
                })
        ) {
            if(rail.form == RailForm.bottomTop || rail.form == RailForm.leftRight) {
                railModel.draw
            } else {
                railTurnModel.draw
            }
        }
    }
}

class SwitchView {
    val material = StandardMaterial( vec4(0.2, 0.5, 0.15, 1), vec4(0.5, 1, 0.5, 1), 1)
    val switchStraightModel = MeshModel([
        (Models.switchStraight, material)
    ])
    val switchTurnModel = MeshModel([
        (Models.switchTurn, material)
    ])

    def draw(theSwitch : Switch) {
        val connector = theSwitch.connector
        val rail = theSwitch.activeRail
        val form = rail.form
        var ref = false
        matrix(
            _.modify(w = w -> w.translate(theSwitch.tile.x, theSwitch.tile.y, 0.03))
             .modify(m = m -> {
                val m2 = m.rotate(connector.angle, 0, 1, 0).translate(-0.5, 0, 0)
                if(form.start.x + form.end.x != 0) {
                    val otherConnector = if(form.start == connector) form.end else form.start
                    val x = connector.x
                    val y = connector.y
                    val ox = otherConnector.x
                    val oy = otherConnector.y
                    if(x == -1 && oy == -1 || y == 1 && ox == -1 || y == -1 && ox == 1 || x == 1 && oy == 1) {
                        ref = true
                        m2.scale(1, 1, -1)
                    } else m2
                } else m2
             })
        ) {
            if(ref) glCullFace(GL_BACK)
            if(form.start.x + form.end.x == 0) {
                switchStraightModel.draw
            } else {
                switchTurnModel.draw
            }
            if(ref) glCullFace(GL_FRONT)
        }
    }
}

class LightView {
    val texture = textureFor("Light.png", GL_LINEAR, GL_LINEAR_MIPMAP_LINEAR)
    val redBodyMaterial = StandardMaterial(TextureRegion(texture, Rect(0.5, 0, 1, 1)))
    val greenBodyMaterial = StandardMaterial(texture)
    val greenGlowMaterial = ColorSource(vec4(0, 1, 0, 0.8), textureFor("LightGlow.png"))
    val redGlowMaterial = ColorSource(vec4(1, 0, 0, 0.8), textureFor("LightGlow.png"))

    def draw(lights : [RailLight]) {
        if(lights.isEmpty) return nil

        matrix.push
        val arr = lights.chain.map{light ->
            (matrix.value
                .modify(w = w -> w.translate(light.tile.x, light.tile.y, 0))
                .modify(m = m -> m.rotate(90 + light.connector.angle, 0, 1, 0).translate(0.2, 0, -0.45))
            , light.isGreen)
        }.toArray

        val shadow = context.renderTarget.is<ShadowRenderTarget>
        arr.for { p ->
            matrix.value = p.a
            (if(p.b)greenBodyMaterial else redBodyMaterial).draw(Models.light)
        }
        if(!shadow) {
            context.cullFace.disabled{ BlendFunction.standard{
                arr.for { p ->
                    matrix.value = p.a
                    if(p.b) greenGlowMaterial.draw(Models.lightGreenGlow)
                    else redGlowMaterial.draw(Models.lightRedGlow)
                }
            }}
        }
        matrix.pop
    }
}

class DamageView {
    val model = MeshModel([(Models.damage, vec4(1, 0, 0, 1))])
    def draw(point : RailPoint) {
        matrix(
            _.modify(w = w -> w.translate(point.point.x, point.point.y, 0.0))
        ) {
            model.draw
        }
    }
}

class BackgroundView(map : MapSso) {
    val mapView = MapSsoView(map)
    val material = StandardMaterial(textureFor("Grass.png"))

    def draw {
        mapView.drawPlaneWith(material)
//        mapView.drawLayout
    }

    def drawShadow {
        if(egPlatform.shadows) {
            BlendFunction.standard{ context.cullFace.disabled{ context.depthTest.disabled {
                val param = ShadowDrawParam([0.3])
                ShadowDrawShaderSystem.instance.shaderFor(param).draw(param, mapView.plane)
            }}}
        }
    }
}