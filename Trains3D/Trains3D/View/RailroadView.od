package com.antonzherdev.trains


import com.antonzherdev.eg._

class RailroadView(railroad : Railroad) extends InputProcessor {
    private val railView : RailView
    private val switchView = SwitchView()
    private val lightView = LightView(railroad)
    private val damageView = DamageView()
    private val railroadSurface = ViewportSurface(depth = true, multisampling = true)
    private val backgroundView : BackgroundView
    private val undoView = UndoView(railroad.builder)
    val shadowVao : VertexArray<_>?

    var _changed = true
    def init {
        weak val weakSelf = self
        railroad.add(changeListener = weakSelf._changed = true)
        railroad.builder.add(changeListener = weakSelf._changed = true)
        context.considerShadows = false
        backgroundView = BackgroundView(railroad.map)
        railView = RailView(railroad)
        val shadowParam = ShadowDrawParam([0.3], railroadSurface)
        shadowVao =
            if(egPlatform.shadows) backgroundView.mapView.plane.vao(ShadowDrawShaderSystem.instance, shadowParam, shadow = false)
            else nil
        context.considerShadows = true
    }

    def drawBackground {
        egPushGroupMarker("Railroad background")
        if(context.renderTarget.isShadow) {
            lightView.drawShadow
        } else {
            if(egPlatform.shadows) {
                context.cullFace.disabled{ context.depthTest.disabled {
                    shadowVao.get.draw
                }}
            } else {
                railroadSurface.draw
            }
            railroad.switches.for(switchView.draw(_))
            lightView.drawBodies
        }

        egPopGroupMarker
    }

    def drawForeground {
        egPushGroupMarker("Railroad foreground")
        BlendFunction.standard{
            undoView.draw
            lightView.drawGlows
            railroad.damagesPoints.for(damageView.draw(_))
        }
        egPopGroupMarker
    }

    def prepare {
        railroadSurface.maybe(_changed) {
            context.clearColor(vec4(0, 0, 0, 0))
            glClear(GL_COLOR_BUFFER_BIT + GL_DEPTH_BUFFER_BIT)
            context.considerShadows = false
            backgroundView.draw
            railroad.rails.for(railView.draw(_))
            railroad.builder.rail.for(railView.draw(_))
            railroad.builder.buildingRails.for(railView.draw(_))
            context.considerShadows = true
            _changed = false
        }
    }

    def reshape {
        undoView.reshape
    }

    def process(event : Event) : bool = undoView.process(event)
}

class RailView(railroad : Railroad) {
    val railMaterial = StandardMaterial(vec4(0.5, 0.5, 0.6, 1), vec4(0.5, 0.5, 0.5, 1), 0.3)
    val gravel = textureFor("Gravel.png", GL_LINEAR, GL_LINEAR_MIPMAP_LINEAR)
    val railModel = MeshModel([
        (Models.railGravel, gravel),
        (Models.railTies, vec4(0.55, 0.45, 0.25, 1)),
        (Models.rails, railMaterial)
    ])
    val railTurnModel = MeshModel([
        (Models.railTurnGravel, gravel),
        (Models.railTurnTies, vec4(0.55, 0.45, 0.25, 1)),
        (Models.railsTurn, railMaterial)
    ])
    def draw(railBuilding : RailBuilding) {
        val p = railBuilding.progress
        draw(railBuilding.rail, if(p < 0.5) 1 else 2)
    }

    def draw(rail : Rail) {
        draw(rail, 3)
    }

    private def draw(rail : Rail, count : uint4) {
        matrix(
            _.modify(w = w -> w.translate(rail.tile.x, rail.tile.y, 0.001))
             .modify(m = m ->
                if(rail.form == RailForm.bottomTop || rail.form == RailForm.leftRight) {
                    if(rail.form == RailForm.leftRight) m.rotate(90, 0, 1, 0)
                    else m
                } else {
                    if(rail.form == RailForm.topRight) m.rotate(270, 0, 1, 0)
                    else if(rail.form == RailForm.bottomRight) m.rotate(180, 0, 1, 0)
                    else if(rail.form == RailForm.leftBottom) m.rotate(90, 0, 1, 0)
                    else m
                })
        ) {
            if(rail.form == RailForm.bottomTop || rail.form == RailForm.leftRight) {
                railModel.draw(count)
                val t = rail.tile
                if(railroad.map.isPartial(t)) {
                    if(railroad.map.cutStateFor(t).y != 0) {
                        val dt = (if(rail.form == RailForm.leftRight) rail.form.start else rail.form.end).next(t) - t
                        matrix.value = matrix.value.modify(w = w -> w.translate(dt.x, dt.y, 0.001))
                        railModel.draw(count)
                    }
                }
            } else {
                railTurnModel.draw(count)
            }
        }
    }
}

class UndoView(builder : RailroadBuilder) extends InputProcessor with TapProcessor {
    private var font : Font
    def reshape {
        font = fontWith(name = "lucida_grande", 18)
        val textSize = font.measureP(Loc.undo)
        val buttonSize = matrix.p.divBySelf(vec4(textSize * 1.5, 0, 0)).xy
        button.rect = Rect(buttonSize.negate/2, buttonSize)
    }

    private var empty : bool = true
    private val button = Billboard(material = vec4(0.85, 0.9, 0.75, 0.8))
    def draw {
        val rail = builder.railForUndo
        if(rail.isEmpty) {
            empty = true
        } else {
            empty = false
            context.depthTest.disabled {
                button.position = vec3(rail.get.tile, 0)
                button.draw
                font.draw(Loc.undo, color = vec4(0.1, 0.1, 0.1, 1), button.position, TextAlignment(0, 0))
            }
        }
    }

    def process(event : Event) : bool = !empty && event.tap(self)
    def tap(event : Event) : bool = {
        val p = event.locationInViewport
        if(button.contains(p)) {
            builder.undo
            true
        } else false
    }
}

class SwitchView {
    val material = ColorSource(textureFor("Switches.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST))
    val switchStraightModel = MeshModel([
        (Models.switchStraight, material)
    ])
    val switchTurnModel = MeshModel([
        (Models.switchTurn, material)
    ])

    def draw(theSwitch : Switch) {
        val connector = theSwitch.connector
        val rail = theSwitch.activeRail
        val form = rail.form
        var ref = false
        matrix(
            _.modify(w = w -> w.translate(theSwitch.tile.x, theSwitch.tile.y, 0.03))
             .modify(m = m -> {
                val m2 = m.rotate(connector.angle, 0, 1, 0).translate(-0.5, 0, 0)
                if(form.start.x + form.end.x != 0) {
                    val otherConnector = if(form.start == connector) form.end else form.start
                    val x = connector.x
                    val y = connector.y
                    val ox = otherConnector.x
                    val oy = otherConnector.y
                    if(x == -1 && oy == -1 || y == 1 && ox == -1 || y == -1 && ox == 1 || x == 1 && oy == 1) {
                        ref = true
                        m2.scale(1, 1, -1)
                    } else m2
                } else m2
             })
        ) {
            BlendFunction.standard { context.cullFace.disabled {
                if(form.start.x + form.end.x == 0) {
                    switchStraightModel.draw
                } else {
                    switchTurnModel.draw
                }
            }}
        }
    }
}

class LightView(railroad : Railroad) {
    val texture = textureFor("Light.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST)
    val redBodyVao = Models.light.vao(ColorSource(TextureRegion(texture, Rect(0.5, 0, 1, 1))), false)
    val greenBodyVao = Models.light.vao(ColorSource(texture), false)
    val shadowBodyVao = Models.light.vaoShadow

    var _changed = true
    def init {
        weak val weakSelf = self
        railroad.add(changeListener = weakSelf._changed = true)
    }

    private var _matrixArr : [(MatrixModel, RailLight)] = []
    private var _matrixArrShadow : [(MatrixModel, RailLight)] = []
    private def calculateMatrixArr : [(MatrixModel, RailLight)] = railroad.lights.chain.map{light ->
        (matrix.value
            .modify(w = w -> w.translate(light.tile.x, light.tile.y, 0))
            .modify(m = m -> m.rotate(90 + light.connector.angle, 0, 1, 0).translate(0.2, 0, -0.45))
        , light)
    }.toArray

    def drawBodies {
        if(_changed) _matrixArr = calculateMatrixArr
        matrix.push
        _matrixArr.for { p ->
            matrix.value = p.a
            (if(p.b.isGreen)greenBodyVao else redBodyVao).draw
        }
        matrix.pop
    }

    def drawShadow {
        if(_changed) _matrixArrShadow = calculateMatrixArr
        matrix.push
        _matrixArrShadow.for { p ->
            matrix.value = p.a
            shadowBodyVao.draw
        }
        matrix.pop
    }

    private val glows = MeshUnite(Models.lightGreenGlow, Models.lightIndex,
        _.vao(ColorSource(textureFor("LightGlow.png")), false))

    def drawGlows {
        if(!_matrixArr.isEmpty && !context.renderTarget.is<ShadowRenderTarget>) {
            glows.write(_matrixArr.count) {writer ->
                _matrixArr.for{ p ->
                    writer.write(if(p.b.isGreen) Models.lightGreenGlow else Models.lightRedGlow, mat4 = p.a.mwcp)
                }
            }
            context.cullFace.disabled{
                glows.draw
            }
        }
    }
}

class MeshUnite(vertexSample : PArray<MeshData>, indexSample : PArray<uint4>, createVao : Mesh -> VertexArray<_>) {
    private val vbo = VBO.mutMesh
    private val ibo = IBO.mut
    val mesh = Mesh(vbo, ibo)
    val vao = createVao(mesh)

    def write(count : uint4, f : MeshWriter -> void) {
        val w = writer(count)
        f(w)
        w.flush
    }

    def writer(count : uint4) = MeshWriter(vbo, ibo, count, vertexSample, indexSample)

    def draw {
        matrix.identity{
            vao.draw
        }
    }
}

class MeshWriter(vbo : MutableVertexBuffer<MeshData>, ibo : MutableIndexBuffer,
    count : uint4, vertexSample : PArray<MeshData>, indexSample : PArray<uint4>)
{
    private val vertex = VoidRefArray(MeshData.type, vertexSample.count * count)
    private val index = VoidRefArray(UInt4.type, indexSample.count * count)
    private var _vp = vertex
    private var _ip = index
    private var _indexShift : uint4 = 0
    def write(mat4 : mat4) {
        write(vertexSample, indexSample, mat4)
    }

    def write(vertex : PArray<MeshData>, mat4 : mat4) {
        write(vertex, indexSample, mat4)
    }

    def write(vertex : PArray<MeshData>, index : PArray<uint4>, mat4 : mat4) {
        vertex.forRef{ r ->
            _vp = _vp.write(MeshData, r.cast<MeshData> * mat4)
        }
        index.forRef {r ->
            _ip = _ip.write(uInt4 = r.cast<uint4> + _indexShift)
        }
        _indexShift += vertex.count
    }

    def flush {
        vbo.set(vertex)
        ibo.set(index)
    }

    def dealloc {
        vertex.free
        index.free
    }
}

class DamageView {
    val model = MeshModel([(Models.damage, ColorSource(vec4(1, 0, 0, 0.6)))])
    def draw(point : RailPoint) {
        matrix(
            _.modify(w = w -> w.translate(point.point.x, point.point.y, 0.0))
        ) {
            model.draw
        }
    }
}

class BackgroundView(map : MapSso) {
    val mapView = MapSsoView(map, ColorSource(textureFor("Grass.png", GL_NEAREST, GL_NEAREST)))
    def draw {
        mapView.draw
//        mapView.drawLayout
    }
}