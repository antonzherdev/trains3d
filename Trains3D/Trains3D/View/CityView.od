package com.antonzherdev.trains


import com.antonzherdev.eg._

class CityView(level : Level) {
    val cityTexture = textureFor("City.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST)
    val vaoBody = Models.city.vao(StandardMaterial(ColorSource(vec4(1, 0, 0, 1), cityTexture, BlendMode.darken, -1)), shadow = true)

    def draw {
        egPushGroupMarker("Cities")
        level.cities.for{ city ->
            matrix(
                _.modify(w = w -> w.translate(city.tile.x, city.tile.y, 0))
                 .modify(m = m -> m.rotate(city.angle.angle, 0, -1, 0))
            ) {
                vaoBody.draw(StandardMaterial(ColorSource(city.color.color, cityTexture)))

            }
        }
        egPopGroupMarker
    }

    def drawExpected {
        context.depthTest.disabled {
            level.cities.for{ city ->
                city.expectedTrainCounter.for{time ->
                    D2D.drawCircle(ColorSource(vec4(city.expectedTrainColor.color.xyz, 0.85)), vec3(city.tile, 0),
                        radius = 0.04, relative = moveVecFor(level, city)*0.25, start = math.M_PI_2, end = math.M_PI_2 - 2*time*math.M_PI)
                }
            }
        }
    }

    static def moveVecFor(level : Level, city : City) : vec2 =  {
        val cut = level.map.cutStateFor(city.tile)

        var p = vec2(0, 0)
        if(cut.x != 0) p += vec2(1, 0)
        if(cut.x2 != 0) p += vec2(-1, 0)
        if(cut.y != 0) p += vec2(0, -1)
        if(cut.y2 != 0) p += vec2(0, 1)
        p
    }
}

class CallRepairerView(level : Level) extends InputProcessor with TapProcessor {
    private var buttonSize : vec2
    private val text = Text(nil, Loc.callRepairer, vec3(0, 0, 0), TextAlignment(0, 0), vec4(0.1, 0.1, 0.1, 1))
    def reshapeWith(viewport : Rect) {
        val font = fontWith(name = "lucida_grande", 18)
        text.font = font
        buttonSize = font.measureC(Loc.callRepairer)*1.2
    }


    def draw {
        if(!level.railroad.damagesPoints.isEmpty && level.repairer.isEmpty) {
            egPushGroupMarker("Call repairer")
            context.depthTest.disabled { BlendFunction.standard {
            level.cities.for(drawButtonFor(_))
            }}
            egPopGroupMarker
        } else if(!buttons.isEmpty) {
            buttons.clear
        }
    }

    private var buttons = MutableHashMap<City, Billboard>()

    def drawButtonFor(city : City) {
        val bs = buttonSize
        var p = CityView.moveVecFor(level, city)

        val billboard = buttons.objectFor(city, orUpdateWith = Billboard(material = vec4(city.color.color.xyz, 0.8)))
        billboard.position = vec3(city.tile, 0)
        val r = (p - 0.5) * bs
        billboard.rect = Rect(r, bs)
        billboard.draw

        text.position = billboard.position
        text.alignment = TextAlignment(0, 0, false, vec3(r + bs/2, 0))
        text.draw
    }

    def process(event : Event) : bool = {
        event.tap(self)
    }

    def tap(event : Event) : bool = {
        val p = event.locationInViewport
        val b = buttons.chain.find(_.b.contains(p))
        b.for{kv -> level.runRepairerFrom(kv.a)}
        b.isDefined
    }
}