package com.antonzherdev.trains


import com.antonzherdev.eg._

class CityView(level : Level) {
    val cityTexture = textureFor("City.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST)
    val vaoBody = Models.city.vao(StandardMaterial(ColorSource(vec4(1, 0, 0, 1), cityTexture, BlendMode.darken, -1)), shadow = true)

    def draw {
        egPushGroupMarker("Cities")
        level.cities.for{ city ->
            matrix(
                _.modify(w = w -> w.translate(city.tile.x, city.tile.y, 0))
                 .modify(m = m -> m.rotate(city.angle.angle, 0, -1, 0))
            ) {
                vaoBody.draw(StandardMaterial(ColorSource(city.color.color, cityTexture)))

            }
        }
        egPopGroupMarker
    }

    def drawExpected {
        BlendFunction.standard{ context.depthTest.disabled {
            level.cities.for{ city ->
                city.expectedTrainCounter.for{time ->
                    val train = city.expectedTrain
                    val color =
                        if(train.trainType == TrainType.crazy) TrainView.crazyColor(time * Level.trainComingPeriod)
                        else train.color.trainColor
                    D2D.drawCircle(backColor = vec4(color.xyz*0.5, 0.85), strokeColor = vec4(0, 0, 0, 0.2),
                        at = vec3(city.tile, 0), radius = 0.04, relative = moveVecFor(level, city)*0.25,
                        segmentColor = color,
                        start = math.M_PI_2, end = math.M_PI_2 - 2*time*math.M_PI
                        )
                }
            }
        }}
    }

    static def moveVecFor(level : Level, city : City) : vec2 =  {
        val cut = level.map.cutStateFor(city.tile)

        var p = vec2(0, 0)
        if(cut.x != 0) p += vec2(1, 0)
        if(cut.x2 != 0) p += vec2(-1, 0)
        if(cut.y != 0) p += vec2(0, -1)
        if(cut.y2 != 0) p += vec2(0, 1)
        p
    }
}

class CallRepairerView(level : Level) extends InputProcessor {
    private var buttonSize : vec2
    private var font : Font
    def reshape {
        font = fontWith(name = "lucida_grande", 18)
        buttonSize = font.measureC(Loc.callRepairer)*1.2
    }


    def draw {
        if(!level.railroad.damagesPoints.isEmpty && level.repairer.isEmpty) {
            egPushGroupMarker("Call repairer")
            context.depthTest.disabled { BlendFunction.standard {
                level.cities.for{city ->
                    if(city.canRunNewTrain) drawButtonFor(city)
                }
            }}
            egPopGroupMarker
        } else if(!buttons.isEmpty) {
            buttons.clear
            texts.clear
        }
    }

    private var buttons = MutableHashMap<City, Billboard>()
    private var texts = MutableHashMap<City, Text>()

    def drawButtonFor(city : City) {
        val bs = buttonSize
        var p = CityView.moveVecFor(level, city)

        val billboard = buttons.objectFor(city, orUpdateWith = Billboard(material = vec4(city.color.color.xyz, 0.8)))
        billboard.position = vec3(city.tile, 0)
        val r = (p - 0.5) * bs
        billboard.rect = Rect(r, bs)
        billboard.draw

        val text = texts.objectFor(city, orUpdateWith =  Text(font, Loc.callRepairer, vec3(0, 0, 0), TextAlignment(0, 0), vec4(0.1, 0.1, 0.1, 1)))
        text.position = billboard.position
        text.alignment = TextAlignment(0, 0, false, vec3(r + bs/2, 0))
        text.draw
    }

    def recognizers : Recognizers = Recognizer(Tap()) { event : Event ->
        val p = event.locationInViewport
        val b = buttons.chain.find(_.b.contains(p))
        b.for{kv -> if(kv.a.canRunNewTrain) level.runRepairerFrom(kv.a)}
        b.isDefined
    }
}