package com.antonzherdev.trains

class LevelView(level : Level) extends LayerView with InputProcessor {
    val name = "Level"
    private val cityView : CityView
    private val railroadView : RailroadView
    val trainModels : TrainModels
    val trainsView = MArray<TrainView>()
    private val treeView : TreeView
    private val callRepairerView : CallRepairerView
    private val precipitationView : PrecipitationView?
    private val rewindButtonView : RewindButtonView

    private val onTrainAdd = level.trainWasAdded.observe{ train ->
        Director.current.onGLThread{
            trainsView.append(TrainView(trainModels, train))
        }
        if(train.trainType == TrainType.crazy) {
            GameDirector.instance.showHelp(key = "help.crazy", Loc.helpCrazy, after = 2)
        }
    }
    private val onTrainRemove = level.trainWasRemoved.observe{ train ->
        Director.current.onGLThread{
            trainsView.mutableFilter(_.train != train)
        }
    }
    private val modeChangeObs = RailroadBuilder.modeNotification.observe(level.builder) {mode ->
        _move.panEnabled = (mode == RailroadBuilderMode.simple)
    }


    val environment = Environment(ambientColor = vec4(0.7, 0.7, 0.7, 1), lights = [
        DirectLight(
            color = vec4(vec3(0.2, 0.2, 0.2) + vec3(0.4, 0.4, 0.4)*level.rules.weatherRules.sunny, 1.0),
            direction = vec3(-0.15, 0.35, -0.3).normalize,
            hasShadows = level.rules.weatherRules.sunny > 0.0 && GameDirector.instance.showShadows,
            shadowsProjectionMatrix = {
                var m : mat4
                if(level.map.size == vec2i(7, 5)) m = mat4.ortho(-2.5, 8.8, -2.9, 4.6, -3.0, 6.3)
                else if(level.map.size == vec2i(5, 5)) m = mat4.ortho(-2.4, 7.3, -2.4, 3.9, -2, 5.9)
                else if(level.map.size == vec2i(5, 3)) m = mat4.ortho(-2, 5.9, -2.2, 2.7, -2, 4.5)
                else throw "Define shadow matrix for this map size"
                m
            }
        )])

    private val moveScaleObserver : Observer<float>
    def init {
        context.clear
        context.environment = environment
        D2D.install
        treeView = TreeView(level.forest)
        cityView = CityView(level)
        callRepairerView = CallRepairerView(level)
        trainModels = TrainModels()
        precipitationView = level.rules.weatherRules.precipitation ?> (PrecipitationView(level.weather, _))
        val cameraReserves =
            if(egPlatform.isPad) {
                if(context.viewSize.value.ratio < 4.0/3 + 0.01) CameraReserve(0, 0, top = 0.5, bottom = 0.1)
                else CameraReserve(0, 0, top = 0.2, bottom = 0.1)
            } else if(egPlatform.isPhone) {
                if(egPlatform.isIOSLess("7") < 0) CameraReserve(0, 0, top = 0.3, bottom = 0.1)
                else CameraReserve(0, 0, top = 0.2, bottom = 0.1)
            } else CameraReserve(0, 0, top = 0.3, bottom = 0.0)
        level.cameraReserves.value = cameraReserves
        level.viewRatio.connect(context.viewSize.map(_.ratio))
        _move = CameraIsoMove(CameraIso(level.map.size, reserve = cameraReserves, viewportRatio = 1.6), 1.0, 2.0, 1, 2)
        railroadView = RailroadView(self, level)
        level.scale.connect(_move.scale)
        moveScaleObserver = _move.scale.observe { s ->
            if(s > 1.0) GameDirector.instance.showHelp("help.zoom", Loc.helpInZoom)
        }
        rewindButtonView = RewindButtonView(level)
    }

    def prepare {
        treeView.prepare
        railroadView.prepare
    }

    def complete {
        treeView.complete
        trainsView.for(_.complete)
        precipitationView ?> (_.complete)
    }

    def draw {
        level.railroad.state.waitAndOnSuccess(1) {rrState ->
            railroadView.drawBackground(rrState)
            cityView.draw

            egPushGroupMarker("Trains")
            trainsView.for(_.draw)
            egPopGroupMarker

            if(!context.renderTarget.isShadow) railroadView.drawLightGlows(rrState)

            if(!context.renderTarget.isShadow) {
                railroadView.drawSwitches(rrState)
            }
            treeView.draw
            if(!context.renderTarget.isShadow) {
                railroadView.drawForeground(rrState)
                egPushGroupMarker("Smoke")
                trainsView.for(_.drawSmoke)
                egPopGroupMarker
                rewindButtonView.draw

                cityView.drawExpected
                callRepairerView.draw(rrState)
                precipitationView ?> (_.draw)
            }
        }
    }

    private var _move : CameraIsoMove
    def camera : Camera = _move.camera
    def cameraMove : CameraIsoMove = _move

    def updateWith(delta : float) {
        railroadView.updateWith(delta)
        precipitationView ?> (_.updateWith(delta))
        trainsView.for(_.updateWith(delta))
    }

    private val railroadBuilderProcessor = RailroadBuilderProcessor(level.builder)
    private val switchProcessor = SwitchProcessor(level)

    def recognizers : Recognizers =
        _move.recognizers +
        callRepairerView.recognizers +
        rewindButtonView.recognizers +
        railroadView.recognizers +
        switchProcessor.recognizers +
        railroadBuilderProcessor.recognizers

    def reshapeWith(viewport : Rect) {
        val r = viewport.size.x/viewport.size.y
        _move.viewportRatio = r
        matrix.value = camera.matrixModel
    }
}

class PrecipitationView extends Updatable {
    static def apply(weather : Weather, precipitation : Precipitation) : PrecipitationView = {
        if(precipitation.tp == PrecipitationType.rain) RainView(weather, precipitation.strength)
        else if(precipitation.tp == PrecipitationType.snow) SnowView(weather, precipitation.strength)
        else throw "Unknown precipitation type"
    }

    def draw
    def complete
    def updateWith(delta : float)
}

class RewindButtonView(level : Level) extends InputProcessor {
    private var empty : bool = true
    private val buttonPos = Var<vec3>(vec3(0, 0, 0))
    private val animation = Progress.trapezium(0.1, 0.5)
    private val button = Sprite(
        visible = React(level.rewindButton.animation.isRunning, level.history.canRewind){a, b -> a && b},
        material = level.rewindButton.animation.time.map{time ->
            ColorSource(color = vec4(animation(time)), scaledTextureFor("Pause", TextureFormat.RGBA4).region(64, 64, 32, 32))
        },
        position = level.rewindButton.position.map(vec3(_))
    )
    private val buttonObs = button.tap.observe{_ ->GameDirector.instance.runRewind(level)}

    def draw {
        context.depthTest.disabled { BlendFunction.premultiplied {
            button.draw
        } }
    }

    def recognizers : Recognizers = button.recognizer
}