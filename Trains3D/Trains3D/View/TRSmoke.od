import CNData

import EG
import EGGL
import EGTypes
import EGBuffer
import EGShader
import EGTexture
import EGMatrix
import EGSurface
import EGMesh
import EGVec

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGController {
    private var _particles = CNList<TRSmokeParticle>()
    def particles = _particles
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.005
    private var emitTime = 0.0

    def updateWith(delta : float) {
        emitTime += delta
        while(emitTime > emitEvery) {
            emitTime -= emitEvery
            createParticle
        }
        _particles = _particles.filter(_.isLive)
        _particles.for(_.updateWith(delta))
    }

    def createParticle {
        val fPos = if(train.isBack) engine.tail.point else engine.head.point
        val bPos = if(train.isBack) engine.head.point else engine.tail.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle(randomMax(3))
        p.position = EGVec3(emitterPos.x + randomFloatGap(-0.01, 0.01), emitterPos.y + randomFloatGap(-0.01, 0.01), emitterPos.z)
        randomFloat
        val s = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        p.speed = EGVec3(-s.x * randomPercents(0.6), -s.y * randomPercents(0.6), s.z * randomPercents(0.6))
        _particles = CNList(p, _particles)
    }
}

class TRSmokeParticle(texture : int) extends EGController {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 4
    static val dragCoefficient = 1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

struct TRSmokeBufferData(x : float4, y : float4, z : float4, uvx : float4, uvy : float4, time : float4, textureX : float4, textureY : float4)

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(6*4)
    val indexBuffer = EGIndexBuffer<uint4>()
    val shader = TRSmokeShader.instance
    val texture = EG.textureFor("Smoke.png")

    def begin {
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_CULL_FACE)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    }

    def end {
        glDisable(GL_BLEND)
        glEnable(GL_CULL_FACE)
        glEnable(GL_DEPTH_TEST)
    }

    static val particleSize = 0.03
    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(TRSmokeBufferData.type, 4*n)
        val indexArr = CNMutablePArray(ODUInt4.type, 6*n)
        var i : uint = 0
        particles.for{p ->
            val v = p.position
            val t : float4 = p.time
            val tx : float4 = if(p.texture >= 2) 0.5 else 0
            val ty : float4 = if(p.texture == 1 || p.texture == 3) 0.5 else 0
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, -particleSize, -particleSize, t, tx, ty))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z,  particleSize, -particleSize, t, tx + 0.5, ty))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z,  particleSize,  particleSize, t, tx + 0.5, ty + 0.5))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, -particleSize,  particleSize, t, tx, ty + 0.5))
            indexArr.write(uInt4 = i)
            indexArr.write(uInt4 = i + 1)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 3)
            indexArr.write(uInt4 = i)
            i += 4
        }
        positionBuffer.set(positionArr)
        indexBuffer.set(indexArr)

        shader(texture, positionBuffer) {
            indexBuffer.draw
        }
    }
}

class TRSmokeShader {
    static val vertex =
        "attribute vec3 position;
         attribute vec2 model;
         attribute float vertexLife;
         attribute vec2 vertexUV;
         uniform mat4 wc;
         uniform mat4 p;

         varying vec2 UV;
         varying float life;

         void main(void) {
            float size = 0.03;
            vec4 pos = wc*vec4(position, 1);
            pos.x += model.x;
            pos.y += model.y;
            gl_Position = p*pos;
            UV = vertexUV;
            life = vertexLife;
        }"
    static val fragment =
        "varying vec2 UV;
         varying float life;

         uniform sampler2D texture;

         void main(void) {
            gl_FragColor = texture2D(texture, UV);
            gl_FragColor.w *= min(0.7, 2.8 - 0.7*life);
         }"
    static val instance = TRSmokeShader()
    val program = EGShaderProgram(vertex, fragment)
    val positionSlot = program.attributeFor("position")
    val modelSlot = program.attributeFor("model")
    val lifeSlot = program.attributeFor("vertexLife")
    val uvSlot = program.attributeFor("vertexUV")
    val m = EGMatrix.identity.rotate(60, 1, 0, 0).rotate(45, 0, 1, 0)
    val wcUniform = program.uniformFor("wc")
    val pUniform = program.uniformFor("p")

    def apply(texture : EGFileTexture, positionBuffer: EGVertexBuffer<float4>, draw : () -> void) {
        program {
            texture {
                positionBuffer {
                    positionSlot.setFromBufferWith(stride = 8*4, valuesCount = 3, GL_FLOAT, shift = 0)
                    modelSlot.setFromBufferWith(stride = 8*4, valuesCount = 2, GL_FLOAT, shift = 3*4)
                    lifeSlot.setFromBufferWith(stride = 8*4, valuesCount = 1, GL_FLOAT, shift = 5*4)
                    uvSlot.setFromBufferWith(stride = 8*4, valuesCount = 2, GL_FLOAT, shift = 6*4)
                    wcUniform.set(matrix = EG.matrix.value.wc)
                    pUniform.set(matrix = EG.matrix.value.p)

                    draw()
                }
            }
        }
    }
}