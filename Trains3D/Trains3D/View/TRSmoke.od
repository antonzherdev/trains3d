import CNData

import EG
import EGGL
import EGTypes
import EGShader
import EGTexture
import EGMatrix
import EGSurface
import EGMesh
import EGVec
import EGBillboard
import EGParticleSystem

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGParticleSystem<TRSmokeBufferData, TRSmokeParticle> {
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.005
    private var emitTime = 0.0

    def generateParticlesWith(delta : float) {
        emitTime += delta
        while(emitTime > emitEvery) {
            emitTime -= emitEvery
            emitParticle
        }
    }

    def generateParticle : TRSmokeParticle =  {
        val fPos = if(train.isBack) engine.tail.point else engine.head.point
        val bPos = if(train.isBack) engine.head.point else engine.tail.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle(randomMax(3))
        p.position = EGVec3(emitterPos.x + randomFloatGap(-0.01, 0.01), emitterPos.y + randomFloatGap(-0.01, 0.01), emitterPos.z)
        randomFloat
        val s = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        p.speed = EGVec3(-s.x * randomPercents(0.6), -s.y * randomPercents(0.6), s.z * randomPercents(0.6))
        p
    }
}

class TRSmokeParticle(texture : int) extends EGParticle(4) {
    var position : EGVec3
    var speed : EGVec3
    static val dragCoefficient = 1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        super.updateWith(delta)
        val a = speed.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
    }

    static val particleSize : float4 = 0.03
    def writeTo(array : CNVoidRefArray) : CNVoidRefArray = {
        val t = lifeTime
        val tx : float4 = if(texture >= 2) 0.5 else 0
        val ty : float4 = if(texture == 1 || texture == 3) 0.5 else 0
        array.write(TRSmokeBufferData, TRSmokeBufferData(position, EGVec2(-particleSize, -particleSize), EGVec2(tx, ty), t))
             .write(TRSmokeBufferData, TRSmokeBufferData(position, EGVec2(particleSize, -particleSize), EGVec2(tx + 0.5, ty), t))
             .write(TRSmokeBufferData, TRSmokeBufferData(position, EGVec2(particleSize,  particleSize), EGVec2(tx + 0.5, ty + 0.5), t))
             .write(TRSmokeBufferData, TRSmokeBufferData(position, EGVec2(-particleSize,  particleSize), EGVec2(tx, ty + 0.5), t))
    }
}

struct TRSmokeBufferData(position : EGVec3, model : EGVec2, uv : EGVec2, time : float4)

class TRSmokeView extends EGParticleSystemView<TRSmokeBufferData, TRSmokeParticle>(TRSmokeBufferData.type) {
    val shader = TRSmokeShader.instance
    val material = EGSimpleMaterial(EG.textureFor("Smoke.png"))
    def vertexCount : uint = 4
}

class TRSmokeShader extends EGBillboardShader(EGShaderProgram(vertex, fragment), true) {
    static val vertex = vertexTextWith(
           texture = true,
        parameters = "attribute float vertexLife;
                      varying float life;",
              code = "life = vertexLife;")
    static val fragment = fragmentTextWith(
           texture = true,
        parameters = "varying float life;",
              code = "gl_FragColor.w *= min(0.7, 2.8 - 0.7*life);")
    static val instance = TRSmokeShader()
    val lifeSlot = program.attributeFor("vertexLife")

    def load(vertexBuffer : EGVertexBuffer<_>, material : EGSimpleMaterial) {
        super.load(vertexBuffer, material)
        lifeSlot.setFromBufferWith(vertexBuffer.stride, valuesCount = 1, GL_FLOAT, shift = 7*4)
    }
}