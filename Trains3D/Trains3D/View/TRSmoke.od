import CNData

import EG
import EGGL
import EGTypes
import EGBuffer
import EGShader
import EGContext
import EGTexture
import EGMatrix
import EGSurface
import EGMesh

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGController {
    private var _particles = CNList<TRSmokeParticle>()
    def particles = _particles
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.1
    private var emitTime = 0.0

    def updateWith(delta : float) {
        emitTime += delta
        if(emitTime > emitEvery) {
            emitTime -= emitEvery
            createParticle
        }
        _particles = _particles.filter(_.isLive)
        _particles.for(_.updateWith(delta))
    }

    def createParticle {
        val fPos = if(train.isBack) engine.backConnector.point else engine.frontConnector.point
        val bPos = if(train.isBack) engine.frontConnector.point else engine.backConnector.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle()
        p.position = emitterPos
        p.speed = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        _particles = CNList(p, _particles)
    }
}

class TRSmokeParticle extends EGController {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 10
    static val dragCoefficient = 0.1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.sqr.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

struct TRSmokeBufferData(x : float4, y : float4, z : float4, uvx : float4, uvy : float4)

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(3*4)
    val indexBuffer = EGIndexBuffer<uint4>()
    val shader = TRSmokeShader.instance
    val texture = EG.textureFor("Smoke.png")
    val surface = EGSurface(1024, 512).init

    def begin {
        surface.bind
        glClearColor(0.0, 0.0, 0.0, 1)
        egClear
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_CULL_FACE)
        glEnable(GL_BLEND)
        glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)
    }

    def end {
        surface.unbind
        glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA)
        surface.drawFullScreen

        glDisable(GL_BLEND)
        glEnable(GL_CULL_FACE)
        glEnable(GL_DEPTH_TEST)
    }

    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(TRSmokeBufferData.type, 6*n)
        val indexArr = CNMutablePArray(ODUInt4.type, 6*n)
        var i : uint = 0
        particles.for{p ->
            val v = p.position
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 0, 0))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 1, 0))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 1, 1))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 0, 1))
            indexArr.write(uInt4 = i)
            indexArr.write(uInt4 = i + 1)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 3)
            indexArr.write(uInt4 = i)
            i += 4
        }
        positionBuffer.set(positionArr)
        indexBuffer.set(indexArr)

        shader(texture, positionBuffer) {
            indexBuffer.draw
        }
    }
}

class TRSmokeShader {
    static val vertex =
        "attribute vec3 position;
         attribute vec2 vertexUV;
         uniform mat4 m;
         uniform mat4 wcp;

         varying vec2 UV;

         void main(void) {
            vec4 model = m * vec4(0.2*vertexUV.x - 0.1, 0.2*vertexUV.y - 0.1, 0, 1);
            gl_Position = wcp * (vec4(position, 0) + model);
            UV = vertexUV;
        }"
    static val fragment =
        "varying vec2 UV;

         uniform sampler2D texture;

         void main(void) {
            gl_FragColor = texture2D(texture, UV);
         }"
    static val instance = TRSmokeShader()
    val program = EGShaderProgram(vertex, fragment)
    val positionSlot = program.attributeFor("position")
    val uvSlot = program.attributeFor("vertexUV")
    val m = EGMatrix.identity.rotate(60, 1, 0, 0).rotate(45, 0, 1, 0)
    val wcpUniform = program.uniformFor("wcp")
    val mUniform = program.uniformFor("m")

    def apply(texture : EGFileTexture, positionBuffer: EGVertexBuffer<float4>, draw : () -> void) {
        program {
            texture {
                positionBuffer {
                    positionSlot.setFromBufferWith(stride = 5*4, valuesCount = 3, GL_FLOAT, shift = 0)
                    uvSlot.setFromBufferWith(stride = 5*4, valuesCount = 2, GL_FLOAT, shift = 3*4)
                    wcpUniform.set(matrix = EG.context.wcp)
                    mUniform.set(matrix = m)

                    draw()
                }
            }
        }
    }
}