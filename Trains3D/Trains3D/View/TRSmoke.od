import CNData

import EG
import EGGL
import EGTypes
import EGBuffer
import EGShader
import EGContext

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGController {
    private var _particles = CNList<TRSmokeParticle>()
    def particles = _particles
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.1
    private var emitTime = 0.0

    def updateWith(delta : float) {
        emitTime += delta
        if(emitTime > emitEvery) {
            emitTime -= emitEvery
            createParticle
        }
        _particles = _particles.filter(_.isLive)
        _particles.for(_.updateWith(delta))
    }

    def createParticle {
        val fPos = engine.frontConnector.point
        val bPos = engine.backConnector.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle()
        p.position = emitterPos
        p.speed = EGVec3(delta.set(length = train.speed), zSpeed)
        _particles = CNList(p, _particles)
    }
}

class TRSmokeParticle extends EGController {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 10
    static val dragCoefficient = 0.1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.sqr.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(3*4)
    val cornerBuffer = EGVertexBuffer<float4>(4)
    val indexBuffer = EGIndexBuffer<int>()
    val shader = TRSmokeShader.instance
    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(EGVec3.type, 4*n)
        val cornerArr = CNMutablePArray(ODFloat4.type, 4*n)
        val corners : CNPArray<float4> = [0, 1, 2, 3]
        particles.for{p ->
            positionArr.write(item = p.position, times = 4)
            cornerArr.write(array = corners)
        }
        positionBuffer.set(positionArr)
        cornerBuffer.set(cornerArr)

        shader(positionBuffer, cornerBuffer) {
            indexBuffer.draw
        }
    }
}

class TRSmokeShader {
    static val vertex =
        "attribute vec3 position;
         attribute float corner;
         uniform mat4 c;
         uniform mat4 p;

         void main(void) {
            vec4 pos = c * vec4(position, 1);
            if(corner <= 0.1) pos = vec4(pos.x - 0.1, pos.y - 0.1, pos.z, 1);
            else if(corner <= 1.1) pos = vec4(pos.x + 0.1, pos.y - 0.1, pos.z, 1);
            else if(corner <= 2.1) pos = vec4(pos.x + 0.1, pos.y + 0.1, pos.z, 1);
            else if(corner <= 3.1) pos = vec4(pos.x - 0.1, pos.y + 0.1, pos.z, 1);

            gl_Position = p * pos;
         }"
    static val fragment =
        "void main(void) {
            gl_FragColor = vec4(1, 0, 0, 0.5);
         }"
    static val instance = TRSmokeShader()
    val program = EGShaderProgram(vertex, fragment)
    val positionSlot = program.attributeFor("position")
    val cornerSlot = program.attributeFor("corner")
    val cUniform = program.uniformFor("c")
    val pUniform = program.uniformFor("p")

    def apply(positionBuffer: EGVertexBuffer<float4>, cornerBuffer : EGVertexBuffer<int>, draw : () -> void) {
        program {
            positionBuffer {
                positionSlot.setFromBufferWith(stride = 3*4, valuesCount = 3, GL_FLOAT, shift = 0)
            }
            cornerBuffer {
                cornerSlot.setFromBufferWith(stride = 1, valuesCount = 1, GL_BYTE, shift = 0)
            }
            cUniform.set(matrix = EG.context.c)
            pUniform.set(matrix = EG.context.p)

            draw()
        }
    }
}