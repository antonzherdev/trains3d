import CNData

import EG
import EGGL
import EGTypes
import EGShader
import EGTexture
import EGMatrix
import EGSurface
import EGMesh
import EGVec
import EGBillboard
import EGParticleSystem

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGParticleSystem<TRSmokeParticle> {
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.005
    private var emitTime = 0.0

    def generateParticlesWith(delta : float) {
        emitTime += delta
        while(emitTime > emitEvery) {
            emitTime -= emitEvery
            emitParticle
        }
    }

    def generateParticle : TRSmokeParticle =  {
        val fPos = if(train.isBack) engine.tail.point else engine.head.point
        val bPos = if(train.isBack) engine.head.point else engine.tail.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle(randomMax(3))
        p.position = EGVec3(emitterPos.x + randomFloatGap(-0.01, 0.01), emitterPos.y + randomFloatGap(-0.01, 0.01), emitterPos.z)
        randomFloat
        val s = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        p.speed = EGVec3(-s.x * randomPercents(0.6), -s.y * randomPercents(0.6), s.z * randomPercents(0.6))
        p
    }
}

class TRSmokeParticle(texture : int) extends EGParticle {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 4
    static val dragCoefficient = 1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

struct TRSmokeBufferData(x : float4, y : float4, z : float4, uvx : float4, uvy : float4, time : float4, textureX : float4, textureY : float4)

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(8*4)
    val indexBuffer = EGIndexBuffer<uint4>()
    val shader = TRSmokeShader.instance
    val texture = EGSimpleMaterial(EG.textureFor("Smoke.png"))

    def begin {
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_CULL_FACE)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    }

    def end {
        glDisable(GL_BLEND)
        glEnable(GL_CULL_FACE)
        glEnable(GL_DEPTH_TEST)
    }

    static val particleSize = 0.03
    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(TRSmokeBufferData.type, 4*n)
        val indexArr = CNMutablePArray(ODUInt4.type, 6*n)
        var i : uint = 0
        particles.for{p ->
            val v = p.position
            val t : float4 = p.time
            val tx : float4 = if(p.texture >= 2) 0.5 else 0
            val ty : float4 = if(p.texture == 1 || p.texture == 3) 0.5 else 0
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, -particleSize, -particleSize, tx, ty, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z,  particleSize, -particleSize, tx + 0.5, ty, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z,  particleSize,  particleSize, tx + 0.5, ty + 0.5, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, -particleSize,  particleSize, tx, ty + 0.5, t))
            indexArr.write(uInt4 = i)
            indexArr.write(uInt4 = i + 1)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 3)
            indexArr.write(uInt4 = i)
            i += 4
        }
        positionBuffer.set(positionArr)
        indexBuffer.set(indexArr)

        shader.draw(texture, EGMesh(vertexBuffer = positionBuffer, indexBuffer))
    }
}

class TRSmokeShader extends EGBillboardShader(EGShaderProgram(vertex, fragment), true) {
    static val vertex = vertexTextWith(
           texture = true,
        parameters = "attribute float vertexLife;
                      varying float life;",
              code = "life = vertexLife;")
    static val fragment = fragmentTextWith(
           texture = true,
        parameters = "varying float life;",
              code = "gl_FragColor.w *= min(0.7, 2.8 - 0.7*life);")
    static val instance = TRSmokeShader()
    val lifeSlot = program.attributeFor("vertexLife")

    def load(vertexBuffer : EGVertexBuffer<_>, material : EGSimpleMaterial) {
        super.load(vertexBuffer, material)
        lifeSlot.setFromBufferWith(vertexBuffer.stride, valuesCount = 1, GL_FLOAT, shift = 7*4)
    }
}