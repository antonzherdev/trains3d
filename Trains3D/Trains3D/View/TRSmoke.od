import CNData

import EG
import EGGL
import EGTypes
import EGBuffer
import EGShader
import EGContext

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGController {
    private var _particles = CNList<TRSmokeParticle>()
    def particles = _particles
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.1
    private var emitTime = 0.0

    def updateWith(delta : float) {
        emitTime += delta
        if(emitTime > emitEvery) {
            emitTime -= emitEvery
            createParticle
        }
        _particles = _particles.filter(_.isLive)
        _particles.for(_.updateWith(delta))
    }

    def createParticle {
        val fPos = if(train.isBack) engine.backConnector.point else engine.frontConnector.point
        val bPos = if(train.isBack) engine.frontConnector.point else engine.backConnector.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle()
        p.position = emitterPos
        p.speed = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        _particles = CNList(p, _particles)
    }
}

class TRSmokeParticle extends EGController {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 10
    static val dragCoefficient = 0.1 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.sqr.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(3*4)
    val indexBuffer = EGIndexBuffer<int>()
    val shader = TRSmokeShader.instance
    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(EGVec3.type, 4*n)
        val indexArr = CNMutablePArray(ODUInt4.type, 6*n)
        var i : uint = 0
        particles.for{p ->
            val v = p.position
            positionArr.write(item = EGVec3(v.x - 0.1, v.y - 0.1, v.z))
            positionArr.write(item = EGVec3(v.x + 0.1, v.y - 0.1, v.z))
            positionArr.write(item = EGVec3(v.x + 0.1, v.y + 0.1, v.z))
            positionArr.write(item = EGVec3(v.x - 0.1, v.y + 0.1, v.z))
            indexArr.write(uInt4 = i)
            indexArr.write(uInt4 = i + 1)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 3)
            indexArr.write(uInt4 = i)
            i += 4
        }
        positionBuffer.set(positionArr)
        indexBuffer.set(indexArr)

        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        shader(positionBuffer) {
            indexBuffer.draw
        }
        glDisable(GL_BLEND)
    }
}

class TRSmokeShader {
    static val vertex =
        "attribute vec3 position;
         uniform mat4 wcp;

         void main(void) {
            gl_Position = wcp * vec4(position, 1);
         }"
    static val fragment =
        "void main(void) {
            gl_FragColor = vec4(1, 0, 0, 0.5);
         }"
    static val instance = TRSmokeShader()
    val program = EGShaderProgram(vertex, fragment)
    val positionSlot = program.attributeFor("position")
    val wcpUniform = program.uniformFor("wcp")

    def apply(positionBuffer: EGVertexBuffer<float4>, draw : () -> void) {
        program {
            positionBuffer {
                positionSlot.setFromBufferWith(stride = 3*4, valuesCount = 3, GL_FLOAT, shift = 0)
                wcpUniform.set(matrix = EG.context.wcp)

                draw()
            }
        }
    }
}