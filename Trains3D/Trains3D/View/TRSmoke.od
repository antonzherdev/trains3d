import CNData

import EG
import EGGL
import EGTypes
import EGBuffer
import EGShader
import EGContext
import EGTexture
import EGMatrix
import EGSurface
import EGMesh

import TRTrain
import TRRailPoint

class TRSmoke(weak train : TRTrain) extends EGController {
    private var _particles = CNList<TRSmokeParticle>()
    def particles = _particles
    private val engine : TRCar = train.cars.head.get
    private val tubePos = engine.carType.engineType.get.tubePos
    private static val zSpeed = 0.1
    private static val emitEvery = 0.005
    private var emitTime = 0.0

    def updateWith(delta : float) {
        emitTime += delta
        while(emitTime > emitEvery) {
            emitTime -= emitEvery
            createParticle
        }
        _particles = _particles.filter(_.isLive)
        _particles.for(_.updateWith(delta))
    }

    def createParticle {
        val fPos = if(train.isBack) engine.tail.point else engine.head.point
        val bPos = if(train.isBack) engine.head.point else engine.tail.point
        val delta = bPos.sub(fPos)
        val tubeXY = fPos.add(delta.set(length = tubePos.x))
        val emitterPos = EGVec3(tubeXY, tubePos.z)

        val p = TRSmokeParticle()
        p.position = EGVec3(emitterPos.x + randomFloatGap(-0.01, 0.01), emitterPos.y + randomFloatGap(-0.01, 0.01), emitterPos.z)
        randomFloat
        val s = EGVec3((if(train.isBack) fPos.sub(bPos) else delta).set(length = train.speedFloat), zSpeed)
        p.speed = EGVec3(-s.x * randomPercents(0.4), -s.y * randomPercents(0.4), s.z * randomPercents(0.4))
        _particles = CNList(p, _particles)
    }
}

class TRSmokeParticle extends EGController {
    var position : EGVec3
    var speed : EGVec3
    var time = 0.0
    static val lifeTime = 4
    static val dragCoefficient = 0.5 // air resistance coefficient | a = -dragCoefficient * sqr(speed)

    def updateWith(delta : float) {
        val a = speed.mul(-dragCoefficient)
        speed = speed.add(a.mul(delta))
        position = position.add(speed.mul(delta))
        time += delta
    }

    def isLive = time < lifeTime
}

struct TRSmokeBufferData(x : float4, y : float4, z : float4, uvx : float4, uvy : float4, time : float4)

class TRSmokeView {
    val positionBuffer = EGVertexBuffer<float4>(6*4)
    val indexBuffer = EGIndexBuffer<uint4>()
    val shader = TRSmokeShader.instance
    val texture = EG.textureFor("Smoke.png")

    def begin {
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_CULL_FACE)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    }

    def end {
        glDisable(GL_BLEND)
        glEnable(GL_CULL_FACE)
        glEnable(GL_DEPTH_TEST)
    }

    def draw(smoke : TRSmoke) {
        val particles = smoke.particles
        val n = particles.count
        if(n == 0) return nil

        val positionArr = CNMutablePArray(TRSmokeBufferData.type, 4*n)
        val indexArr = CNMutablePArray(ODUInt4.type, 6*n)
        var i : uint = 0
        particles.for{p ->
            val v = p.position
            val t = p.time
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 0, 0, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 1, 0, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 1, 1, t))
            positionArr.write(item = TRSmokeBufferData(v.x, v.y, v.z, 0, 1, t))
            indexArr.write(uInt4 = i)
            indexArr.write(uInt4 = i + 1)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 2)
            indexArr.write(uInt4 = i + 3)
            indexArr.write(uInt4 = i)
            i += 4
        }
        positionBuffer.set(positionArr)
        indexBuffer.set(indexArr)

        shader(texture, positionBuffer) {
            indexBuffer.draw
        }
    }
}

class TRSmokeShader {
    static val vertex =
        "attribute vec3 position;
         attribute vec2 vertexUV;
         attribute float vertexLife;
         uniform mat4 m;
         uniform mat4 wcp;

         varying vec2 UV;
         varying float life;

         void main(void) {
            float size = 0.03;
            vec4 model = m * vec4(2.0*size*vertexUV.x - size, 2.0*size*vertexUV.y - size, 0, 1);
            gl_Position = wcp * (vec4(position, 0) + model);
            UV = vertexUV;
            life = vertexLife;
        }"
    static val fragment =
        "varying vec2 UV;
         varying float life;

         uniform sampler2D texture;

         void main(void) {
            gl_FragColor = texture2D(texture, UV);
            if(gl_FragColor.x > 0.7) {
                gl_FragColor.w = min(0.7, 2.8 - 0.7*life);
            } else {
                gl_FragColor.w = 0.0;
            }
         }"
    static val instance = TRSmokeShader()
    val program = EGShaderProgram(vertex, fragment)
    val positionSlot = program.attributeFor("position")
    val uvSlot = program.attributeFor("vertexUV")
    val lifeSlot = program.attributeFor("vertexLife")
    val m = EGMatrix.identity.rotate(60, 1, 0, 0).rotate(45, 0, 1, 0)
    val wcpUniform = program.uniformFor("wcp")
    val mUniform = program.uniformFor("m")

    def apply(texture : EGFileTexture, positionBuffer: EGVertexBuffer<float4>, draw : () -> void) {
        program {
            texture {
                positionBuffer {
                    positionSlot.setFromBufferWith(stride = 6*4, valuesCount = 3, GL_FLOAT, shift = 0)
                    uvSlot.setFromBufferWith(stride = 6*4, valuesCount = 2, GL_FLOAT, shift = 3*4)
                    lifeSlot.setFromBufferWith(stride = 6*4, valuesCount = 1, GL_FLOAT, shift = 5*4)
                    wcpUniform.set(matrix = EG.context.wcp)
                    mUniform.set(matrix = m)

                    draw()
                }
            }
        }
    }
}