import EGGL
import EGMesh
import EG
import EGTexture
import EGMaterial
import EGContext
import EGTypes

import TRRailroad
import TRRailPoint
import TR3D

import "TR3DRailTurn.h"
import "TR3DSwitch.h"

class TRRailroadView {
    private val railView = TRRailView()
    private val switchView = TRSwitchView()
    private val lightView = TRLightView()
    private val damageView = TRDamageView()

    def draw(railroad : TRRailroad) {
        railroad.rails.for(railView.draw(_))
        railroad.switches.for(switchView.draw(_))
        railroad.lights.for(lightView.draw(_))
        railroad.builder.rail.for(railView.draw(_))
        railroad.damagesPoints.for(damageView.draw(_))
    }
}

stub val RailsTurn : string
stub val RailTurnGravel : string
stub val RailTurnTies : string
stub val SwitchStraight : string
stub val SwitchTurn : string

class TRRailView {
    val railModel = EGMeshModel([
        (TR3D.railGravel, EG.textureFor("Gravel.png")),
        (TR3D.railTies, EGColor(1, 1, 0, 1)),
        (TR3D.rails, EGColor(1, 1, 1, 1))
    ])
//    val railMesh = EGMesh([
//        0, 0, 0, -1, 0, -0.5,0, -0.5,
//        1, 0, 0, -1, 0, 0.5, 0, -0.5,
//        1, 1, 0, -1, 0, 0.5, 0, 0.5,
//        0, 1, 0, -1, 0, -0.5, 0, 0.5
//    ], [0, 1, 2,
//    2, 3, 0])
//    val railModel =  EGMeshModel([
//        (railMesh, EGColor(1, 0, 1, 1))
//    ])
    def draw(rail : TRRail) {
        val m = EG.modelMatrix
        m.push

        m.translate(rail.tile.x, rail.tile.y, 0.001)

        if(rail.form == TRRailForm.bottomTop || rail.form == TRRailForm.leftRight) {
            if(rail.form == TRRailForm.leftRight) m.rotate(90, 0, 0, 1)
            m.rotate(90, 1, 0, 0)
            railModel.draw
        } else {
            if(rail.form == TRRailForm.topRight) m.rotate(270, 0, 0, 1)
            else if(rail.form == TRRailForm.bottomRight) m.rotate(180, 0, 0, 1)
            else if(rail.form == TRRailForm.leftBottom) m.rotate(90, 0, 0, 1)
            m.rotate(90, 1, 0, 0)
            egColor3(0.5, 0.5, 0.5)
            EGMaterial.stone.set
            EG.textureFor("Gravel.png").draw(egDrawJasModel(RailTurnGravel))
            EGMaterial.wood.set
            egDrawJasModel(RailTurnTies)
            EGMaterial.steel.set
            egDrawJasModel(RailsTurn)
        }
        m.pop
    }
}

class TRSwitchView {
    def draw(theSwitch : TRSwitch) {
        val connector = theSwitch.connector
        glPushMatrix
        egTranslate(theSwitch.tile.x, theSwitch.tile.y, 0.03)
        egRotate(connector.angle, 0, 0, 1)

        val rail = theSwitch.activeRail
        val form = rail.form

        EGMaterial.emerald.set
        egTranslate(-0.5, 0, 0)
        if(form.start.x + form.end.x == 0) {
            egRotate(90, 1, 0, 0)
            egDrawJasModel(SwitchStraight)
        } else {
            val otherConnector = if(form.start == connector) form.end else form.start
            val x = connector.x
            val y = connector.y
            val ox = otherConnector.x
            val oy = otherConnector.y
            if(x == -1 && oy == -1 || y == 1 && ox == -1 || y == -1 && ox == 1 || x == 1 && oy == 1) {
                egScale(1, -1, 1)
            }
            egRotate(90, 1, 0, 0)
            egDrawJasModel(SwitchTurn)
        }

        glPopMatrix
    }
}

class TRLightView {
    def draw(light : TRLight) {
        glPushMatrix
        egTranslate(light.tile.x, light.tile.y, 0)
        egRotate(light.connector.angle, 0, 0, 1)

        egTranslate(-0.45, 0.2, 0)
        if(light.isGreen) EGMaterial.emerald.set else EGMaterial.ruby.set
        glutSolidCube(0.1)

        glPopMatrix
    }
}

class TRDamageView {
    def draw(point : TRRailPoint) {
        glPushMatrix
        egTranslate(point.point.x, point.point.y, 0.01)
        egColor4(1.0, 0.0, 0.0, 0.5)
        egNormal3(0, 0, 1)
        egRect(-0.1, -0.1, 0.1, 0.1)
        glPopMatrix
    }
}