package com.antonzherdev.trains

import com.antonzherdev.eg.Text._
import com.antonzherdev.eg.Progress._

class LevelMenuView(level : Level) extends LayerView with InputProcessor {
    val name = "LevelMenu"
    private val t = scaledTextureFor("Pause", TextureFormat.RGBA4)

    private val pauseSprite = Sprite(
        material = ColorSource(if(egPlatform.isPhone) t.region(0, 0, 32, 32) else t.region(96, 32, 32, 32)),
        position = context.scaledViewSize.map(vec3(_.x - if(egPlatform.isPhone) 32 else 36, 4, 0)))
    private val slowSprite = Sprite(
        material = ColorSource(t.region(64, 32, 32, 32)),
        position = context.scaledViewSize.map(vec3(_.x - if(egPlatform.isPhone) 36 else 40, _.y - 34, 0))
    )
    private val _hammerSprite = Sprite(
        visible = level.scale.map(_ > 1.0),
        material = level.builder.mode.map{m ->
            ColorSource(
                color = if(m == RailroadBuilderMode.build) vec4(0.45, 0.9, 0.6, 0.95) else vec4(1.0),
                texture = t.region(32, 0, 32, 32)
            )
        },
        position = context.scaledViewSize.map(vec3(0, _.y - 32, 0))
    )
    private val _clearSprite = Sprite(
        material = level.builder.mode.map{m ->
            ColorSource(
                color = if(m == RailroadBuilderMode.clear) vec4(0.45, 0.9, 0.6, 0.95) else vec4(1.0),
                texture = t.region(0, 64, 32, 32)
            )
        },
        position = vec3(0, 0, 0)
    )

    private val shadow : TextShadow? = TextShadow(color = vec4(0.05, 0.05, 0.05, 0.5), shift = vec2(1, -1))
    private val slowMotionCountText = Text(
        visible = GameDirector.instance.slowMotionsCount.map(_ > 0),
        font = mainFontWith(24).beReadyFor("\$0123456789'$(Loc.level(1))"),
        text = GameDirector.instance.slowMotionsCount.map("$_"),
        position = slowSprite.position.map(_ + vec2(1, 18)),
        alignment = TextAlignment(1, 0), color, shadow)
    private val scoreText = Text(
        visible = true,
        font = mainFontWith(24),
        text = level.score.money.map(format(_)),
        position = React(context.scaledViewSize, level.scale){viewSize, scale ->
            if(scale > 1.0) vec3(32, viewSize.y - 24, 0)
            else vec3(10, viewSize.y - 24, 0)
        },
        alignment= TextAlignment.baseline(-1), color, shadow)
    private val currentNotificationText = Var<string>("")
    private val notificationText = Text(
        visible = notificationAnimation.isRunning,
        font = mainFontWith(if(egPlatform.isPhone) (if(egPlatform.screenSizeRatio > 4.0/3.0) 14 else 12) else 18).beReadyFor(Loc.notificationsCharSet),
        text = currentNotificationText,
        position = React(scoreText.text, scoreText.position) {_, scorePos ->
            vec3(scoreText.measureC.x + scorePos.x + 5, scorePos.y + 2, 0)
        },
        alignment = TextAlignment.baseline(if(egPlatform.isPhone) -1 else 0), color, shadow)
    var levelText : Text? = Text(
        visible = true,
        font = mainFontWith(24),
        text = Loc.startLevel(level.number),
        position = context.scaledViewSize.map(vec3(_.x/2, _.y - 24, 0)),
        alignment = TextAlignment.baseline(0),
        color = levelAnimation.time.map(notificationProgress(_)), shadow)

    private val notificationProgress = gap(0.7, 1) >> vec4(0.95 - _)

    private val _camera : React<Camera2D> = context.scaledViewSize.map(Camera2D(_))
    def camera : Camera = _camera.value
    private def color : vec4 = vec4(0.95)

    def draw {
        context.depthTest.disabled { BlendFunction.premultiplied {
            scoreText.draw
            pauseSprite.draw
            _clearSprite.draw
            levelText.for( _.draw)
            notificationText.draw

            if(level.slowMotionCounter.isRunning.value) {
                BlendFunction.standard {
                    D2D.drawCircle(backColor = vec4(0.6, 0.6, 0.6, 0.95), strokeColor = vec4(0, 0, 0, 0.5),
                        at = slowSprite.position.value + slowSprite.rect.value.size/2, radius = 22, relative = vec2(0, 0),
                        segmentColor = vec4(0.95),
                        start = math.M_PI_2, end = math.M_PI_2 - 2*level.slowMotionCounter.time.value*math.M_PI)
                }
            } else {
                slowMotionCountText.draw
                slowSprite.draw
            }
        }}
    }

    def format(score : int) : string = {
        Loc.format(score)
    }

    private var notificationAnimation = Counter(2)
    private var levelAnimation = Finisher(Counter(5), (levelText = nil))

    def updateWith(delta : float) {
        if(levelAnimation.isRunning.value) levelAnimation.updateWith(delta)
        else if(notificationAnimation.isRunning.value) notificationAnimation.updateWith(
            if(level.notifications.isEmpty) delta
            else 5*delta)
        else if(!level.notifications.isEmpty) {
            currentNotificationText.value = level.notifications.take.get
            notificationAnimation.restart
        }
    }

    def recognizers : Recognizers = Recognizer(Tap()) {event ->
        val p = event.locationInViewport
        if(pauseSprite.containsViewport(p)) {
            if(Director.current.isPaused) Director.current.resume else Director.current.pause
        } else if(slowSprite.containsViewport(p) && !level.slowMotionCounter.isRunning.value) {
            GameDirector.instance.runSlowMotion(level)
        } else if(_hammerSprite.containsViewport(p)) {
            level.builder.modeBuildFlip
        } else if(_clearSprite.containsViewport(p)) {
            level.builder.modeClearFlip
        }
        false
    }
}

