package com.antonzherdev.trains


import com.antonzherdev.trains.Models._

class TrainView(level : Level) {
    def draw {
        egPushGroupMarker("Trains")
        draw(trains = level.trains)
        draw(dyingTrains = level.dyingTrains)
        egPopGroupMarker
    }

    def drawSmoke {
        egPushGroupMarker("Smoke")
        drawSmoke(trains = level.trains)
        drawSmoke(trains = level.dyingTrains)
        egPopGroupMarker
    }

    def draw(trains : [Train]) {
        if(trains.isEmpty) return nil

        trains.for {train -> draw(train = train)}
    }

    def drawSmoke(trains : [Train]) {
        trains.for {train ->
            var smoke = train.viewData.cast<SmokeView>
            if(train.viewData == nil) {
                smoke = SmokeView(Smoke(train, level.weather))
                train.viewData = smoke
            }
            smoke.draw
        }
    }

    private def draw(train : Train) {
        train.cars.for{ car ->
            matrix(
                _.modify(w = w -> {
                    val mid = car.position.line.mid
                    w.translate(mid.x, mid.y, 0.04)
                }).modify(m = m -> {
                    m.rotate(car.position.line.degreeAngle + 90, 0, 1, 0)
                })
            ){
                doDraw(car, train.color.color)
            }
        }
    }

    private def doDraw(car : Car, color : vec4) {
        val tp = car.carType
        if(tp == CarType.car) {
            carModel.draw(color)
        } else if(tp == CarType.engine){
            engineModel.draw(color)
        } else if(tp == CarType.expressEngine){
            expressEngineModel.draw(color)
        } else if(tp == CarType.expressCar){
            expressCarModel.draw(color)
        }
    }

    private val engineModel = CarModel(engine, engineBlack, engineShadow)
    private val carModel = CarModel(car, carBlack, carShadow,
        textureFor("Car.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST))
    private val expressEngineModel = CarModel(expressEngine, expressEngineBlack, expressEngineShadow)
    private val expressCarModel = CarModel(expressCar, expressCarBlack, expressCarShadow,
        textureFor("ExpressCar.png", GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST))

    def draw(dyingTrains : [Train]) {
        if(dyingTrains.isEmpty) return nil

        dyingTrains.for {train ->
            draw(dyingTrain = train)
        }
    }

    private def draw(dyingTrain : Train) {
        dyingTrain.cars.for{ car ->
            matrix(
                _.modify(m = m -> {
                    car.dynamicBody.matrix.translate(0, 0, -car.carType.height/2 + 0.04).mul(m.rotate(90, 0, 1, 0))
                })
            ){
                doDraw(car, dyingTrain.color.color)
            }
        }
    }


    def updateWith(delta : float, train : Train) {
        train.viewData.cast<SmokeView>.system.updateWith(delta)
    }
}

class CarModel(colorVao : VertexArray<StandardMaterial>, blackVao : VertexArray<StandardMaterial>,
    shadowVao : VertexArray<ColorSource>, texture : Texture?)
{
    static def trainMaterialFor(diffuse : ColorSource) = StandardMaterial(diffuse, vec4(0.1, 0.1, 0.1, 1), 0.1)

    static val blackMaterial = StandardMaterial(vec4(0, 0, 0, 1))
    static def apply(colorMesh : Mesh, blackMesh : Mesh, shadowMesh : Mesh) = CarModel(colorMesh, blackMesh, shadowMesh, nil)
    static def apply(colorMesh : Mesh, blackMesh : Mesh, shadowMesh : Mesh, texture : Texture?) = {
        val defMat = if(texture.isDefined) trainMaterialFor(texture.get) else trainMaterialFor(vec4(1, 1, 1, 1))
        CarModel(
            colorVao = colorMesh.vao(defMat, shadow = false),
            blackVao = blackMesh.vao(blackMaterial, shadow = false),
            shadowVao = shadowMesh.vaoShadow(ColorSource(vec4(1, 1, 1, 1))),
            texture = texture
            )
    }

    def draw(color : vec4) {
        if(context.renderTarget.isShadow) {
            shadowVao.draw
        } else {
            colorVao.draw(trainMaterialFor(ColorSource(color, texture, -1)))
            blackVao.draw
        }
    }
}