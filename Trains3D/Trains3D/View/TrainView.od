package com.antonzherdev.trains

import com.antonzherdev.trains.Models._

class SmokeView(system : Smoke) extends BillboardParticleSystemView(system,
    202,
    textureFor("Smoke", TextureFormat.RGBA4, TextureFilter.mipmapNearest),
    BlendFunction.premultiplied)


class TrainView(level : Level) {
    def draw {
        egPushGroupMarker("Trains")
        draw(trains = level.trainActors)
        draw(dyingTrains = level.dyingTrainActors)
        egPopGroupMarker
    }

    def drawSmoke {
        egPushGroupMarker("Smoke")
        drawSmoke(trains = level.trainActors)
        drawSmoke(trains = level.dyingTrainActors)
        egPopGroupMarker
    }

    def draw(trains : [Train]) {
        if(trains.isEmpty) return nil

        trains.for {train -> draw(train = train)}
    }

    def drawSmoke(trains : [Train]) {
        trains.for {train ->
            train.smoke.viewData(SmokeView(_)).forSuccess(await = 0.1){smokeView ->
                smokeView.draw
            }
        }
    }

    private def draw(train : Train) {
        train.state.forSuccess(await = 0.1){state ->
            state.cast<LiveTrainState>.carStates.for{ car ->
                matrix(
                    _.modify(w = w -> {
                        val mid = car.midPoint
                        w.translate(mid.x, mid.y, 0.04)
                    }).modify(m = m -> {
                        m.rotate(car.line.degreeAngle + 90, 0, 1, 0)
                    })
                ){
                    doDraw(state, car.carType)
                }
            }
        }
    }

    private static val crazyColors : [float4 -> vec4] =
        CityColor.values.chain
        .exclude([CityColor.grey])
        .map{cityColor ->
            cityColor.color
        }.neighborsRing
        .map{colors ->
            Progress.progress(colors.a, colors.b)
        }.toArray

    static def crazyColor(time : float) : vec4 = {
        val f = (time / 2).fraction * crazyColors.count - 0.0001
        val cc = crazyColors[f.cast<int>]
        cc(f.fraction)
    }

    private def doDraw(trainState : TrainState, carType : CarType) {
        val color : vec4 =
            if(trainState.train.trainType == TrainType.crazy) crazyColor(trainState.time)
            else trainState.train.color.trainColor
        if(carType == CarType.car) {
            carModel.draw(color)
        } else if(carType == CarType.engine){
            engineModel.draw(color)
        } else if(carType == CarType.expressEngine){
            expressEngineModel.draw(color)
        } else if(carType == CarType.expressCar){
            expressCarModel.draw(color)
        }
    }

    private val engineModel = CarModel(engine, engineBlack, engineShadow,
        compressedTextureFor("Engine"), normalMap = compressedTextureFor("engine_normals"))
    private val carModel = CarModel(car, carBlack, carShadow,
        compressedTextureFor("Car"), normalMap = nil)
    private val expressEngineModel = CarModel(expressEngine, expressEngineBlack, expressEngineShadow,
        compressedTextureFor("ExpressEngine"), normalMap = nil)
    private val expressCarModel = CarModel(expressCar, expressCarBlack, expressCarShadow,
        compressedTextureFor("ExpressCar"), normalMap = nil)

    def draw(dyingTrains : [Train]) {
        if(dyingTrains.isEmpty) return nil

        dyingTrains.for {train ->
            draw(dyingTrain = train)
        }
    }

    private def draw(dyingTrain : Train) {
        dyingTrain.state.forSuccess(await = 0.1){state ->
            state.carStates.for{ car ->
                val tp = car.carType
                matrix(
                    _.modify(m = m -> {
                        car.matrix.translate(0, 0, -tp.height/2 + 0.04).mul(m.rotate(90, 0, 1, 0))
                    })
                ){
                    doDraw(state, tp)
                }
            }
        }
    }
}

class CarModel(colorVao : VertexArray<StandardMaterial>, blackVao : VertexArray<StandardMaterial>,
    shadowVao : VertexArray<ColorSource>, texture : Texture?, normalMap : Texture?)
{
    static def trainMaterialFor(diffuse : ColorSource, normalMap : Texture?) = StandardMaterial(diffuse,
        specularColor = vec4(0.1, 0.1, 0.1, 1), specularSize = 0.1,
        normalMap = if(normalMap.isDefined) NormalMap(texture = normalMap.get, tangent = false) else nil)

    static val blackMaterial = ColorSource(vec4(0, 0, 0, 1))
    static def apply(colorMesh : Mesh, blackMesh : Mesh, shadowMesh : Mesh, texture : Texture?, normalMap : Texture?) : CarModel = {
        val defMat =
            if(texture.isDefined) trainMaterialFor(ColorSource(vec4(1, 0, 0, 1), texture.get, BlendMode.multiply, -1), normalMap)
            else trainMaterialFor(vec4(1, 1, 1, 1), normalMap)
        CarModel(
            colorVao = colorMesh.vao(defMat, shadow = false),
            blackVao = blackMesh.vao(blackMaterial, shadow = false),
            shadowVao = shadowMesh.vaoShadow(ColorSource(vec4(1, 1, 1, 1))),
            texture, normalMap
            )
    }

    def draw(color : vec4) {
        if(context.renderTarget.isShadow) {
            shadowVao.draw
        } else {
            colorVao.draw(trainMaterialFor(ColorSource(color, texture, BlendMode.multiply, -1), normalMap))
            blackVao.draw
        }
    }
}