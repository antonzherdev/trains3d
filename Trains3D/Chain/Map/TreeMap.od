package core.chain

class MutableTreeMap<K, V>(comparator : (K, K) -> int) extends MutableMap<K, V> {
    static def apply<K extends Comparable<K>, V> = MutableTreeMap<K, V>((a : K, b : K) -> a.compare(b))

    private var root : TreeMapEntry<K, V> = nil
    private var _size : uint = 0

    def count = _size
    def isEmpty : bool = root == nil
    def apply(key : K) : V = entryFor(key).value
    def opt(key : K) : V? = {
        val e = entryFor(key)
        if(e == nil) nil else e.value
    }
    def clear {
        _size = 0
        root = nil
    }

    val keys : TreeMapKeySet<K> = TreeMapKeySet<K>(self)
    val values : TreeMapValues<V> = TreeMapValues<V>(self)
    def iterator : Iterator<(K, V)> = TreeMapIterator<K, V>.new(self, firstEntry)
    def iteratorHigherThan(key : K) = TreeMapIterator<K, V>.new(self, higherEntryThan(key).getOr(nil))

    private def entryFor(key : K) : TreeMapEntry<K, V> = {
        val p = root
        while (p != nil) {
            val cmp = comparator(key, p.key)
            if (cmp < 0) p = p.left
            else if (cmp > 0) p = p.right
            else break
        }
        p
    }

    static val BLACK = 0
    static val RED = 1

    def set(value : V, forKey : K)  {
        val t = root
        if (t == nil) {
            root = TreeMapEntry.newWith<K,V>(forKey, value, parent = nil)
            _size = 1
        } else {
            val cmp : int = 0
            val parent : TreeMapEntry<K, V> = nil

            do {
                parent = t
                cmp = comparator(forKey, t.key)
                if (cmp < 0) t = t.left
                else if (cmp > 0) t = t.right
                else {
                    t.value = value
                    return nil
                }
            } while (t != nil)

            val e =  TreeMapEntry.newWith<K,V>(forKey, value, parent)
            if (cmp < 0) parent.left = e
            else parent.right = e
            fixAfterInsertion(e)
            _size++
        }
    }

    def removeFor(key : K) : V? = {
        val entry = entryFor(key)
        if(entry != nil) delete(entry)
        else nil
    }

    private def delete(entry : TreeMapEntry<K, V>) : V = {
        val p = entry
        _size--

        // If strictly internal, copy successor's element to p and then make p
        // point to successor.
        if (p.left != nil && p.right != nil) {
            val s = p.next
            p.key = s.key
            p.value = s.value
            p = s
        } // p has 2 children

        // Start fixup at replacement node, if it exists.
        val replacement = if(p.left != nil) p.left else p.right
        if (replacement != nil) {
            // Link replacement to parent
            replacement.parent = p.parent
            if (p.parent == nil) root = replacement
            else if (p == p.parent.left) p.parent.left  = replacement
            else p.parent.right = replacement

            // Null out links so they are OK to use by fixAfterDeletion.
            p.left = nil
            p.right = nil
            p.parent = nil

            // Fix replacement
            if (p.color == BLACK) fixAfterDeletion(replacement)
        } else if (p.parent == nil) { // return if we are the only node.
            root = nil
        } else { //  No children. Use self as phantom replacement and unlink.
            if (p.color == BLACK) fixAfterDeletion(p)
            if (p.parent != nil) {
                if (p == p.parent.left) p.parent.left = nil
                else if (p == p.parent.right) p.parent.right = nil
                p.parent = nil
            }
        }
        entry.value
    }

    private def fixAfterInsertion(entry : TreeMapEntry<K, V>) {
        var x = entry
        x.color = RED
        while (x != nil && x != root && x.parent.color == RED) {
            if (x.parent == x.parent.parent.left) {
                val y = x.parent.parent.right
                if (y.color == RED) {
                    x.parent.color = BLACK
                    y.color = BLACK
                    x.parent.parent.color = RED
                    x = x.parent.parent
                } else {
                    if (x == x.parent.right) {
                        x = x.parent
                        rotateLeft(x)
                    }
                    x.parent.color = BLACK
                    x.parent.parent.color = RED
                    rotateRight(x.parent.parent)
                }
            } else {
                val y = x.parent.parent.left
                if (y.color == RED) {
                    x.parent.color = BLACK
                    y.color = BLACK
                    x.parent.parent.color = RED
                    x = x.parent.parent
                } else {
                    if (x == x.parent.left) {
                        x = x.parent
                        rotateRight(x)
                    }
                    x.parent.color = BLACK
                    x.parent.parent.color = RED
                    rotateLeft(x.parent.parent)
                }
            }
        }
        root.color = BLACK
    }

    private def fixAfterDeletion(entry : TreeMapEntry<K, V>) {
        var x = entry
        while (x != root && x.color == BLACK) {
            if (x == x.parent.left) {
                val sib = x.parent.right
                if (sib.color == RED) {
                    sib.color = BLACK
                    x.parent.color = RED
                    rotateLeft(x.parent)
                    sib = x.parent.right
                }
                if (sib.left.color == BLACK && sib.right.color == BLACK) {
                    sib.color = RED
                    x = x.parent
                } else {
                    if (sib.right.color == BLACK) {
                        sib.left.color = BLACK
                        sib.color = RED
                        rotateRight(sib)
                        sib = x.parent.right
                    }
                    sib.color = x.parent.color
                    x.parent.color = BLACK
                    sib.right.color = BLACK
                    rotateLeft(x.parent)
                    x = root
                }
            } else { // symmetric
                var sib = x.parent.left

                if (sib.color == RED) {
                    sib.color = BLACK
                    x.parent.color = RED
                    rotateRight(x.parent)
                    sib = x.parent.left
                }

                if (sib.right.color == BLACK && sib.left.color == BLACK) {
                    sib.color = RED
                    x = x.parent
                } else {
                    if (sib.left.color == BLACK) {
                        sib.right.color = BLACK
                        sib.color = RED
                        rotateLeft(sib)
                        sib = x.parent.left
                    }
                    sib.color = x.parent.color
                    x.parent.color = BLACK
                    sib.left.color = BLACK
                    rotateRight(x.parent)
                    x = root
                }
            }
        }
        x.color = BLACK
    }


    private def rotateLeft(p : TreeMapEntry<K, V>) {
        if (p != nil) {
            val r = p.right
            p.right = r.left
            if (r.left != nil) r.left.parent = p
            r.parent = p.parent
            if (p.parent == nil) root = r
            else if (p.parent.left == p) p.parent.left = r
            else p.parent.right = r
            r.left = p
            p.parent = r
        }
    }

    private def rotateRight(p : TreeMapEntry<K, V>) {
        if (p != nil) {
            val l = p.left
            p.left = l.right
            if (l.right != nil) l.right.parent = p
            l.parent = p.parent
            if (p.parent == nil) root = l
            else if (p.parent.right == p) p.parent.right = l
            else p.parent.left = l
            l.right = p
            p.parent = l
        }
    }

    private def firstEntry : TreeMapEntry<K, V> = {
        val p = root
        if (p != nil) while (p.left != nil) p = p.left
        p
    }

    private def lastEntry : TreeMapEntry<K, V> = {
        val p = root
        if (p != nil) while (p.right != nil) p = p.right
        p
    }

    def pollFirst : (K, V)? = {
        val entry = firstEntry
        if(entry == nil) nil
        else {
            delete(entry)
            (entry.key, entry.value)
        }
    }

    def firstKey : K? = if(root == nil) nil else firstEntry.key
    def lastKey : K? = if(root == nil) nil else lastEntry.key

    def lowerKeyThan(key : K) : K? = lowerEntryThan(key).map(_.key)
    def higherKeyThan(key : K) : K? = higherEntryThan(key).map(_.key)

    private def lowerEntryThan(key : K) : TreeMapEntry<K, V>? = {
        val p = root
        while (p != nil) {
            val cmp = comparator(key, p.key)
            if (cmp > 0) {
                if (p.right != nil) p = p.right
                else return Some(p)
            } else {
                if (p.left != nil) {
                    p = p.left
                } else {
                    val parent = p.parent
                    val ch = p
                    while (parent != nil && ch == parent.left) {
                        ch = parent
                        parent = parent.parent
                    }
                    return Some(parent)
                }
            }
        }
        nil
    }

    private def higherEntryThan(key : K) : TreeMapEntry<K, V>? = {
        val p = root
        while (p != nil) {
            val cmp = comparator(key, p.key)
            if (cmp < 0) {
                if (p.left != nil) p = p.left
                else return Some(p)
            } else {
                if (p.right != nil) {
                    p = p.right
                } else {
                    val parent = p.parent
                    val ch = p
                    while (parent != nil && ch == parent.right) {
                        ch = parent
                        parent = parent.parent
                    }
                    return Some(parent)
                }
            }
        }
        nil
    }
}

class TreeMapEntry<K, V> {
    var key : K
    var value : V
    var left : TreeMapEntry<K, V> = nil
    var right : TreeMapEntry<K, V> = nil
    var color : int
    weak var parent : TreeMapEntry<K, V>

    static def newWith<K, V>(key : K, value : V, parent : TreeMapEntry<K, V>) : TreeMapEntry<K, V> = {
        val r = TreeMapEntry<K, V>()
        r.key = key
        r.value = value
        r.parent = parent
        r
    }

    def next : TreeMapEntry<K, V> = {
        if (right != nil) {
            var p = right
            while (p.left != nil) p = p.left
            p
        } else {
            var p = parent
            var ch = self
            while (p != nil && ch == p.right) {
                ch = p
                p = p.parent
            }
            p
        }
    }
}

class TreeMapKeySet<K>(map : MutableTreeMap<K, _>) extends Iterable<K> {
    def count : uint = map.count

    def iterator : Iterator<K> = TreeMapKeyIterator<K>.new(map, map.firstEntry)
    def iteratorHigherThan(key : K) : Iterator<K> = TreeMapKeyIterator<K>.new(map, map.higherEntryThan(key).getOr(nil))
}

class TreeMapKeyIterator<K>(map : MutableTreeMap<K, _>) extends Iterator<K> {
   static def new<K>(map : MutableTreeMap<K, _>, entry : TreeMapEntry<K, _>) : TreeMapKeyIterator<K> = {
       val ret = TreeMapKeyIterator<K>(map)
       ret.entry = entry
       ret
   }
   var entry : TreeMapEntry<K, _>
   def hasNext : bool = entry != nil
   def next : K = {
        val ret = entry.key
        entry = entry.next
        ret
   }
}

class TreeMapValues<V>(map : MutableTreeMap<_, V>) extends Iterable<V> {
    def count : uint = map.count

    def iterator : Iterator<V> = TreeMapValuesIterator<V>.new(map, map.firstEntry)
}

class TreeMapValuesIterator<V>(map : MutableTreeMap<_, V>) extends Iterator<V> {
    static def new<V>(map : MutableTreeMap<_, V>, entry : TreeMapEntry<_, V>) : TreeMapValuesIterator<V> = {
        val ret = TreeMapValuesIterator<V>(map)
        ret.entry = entry
        ret
    }
    var entry : TreeMapEntry<_, V>
    def hasNext : bool = entry != nil
    def next : V = {
        val ret = entry.value
        entry = entry.next
        ret
    }
}

class TreeMapIterator<K, V>(map : MutableTreeMap<K, V>) extends Iterator<(K, V)> {
    static def new<K, V>(map : MutableTreeMap<K, V>, entry : TreeMapEntry<K, V>) : TreeMapIterator<K, V> = {
        val ret = TreeMapIterator<K, V>(map)
        ret.entry = entry
        ret
    }
    def hasNext : bool = entry != nil
    var entry : TreeMapEntry<K, V>

    def next : V = {
        val ret = (entry.key, entry.value)
        entry = entry.next
        ret
    }
}