package core.chain

import CNCollection
import CNChain
import CNTuple
import "CNOption.h"

trait CNMap<K, V> extends CNIterable<(K, V)> {
    def apply(key : K) : V?
    def keys : CNIterable<K>
    def values : CNIterable<V>
    def contains(key : K) : bool = apply(key).isDefined
}

trait CNMutableMap<K, V> extends CNMap<K, V> with CNMutableIterable<(K, V)> {
    def set(object : V, forKey : K)
    def removeFor(key : K) : V?
    def objectFor(key: K, orUpdateWith: () -> V) : V = {
        val o = apply(key)
        if(o.isDefined) o.get
        else {
            val init : V = orUpdateWith
            set(init, forKey = key)
            init
        }
    }
    def modify(by : V? -> V?, forKey : K) : V? = {
        val newObject = by(apply(forKey))
        if(newObject.isEmpty) removeFor(forKey)
        else set(newObject, forKey)
        newObject
    }

    def add(object : (K, V)) {
        set(object.a, object.b)
    }
    def remove(object : (K, V)) {
        removeFor(object.a)
    }
}

class CNMapDefault<K, V>(defaultFunc : K -> V, map : CNMutableMap<K, V>) extends CNMutableIterable<(K, V)> {
    def count : uint = map.count
    def iterator : CNIterator<(K, V)> = map.iterator
    def apply(key : K) : V = map.objectFor(key, orUpdateWith = defaultFunc(key))
    def keys : CNIterable<K> = map.keys
    def values : CNIterable<V> = map.values
    def contains(key : K) : bool = map.contains(key)
    def set(object : V, forKey : K) {
        map.set(object, forKey)
    }
    def modify(by : V -> V, forKey : K) : V {
        val object = by(apply(forKey))
        map.set(object, forKey)
        object
    }
    def add(object : (K, V)) {
        map.add(object)
    }
    def remove(object : (K, V)) {
        map.remove(object)
    }
}

stub class NSDictionary <K, V> extends CNMap<K, V>

stub class NSMutableDictionary<K, V> extends CNMutableMap<K, V>

type CNHashMap<K, V> = NSDictionary<K, V>
type CNMutableHashMap<K, V> = NSMutableDictionary<K, V>