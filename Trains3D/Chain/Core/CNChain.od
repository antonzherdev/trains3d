package core.chain

import CNCollection
import CNSet
import CNSortBuilder

stub class CNChain<A> extends CNIterable<A> {
    static def chainWith<T>(collection:CNTraversable<T>) : CNChain<T>

    def filter(: A -> bool) : CNChain<A>
    def map<B>(: A -> B) : CNChain<B>
    def flatMap<B>(: A -> CNTraversable<B>) : CNChain<B>

    def combinations : CNChain<(A, A)>
    def uncombinations<B>(self : CNChain<(B, B)>) : CNChain<B>
    def neighbors : CNChain<(A, A)>
    def neighborsRing : CNChain<(A, A)>
    def mul<B>(: CNTraversable<B>) : CNChain<(A,B)>

    def group<K>(by : A -> K) : CNChain<(K, [A])>
    def group<K, B>(by : A -> K, map : A -> B) : CNChain<(K, [B])>
    def group<K, C extends CNTraversable<K>>(by : A -> K, withBuilder : () -> CNBuilder<A, C>) : CNChain<(K, C<A>)>
    def group<B, K, C extends CNTraversable<K>>(by : A -> K, map : A -> B, withBuilder : () -> CNBuilder<B, C>) : CNChain<(K, C<B>)>
    def group<K, V>(by : A -> K, fold : (V, A) -> V, withStart : () -> V) : CNChain<(K, V)>

    def join<K, V1, V2>(self : CNChain<(K, V1)>, chain : CNIterable<(K, V2)>) : CNChain<K, (V1, V2)>

    def prepend(: CNIterable<A>) : CNChain<A>
    def append(: CNIterable<A>) : CNChain<A>
    def exclude(: CNIterable<A>) : CNChain<A>
    def intersect(: CNIterable<A>) : CNChain<A>

    def reverse : CNChain<A>
    def distinct : CNChain<A>
    def sort<B extends ODComparable<B>> (self : CNChain<B>) : CNChain<A>
    def sortDesc<B extends ODComparable<B>> (self : CNChain<B>) : CNChain<A>
    def sort(:(A, A) -> int) : CNChain<A>
    def sortBy : CNSortBuilder<A>

    def fold<B>( : (B, A) -> B, withStart : B) : B
    def count : uint
    def for(each: A -> void)
    def head : A?
    def randomItem : A?
    def find(: A -> bool) : A?
    def isEmpty : bool
    def gap<B extends ODComparable<B>> (self : CNChain<B>) : (A, A)?
    def min<B extends ODComparable<B>> (self : CNChain<B>) : A?
    def max<B extends ODComparable<B>> (self : CNChain<B>) : A?
    def toStringWith(start : string, delimiter : string, end : string) : string
    def toStringWith(delimiter : string) : string

    def toArray : [A]
    def toSet : CNSet<A>
    def toMap<K, V>(self : CNChain<(K, V)>) : [K : V]
}

stub def randomWith(max : uint) : uint