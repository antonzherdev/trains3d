package core.chain

import ODType

import CNSeq
import CNCollection
export CNTypes
import CNOption
import CNChain


class CNPArray<T>(stride : uint, wrap : (VoidRef, uint) -> T, count : uint, length : uint, bytes : VoidRef, copied : bool) extends CNSeq<T> {
    static def apply<T>(stride : uint, wrap : (VoidRef, uint) -> T, count : uint, copyBytes : VoidRef) : CNPArray<T> = {
        val len =  count * stride
        CNPArray<T>(stride, wrap, count, len, copy(copyBytes, count * stride), true)
    }


    def iterator : CNIterator<T> = CNPArrayIterator<T>(self)

    def apply(index : uint) : T? =
        if(index >= count) nil
        else wrap(bytes, index)

    def dealloc {
        if(copied) free(bytes)
    }
}

class CNPArrayIterator<T>(array : CNPArray<T>) extends CNIterator<T> {
    private var i = 0
    def hasNext : bool = i < array.count
    def next : T = {
        val ret = array.apply(i)
        i++
        ret
    }
}
