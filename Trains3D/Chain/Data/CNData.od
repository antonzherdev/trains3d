package core.chain

import ODType

import CNSeq
import CNCollection
import CNTypes
import CNOption
import CNChain


class CNPArray<T>(stride : uint, wrap : (VoidRef, uint) -> T, count : uint, length : uint, bytes : VoidRef, copied : bool) extends CNSeq<T> {
    static def apply<T>(stride : uint, wrap : (VoidRef, uint) -> T, count : uint, copyBytes : VoidRef) : CNPArray<T> = {
        val len =  count * stride
        CNPArray<T>(stride, wrap, count, len, copy(copyBytes, count * stride), true)
    }


    def iterator : CNIterator<T> = CNPArrayIterator<T>(self)

    def apply(index : uint) : T? =
        if(index >= count) nil
        else wrap(bytes, index)

    def dealloc {
        if(copied) free(bytes)
    }
}

class CNPArrayIterator<T>(array : CNPArray<T>) extends CNIterator<T> {
    private var i = 0
    def hasNext : bool = i < array.count
    def next : T = {
        val ret = array.apply(i)
        i++
        ret
    }
}

class CNMutablePArray<T>(stride : uint, wrap : (VoidRef, uint) -> T, count : uint, length : uint, bytes : VoidRef)
    extends CNPArray<T>(stride, wrap, count, length, bytes, true)
{
    private var pointer = bytes
    static def apply<T>(tp: ODPType<T>, count : uint) : CNMutablePArray<T> = {
        val length = tp.size * count
        CNMutablePArray<T>(tp.size, tp.wrap, count, length, malloc(length))
    }

    def write(item : VoidRef) {
        memcpy(pointer, item, stride)
        pointer += stride
    }

    def write(uInt4 : uint4) {
        setui4(pointer, uInt4)
        pointer += stride
    }

    def write(item : VoidRef, times : uint) {
        while(times > 0) {
            memcpy(pointer, item, stride)
            pointer += stride
            times--
        }
    }

    def write(array : CNPArray<T>) {
        memcpy(pointer, array.bytes, array.length)
        pointer += array.length
    }
}