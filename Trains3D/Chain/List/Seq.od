package core.chain

import core.ODMath._

trait Seq<T> extends Iterable<T> {
    def apply(index : uint) : T? = {
        val i = iterator
        var n = index
        while(i.hasNext) {
            if(n == 0) return i.next
            i.next
            n--
        }
        nil
    }

    def randomItem : T? =
        if(isEmpty) nil
        else apply(randomMax(count - 1))

    def toSet : Set<T> = convertWith(HashSetBuilder<T>())
    def arrayByAdding(item : T) : Seq<T> = {
        val builder = ArrayBuilder<T>()
        builder.addAll(self)
        builder.add(item)
        builder.build
    }

    def arrayByRemoving(item : T) : Seq<T> = {
        chain.filter(_ != item).toArray
    }

    def isEqualTo(seq : Seq<T>) : bool = {
        if(self.count != seq.count) return false
        val ia = self.iterator
        val ib = seq.iterator
        while(ia.hasNext && ib.hasNext) {
            if(ia.next != ib.next) return false
        }
        true
    }
}

trait MutableSeq<T> extends Seq<T> with MutableIterable<T>

class ArrayBuilder<T> extends Builder<T, Array<T>> {
    val array = MutableArray<T>()

    def add(item : T) {
        array.add(item)
        self
    }

    def build : NSArray<T> = array
}

class IndexFunSeq<T>(count : uint, f : uint -> T) extends Seq<T> {
    def apply(index : uint) : T? =
        if(index >= count) nil
        else f(index)

    def iterator : Iterator<T> = IndexFunSeqIterator<T>(count, f)
}

class IndexFunSeqIterator<T>(count : uint, f : uint -> T) {
    var i : uint = 0
    def hasNext = i < count

    def next : T = {
        val ret = f(i)
        i++
        ret
    }
}