package core.chain

class List<T> extends Seq<T> {
    static def apply<T> : List<T> = EmptyList.instance
    static def apply<T>(item : T) : List<T> = FilledList<T>(item, EmptyList.instance)
    static def apply<T>(item : T, tail : List<T>) : List<T>  = FilledList<T>(item, tail)

    def iterator : Iterator<T> = {
        val i = ListIterator<T>()
        i.list = self
        i
    }
    def tail : List<T>
    def filter(f : T -> bool) : List<T>
    def reverse : List<T>
}

class FilledList<T>(item : T, tail : List<T>) extends List<T> {
    def head : T? = item
    val count : uint = tail.count + 1
    def isEmpty = false
    def filter(f : T -> bool) : List<T> =
        if(f(item)) FilledList<T>(item, tail.filter(f))
        else tail.filter(f)

    def reverse : List<T> = {
        var ret = FilledList<T>(item, EmptyList.instance)
        var list = tail
        while(!list.isEmpty) {
            ret = FilledList<T>(list.cast<FilledList<T>>.item, ret)
            list = list.tail
        }
        ret
    }
}

class EmptyList<T> extends List<T> {
    def count : uint = 0
    def head : T? = nil
    def tail : List<T> = self
    def isEmpty = true

    static val instance = EmptyList<int>()
    def filter(f : T -> bool) : List<T> = self
    def reverse : List<T> = self
}

class ListIterator<T> extends Iterator<T> {
    var list : List<T>
    def hasNext = !list.isEmpty

    def next : T = {
        val ret = list.head.get
        list = list.tail
        ret
    }
}