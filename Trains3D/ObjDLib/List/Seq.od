package core.chain

import core.math._

trait Seq<T> extends Iterable<T> {
    def apply(index : uint) : T = {
        val i = iterator
        var n = index
        while(i.hasNext) {
            if(n == 0) return i.next
            i.next
            n--
        }
        throw "Incorrect index"
    }

    def opt(index : uint) : T? =
        if(index >= count) nil
        else apply(index)

    def randomItem : T? = {
        val c = count
        if(c == 0) nil
        else if(c == 1) head
        else apply(UInt.rnd(count - 1))
    }

    def toSet : Set<T> = convertWith<Set<T>>(HashSetBuilder<T>())


    def isEqual(seq : Seq<T>) : bool = {
        if(self.count != seq.count) return false
        val ia = self.iterator
        val ib = seq.iterator
        while(ia.hasNext && ib.hasNext) {
            if(ia.next != ib.next) return false
        }
        true
    }

    def isEmpty : bool = count == 0

    def head : T = apply(0)
    def headOpt : T? = opt(0)
    def tail : ImSeq<T> = {
        val builder = ArrayBuilder<T>()
        val i = iterator
        if(i.hasNext) {
            i.next
            while(i.hasNext) {
                builder.append(i.next)
            }
        }
        builder.build
    }
    def last : T = apply(count - 1)
}

trait ImSeq<T> extends Seq<T> with ImIterable<T> {
    def add(item : T) : ImSeq<T> = {
        val builder = ArrayBuilder<T>()
        builder.appendAll(self)
        builder.append(item)
        builder.build
    }

    def add(seq : Seq<T>) : ImSeq<T> = {
        val builder = ArrayBuilder<T>()
        builder.appendAll(self)
        builder.appendAll(seq)
        builder.build
    }

    def sub(item : T) : ImSeq<T> = {
        chain.filter(_ != item).toArray
    }

    def mCopy : MSeq<T> = {
        val arr = MArray<T>()
        for{item -> arr.append(item)}
        arr
    }
}

trait MSeq<T> extends Seq<T> with MIterable<T> {
    def remove(index : uint) : bool = {
        val i = mutableIterator
        var j = index
        var ret = false
        while(i.hasNext) {
            i.next
            if(j == 0) {
                i.remove
                ret = true
                break
            }
            j--
        }
        ret
    }

    def insert(index : uint, item : T)

    def set(index : uint, item : T) {
        val i = mutableIterator
        var n = index
        while(i.hasNext) {
            if(n == 0) {
                i.next
                i.set(value = item)
                return nil
            }
            i.next
            n--
        }
        throw "Incorrect index"
    }

    def im : ImSeq<T> = imCopy
    def imCopy : ImSeq<T> = {
        val arr = MArray<T>()
        for{item -> arr.append(item)}
        arr.im
    }
}

class ArrayBuilder<T> extends Builder<T, ImArray<T>> {
    private val array = MArray<T>()

    def append(item : T) {
        array.append(item)
    }

    def build : ImArray<T> = array.im
}

case class IndexFunSeq<T>(count : uint, f : uint -> T) extends ImSeq<T> {
    def apply(index : uint) : T =
        if(index >= count) throw "Incorrect index"
        else f(index)

    def iterator : Iterator<T> = IndexFunSeqIterator<T>(count, f)
}

class IndexFunSeqIterator<T>(count : uint, f : uint -> T) extends Iterator<T> {
    var i : uint = 0
    def hasNext = i < count

    def next : T = {
        val ret = f(i)
        i++
        ret
    }
}