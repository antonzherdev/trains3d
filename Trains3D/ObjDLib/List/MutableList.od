package core.chain

class MList<T> extends MSeq<T> {
    private var _count : uint
    private var headItem : MListItem<T>?
    private var lastItem : MListItem<T>?
    override def count = _count

    override def iterator : Iterator<T> = {
        val i = MListImmutableIterator<T>()
        i.item = headItem
        i
    }
    override def mutableIterator : MIterator<T> = {
        val i = MListIterator<T>(self)
        i.item = headItem
        i
    }
    override def insert(index : uint, item : T) {
        if(index == 0) prepend(item)
        else if(index >= _count) append(item)
        else {
            var c = headItem
            var i = index
            while(c != nil && i > 0) {
                c = c.get.next
            }
            if(c != nil) {
                val li = MListItem<T>()
                li.data = item
                c.get.next?.prev = li
                c.get.next = li
            } else {
                append(item)
            }
        }
    }
    override def prepend(item : T) {
        val i = MListItem<T>()
        i.data = item
        if(headItem == nil) {
            headItem = i
            lastItem = i
            _count = 1
        } else {
            i.next = headItem
            headItem.get.prev = i
            headItem = i
            _count++
        }
    }

    override def append(item : T) {
        val i = MListItem<T>()
        i.data = item
        if(headItem == nil) {
            headItem = i
            lastItem = i
            _count = 1
        } else {
            i.prev = lastItem
            lastItem.get.next = i
            lastItem = i
            _count++
        }
    }

    def remove(listItem : MListItem<T>) {
        if(listItem == headItem) {
            headItem = headItem.get.next
            if(headItem == nil) lastItem = nil
            else headItem.get.prev = nil
        } else if(listItem == lastItem) {
            lastItem = lastItem.get.prev
            lastItem.get.next = nil
        } else {
            listItem.prev?.next = listItem.next
            listItem.next?.prev = listItem.prev
        }
        _count--
    }

    override def clear {
        headItem = nil
        lastItem = nil
    }

    def removeHead {
        headItem ?> (remove(listItem = _))
    }

    def removeLast {
        lastItem ?> (remove(listItem = _))
    }

    def takeHead : T? = headItem ?> { h ->
        val r = h.data
        remove(listItem = h)
        r
    }

    def takeLast : T? = lastItem ?> { h ->
        val r = h.data
        remove(listItem = h)
        r
    }

    override def for(each : T -> void) {
        var i = headItem
        while(i != nil) {
            each(i.get.data)
            i = i.get.next
        }
    }
    override def go(on : T -> bool) : bool = {
        var i = headItem
        while(i != nil) {
            if(!on(i.get.data)) return false
            i = i.get.next
        }
        true
    }

    override def mutableFilter(by : T -> bool) {
        var i = headItem
        while(i != nil) {
            if(!by(i.get.data)) remove(i.get)
            i = i.get.next
        }
    }

    override def headOpt : T? = headItem?.data

    override def head : T =
        if(headItem == nil) throw "List is empty"
        else headItem.get.data
}

class MListItem<T> {
    var data : T

    var next : MListItem<T>?
    weak var prev : MListItem<T>?
}

class MListIterator<T>(list : MList<T>) extends MIterator<T> {
    private var prev : MListItem<T>?
    var item : MListItem<T>?

    override def hasNext : bool = item != nil
    override def next : T = {
        prev = item
        item = item.get.next
        prev.get.data
    }
    override def remove {
        list.remove(prev.get)
    }

    override def set(value : T) {
        prev.get.data = value
    }
}

class MListImmutableIterator<T> extends Iterator<T> {
    weak var item : MListItem<T>?

    override def hasNext : bool = item != nil
    override def next : T = {
        val r = item
        item = item.get.next
        r.get.data
    }
}
