package core.chain

class MList<T> extends MSeq<T> {
    private var _count : uint
    private var headItem : MListItem<T>
    private var lastItem : MListItem<T>
    def count = _count

    def iterator : Iterator<T> = {
        val i = MListImmutableIterator<T>()
        i.item = headItem
        i
    }
    def mutableIterator : MIterator<T> = {
        val i = MListIterator<T>(self)
        i.item = headItem
        i
    }
    def insert(index : uint, item : T) {
        if(index <= 0) prepend(item)
        else if(index >= _count) append(item)
        else {
            var c = headItem
            var i = index
            while(c != nil && i > 0) {
                c = c.next
            }
            val li = MListItem<T>()
            li.data = item
            c.next.prev = li
            c.next = li
        }
    }
    def prepend(item : T) {
        val i = MListItem<T>()
        i.data = item
        if(headItem == nil) {
            headItem = i
            lastItem = i
            _count = 1
        } else {
            i.next = headItem
            headItem.prev = i
            headItem = i
            _count++
        }
    }

    def append(item : T) {
        val i = MListItem<T>()
        i.data = item
        if(headItem == nil) {
            headItem = i
            lastItem = i
            _count = 1
        } else {
            i.prev = lastItem
            lastItem.next = i
            lastItem = i
            _count++
        }
    }

    def remove(listItem : MListItem<T>) {
        if(listItem == headItem) {
            headItem = headItem.next
            if(headItem == nil) lastItem = nil
            else headItem.prev = nil
        } else if(listItem == lastItem) {
            lastItem = lastItem.prev
            lastItem.next = nil
        } else {
            listItem.prev.next = listItem.next
            listItem.next.prev = listItem.prev
        }
        _count--
    }

    def clear {
        headItem = nil
        lastItem = nil
    }

    def removeHead {
        remove(listItem = headItem)
    }

    pure def for(each : T -> void) {
        var i = headItem
        while(i != nil) {
            each(i.data)
            i = i.next
        }
    }
    pure def go(on : T -> bool) : bool = {
        var i = headItem
        while(i != nil) {
            if(!on(i.data)) return false
            i = i.next
        }
        true
    }

    def mutableFilter(by : T -> bool) {
        var i = headItem
        while(i != nil) {
            if(!by(i.data)) remove(i)
            i = i.next
        }
    }

    def headOpt : T? =
        if(headItem == nil) nil
        else headItem.data

    def head : T =
        if(headItem == nil) throw "List is empty"
        else headItem.data
}

class MListItem<T> {
    var data : T

    var next : MListItem<T>
    weak var prev : MListItem<T>
}

class MListIterator<T>(list : MList<T>) extends MIterator<T> {
    private var prev : MListItem<T>
    var item : MListItem<T>

    def hasNext : bool = item != nil
    def next : T = {
        prev = item
        item = item.next
        prev.data
    }
    def remove {
        list.remove(prev)
    }

    def set(value : T) {
        prev.data = value
    }
}

class MListImmutableIterator<T> extends Iterator<T> {
    weak var item : MListItem<T>

    def hasNext : bool = item != nil
    def next : T = {
        val r = item
        item = item.next
        r.data
    }
}
