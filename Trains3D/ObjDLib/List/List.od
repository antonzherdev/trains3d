package core.chain

abstract class ImList<T> extends ImSeq<T> {
    static def apply<T> : ImList<T> = EmptyList.instance.cast<ImList<T>>
    static def apply<T>(item : T) : ImList<T> = FilledList<T>(item, EmptyList.instance)
    static def apply<T>(item : T, tail : ImList<T>) : ImList<T>  = FilledList<T>(item, tail)

    def iterator : Iterator<T> = {
        val i = ListIterator<T>()
        i.list = self
        i
    }
    def tail : ImList<T>
    def filter(f : T -> bool) : ImList<T>
    def reverse : ImList<T>

    def insert<C extends Comparable<C>>(self : ImList<C>, item : C) : ImList<T>
}

case class FilledList<T>(head : T, tail : ImList<T>) extends ImList<T> {
    def headOpt : T? = head
    val count : uint = tail.count + 1
    def isEmpty = false
    def filter(f : T -> bool) : ImList<T> =
        if(f(head)) FilledList<T>(head, tail.filter(f))
        else tail.filter(f)

    def reverse : ImList<T> = reverseAndAdd(EmptyList.instance.cast<ImList<T>>)
    private def reverseAndAdd(list : ImList<T>) : ImList<T> = {
        var ret = FilledList<T>(head, list)
        var l = tail
        while(!l.isEmpty) {
            ret = FilledList<T>(l.cast<FilledList<T>>.head, ret)
            l = l.tail
        }
        ret
    }

    def for(each : T -> void) {
        var list : FilledList<T> = self
        while(true) {
            each(list.head)
            val tail = list.tail
            if(tail.isEmpty) return nil
            list = tail.cast<FilledList<T>>
        }
    }

    def insert<C extends Comparable<C>>(self : FilledList<C>, item : C) : ImList<T> = {
        var before = ImList<T>()
        var list : FilledList<T> = self
        while(true) {
            val h = list.head
            if(item.compare(h) < 0) {
                return FilledList(item.cast<T>, before).reverseAndAdd(list)
            }
            before = ImList<T>(h, before)

            if(list.tail.isEmpty) {
                return FilledList(item.cast<T>, before).reverse
            }
            list = list.tail.cast<FilledList<T>>
        }
    }
}

case class EmptyList<T> extends ImList<T> {
    def count : uint = 0
    def head : T = throw "List is empty"
    def headOpt : T? = nil
    def tail : ImList<T> = self
    def isEmpty = true

    static val instance = EmptyList<any>()
    def filter(f : T -> bool) : ImList<T> = self
    def reverse : ImList<T> = self
    def for(each : T -> void) {
    }

    def insert<C extends Comparable<C>>(self : ImList<C>, item : C) : ImList<T> = ImList(item.cast<T>)
}

class ListIterator<T> extends Iterator<T> {
    var list : ImList<T>
    def hasNext = !list.isEmpty

    def next : T = {
        val ret = list.head
        list = list.tail
        ret
    }
}

class ImListBuilder<T> extends Builder<T, ImList<T>> {
    private var list = ImList<T>()
    def append(item : T) {
        list = ImList(item, list)
    }
    def build : ImList<T> = list.reverse
}