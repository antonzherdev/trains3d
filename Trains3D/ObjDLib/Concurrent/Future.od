package core.chain

class Future<T> {
    static def apply<T>(f : () -> T) : Future<T> = {
        val p = Promise<T>()
        DispatchQueue.default.async {
            p.success(f())
        }
        p
    }

    static def successful<T>(result : T) : Future<T> = KeptPromise<T>(Success(result))

    def result : Try<T>?
    def isCompleted : bool = result.isDefined
    def isSucceeded : bool = result.isDefined && result.get.isSuccess
    def isFailed : bool = result.isDefined && result.get.isFailure

    def onComplete(f : Try<T> -> void)

    def onSuccess(f : T -> void) {
        onComplete{t ->
            if(t.isSuccess) f(t.get)
        }
    }

    def onFailure(f : any -> void) {
        onComplete{t ->
            if(t.isFailure) f(t.reason)
        }
    }

    def map<R>(f : T -> R) : Future<R> = {
        val p = Promise<R>()
        onComplete{tr ->
            p.complete(tr.map(f))
        }
        p
    }

    def for(f : T -> void) : Future<void> = {
        val p = Promise<void>()
        onComplete{tr ->
            if(tr.isSuccess) {
                f(tr.get)
                p.success(nil)
            } else p.complete(tr)
        }
        p
    }

    def flatMap<R>(f : T -> Future<R>) : Future<R> = {
        val p = Promise<R>()
        onComplete{tr ->
            if(tr.isFailure) {
                p.complete(tr.cast<Try<R>>)
            } else {
                val fut = f(tr.get)
                fut.onComplete {ftr ->
                    p.complete(ftr)
                }
            }
        }
        p
    }

    def waitResult(period : float) : Try<T>? = {
        val lock = ConditionLock(0)
        onComplete { _ ->
            lock.lock
            lock.unlockWith(condition = 1)
        }
        if(lock.lockWhen(condition = 1, period)) {
            lock.unlock
        }
        result
    }

    def waitResult : Try<T> = {
        val lock = ConditionLock(0)
        onComplete { _ ->
            lock.lock
            lock.unlockWith(condition = 1)
        }
        lock.lockWhen(condition = 1)
        lock.unlock
        result.get
    }

    def forSuccess(await : float, f : T -> void) {
        val r = waitResult(await)
        if(r.isDefined) {
            val tr = r.get
            if(tr.isSuccess) {
                f(tr.get)
            }
        }
    }

    def flatForSuccess<I>(self : Future<Traversable<I>>, await : float, f : I -> void) {
        forSuccess(await) {tr ->
            tr.cast<Traversable<I>>.for(f)
        }
    }
}

class Promise<T> extends Future<T> {
    static def apply<T> : Promise<T> = DefaultPromise<T>()

    def complete(value : Try<T>): bool
    def success(value : T) : bool
    def failure(reason : any): bool
}

class DefaultPromise<T> extends Promise<T> {
    private val _state = AtomicObject<any>([])
    def result : Try<T>? = {
        val v = _state.value
        if(v.is<Try<T>>) v.cast<Try<T>>
        else nil
    }

    def complete(value : Try<T>) : bool = {
        while(true) {
            val v = _state.value
            if(v.is<Try<T>>) return false
            else {
                if(_state.compareAndSet(v, value)) {
                    v.cast<[Try<T> -> void]>.for{f -> f(value)}
                    return true
                }
            }
        }
        false
    }

    def success(value : T) : bool = {
        complete(Success(value))
    }

    def failure(reason : any) : bool = {
        complete(Failure<T>(result))
    }

    def onComplete(f : Try<T> -> void) {
        while(true) {
            val v = _state.value
            if(v.is<Try<T>>) {
                f(v.cast<Try<T>>)
                return nil
            } else {
                val vv = v.cast<[Try<T> -> void]>
                if(_state.compareAndSet(vv, vv + f)) {
                    return nil
                }
            }
        }
    }

}

class KeptPromise<T>(value : Try<T>) extends Promise<T> {
    def result : Try<T>? = value

    def onComplete(f : Try<T> -> void) {
        f(value)
    }

    def waitResult(period : float) : Try<T>? = value

    def waitResult : Try<T> = value
}